Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> globalVarDeclar functionDeclar main
Rule 2     globalVarDeclar -> GLOBAL { initVarDeclar }
Rule 3     initVarDeclar -> varDeclar initVarDeclar
Rule 4     initVarDeclar -> <empty>
Rule 5     functionDeclar -> function functionDeclar
Rule 6     functionDeclar -> <empty>
Rule 7     varDeclar -> vars ;
Rule 8     varDeclar -> ARRAY arrays ;
Rule 9     vars -> type ID = expression moreVar
Rule 10    moreVar -> , ID = expression moreVar
Rule 11    moreVar -> <empty>
Rule 12    type -> INTTYPE
Rule 13    type -> FLOATTYPE
Rule 14    type -> STRINGTYPE
Rule 15    type -> BOOLTYPE
Rule 16    arrays -> type ID [ constant ] = { expression moreExp } moreArray
Rule 17    moreExp -> , expression moreExp
Rule 18    moreExp -> <empty>
Rule 19    moreArray -> , ID [ constant ] = { expression moreExp } moreArray
Rule 20    moreArray -> <empty>
Rule 21    function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; }
Rule 22    funcType -> type
Rule 23    funcType -> VOID
Rule 24    returnType -> expression
Rule 25    returnType -> VOID
Rule 26    main -> MAIN ( par ) { block }
Rule 27    par -> type ID morePar
Rule 28    par -> <empty>
Rule 29    morePar -> , type ID morePar
Rule 30    morePar -> <empty>
Rule 31    funcCall -> ID ( parIn )
Rule 32    parIn -> expression moreParIn
Rule 33    parIn -> <empty>
Rule 34    moreParIn -> , expression moreParIn
Rule 35    moreParIn -> <empty>
Rule 36    block -> varDeclar block
Rule 37    block -> assign ; block
Rule 38    block -> conditional block
Rule 39    block -> loop block
Rule 40    block -> funcCall ; block
Rule 41    block -> output block
Rule 42    block -> input block
Rule 43    block -> <empty>
Rule 44    loopBlock -> assign ; loopBlock
Rule 45    loopBlock -> conditional loopBlock
Rule 46    loopBlock -> loop loopBlock
Rule 47    loopBlock -> funcCall ; loopBlock
Rule 48    loopBlock -> output loopBlock
Rule 49    loopBlock -> input loopBlock
Rule 50    loopBlock -> <empty>
Rule 51    assign -> ID possibleArray = expression
Rule 52    possibleArray -> [ exp ]
Rule 53    possibleArray -> <empty>
Rule 54    conditional -> IF ( expression ) { block } possibleElif possibleElse
Rule 55    possibleElif -> ELIF ( expression ) { block } possibleElif
Rule 56    possibleElif -> <empty>
Rule 57    possibleElse -> ELSE { block }
Rule 58    possibleElse -> <empty>
Rule 59    output -> CONSOLE ( expression ) ;
Rule 60    loop -> for
Rule 61    loop -> while
Rule 62    loop -> doWhile
Rule 63    for -> FOR ( expression ; assign ) { loopBlock }
Rule 64    while -> WHILE ( expression ) { loopBlock }
Rule 65    doWhile -> DO { loopBlock } WHILE ( expression ) ;
Rule 66    expression -> higherExp possibleHigherExp
Rule 67    possibleHigherExp -> possibleHigherExpOp higherExp
Rule 68    possibleHigherExp -> <empty>
Rule 69    possibleHigherExpOp -> AND
Rule 70    possibleHigherExpOp -> OR
Rule 71    higherExp -> exp possibleExp
Rule 72    possibleExp -> possibleExpOp exp
Rule 73    possibleExp -> <empty>
Rule 74    possibleExpOp -> LESS
Rule 75    possibleExpOp -> GREATER
Rule 76    possibleExpOp -> LESSEQUAL
Rule 77    possibleExpOp -> GREATEREQUAL
Rule 78    possibleExpOp -> DIFFERENT
Rule 79    possibleExpOp -> EQUALTO
Rule 80    exp -> term possibleTerms
Rule 81    possibleTerms -> possibleTermOp term possibleTerms
Rule 82    possibleTerms -> <empty>
Rule 83    possibleTermOp -> +
Rule 84    possibleTermOp -> -
Rule 85    term -> factor possibleFactors
Rule 86    possibleFactors -> possibleFactorOp factor possibleFactors
Rule 87    possibleFactors -> <empty>
Rule 88    possibleFactorOp -> *
Rule 89    possibleFactorOp -> /
Rule 90    possibleFactorOp -> %
Rule 91    factor -> ( expression )
Rule 92    factor -> data
Rule 93    data -> ID possibleIdCall
Rule 94    data -> constant
Rule 95    data -> input
Rule 96    possibleIdCall -> [ expression ]
Rule 97    possibleIdCall -> ( parIn )
Rule 98    possibleIdCall -> <empty>
Rule 99    constant -> INT
Rule 100   constant -> FLOAT
Rule 101   constant -> TRUE
Rule 102   constant -> FALSE
Rule 103   constant -> STRING
Rule 104   input -> INPUT ( inputPar )
Rule 105   inputPar -> STRING
Rule 106   inputPar -> <empty>

Terminals, with rules where they appear

%                    : 90
(                    : 21 26 31 54 55 59 63 64 65 91 97 104
)                    : 21 26 31 54 55 59 63 64 65 91 97 104
*                    : 88
+                    : 83
,                    : 10 17 19 29 34
-                    : 84
/                    : 89
;                    : 7 8 21 37 40 44 47 59 63 65
=                    : 9 10 16 19 51
AND                  : 69
ARRAY                : 8
BOOLTYPE             : 15
CONSOLE              : 59
DIFFERENT            : 78
DO                   : 65
ELIF                 : 55
ELSE                 : 57
EQUALTO              : 79
FALSE                : 102
FLOAT                : 100
FLOATTYPE            : 13
FOR                  : 63
FUNCTION             : 21
GLOBAL               : 2
GREATER              : 75
GREATEREQUAL         : 77
ID                   : 9 10 16 19 21 27 29 31 51 93
IF                   : 54
INPUT                : 104
INT                  : 99
INTTYPE              : 12
LESS                 : 74
LESSEQUAL            : 76
MAIN                 : 26
OR                   : 70
RETURN               : 21
STRING               : 103 105
STRINGTYPE           : 14
TRUE                 : 101
VOID                 : 23 25
WHILE                : 64 65
[                    : 16 19 52 96
]                    : 16 19 52 96
error                : 
{                    : 2 16 19 21 26 54 55 57 63 64 65
}                    : 2 16 19 21 26 54 55 57 63 64 65

Nonterminals, with rules where they appear

arrays               : 8
assign               : 37 44 63
block                : 21 26 36 37 38 39 40 41 42 54 55 57
conditional          : 38 45
constant             : 16 19 94
data                 : 92
doWhile              : 62
exp                  : 52 71 72
expression           : 9 10 16 17 19 24 32 34 51 54 55 59 63 64 65 91 96
factor               : 85 86
for                  : 60
funcCall             : 40 47
funcType             : 21
function             : 5
functionDeclar       : 1 5
globalVarDeclar      : 1
higherExp            : 66 67
initVarDeclar        : 2 3
input                : 42 49 95
inputPar             : 104
loop                 : 39 46
loopBlock            : 44 45 46 47 48 49 63 64 65
main                 : 1
moreArray            : 16 19
moreExp              : 16 17 19
morePar              : 27 29
moreParIn            : 32 34
moreVar              : 9 10
output               : 41 48
par                  : 21 26
parIn                : 31 97
possibleArray        : 51
possibleElif         : 54 55
possibleElse         : 54
possibleExp          : 71
possibleExpOp        : 72
possibleFactorOp     : 86
possibleFactors      : 85 86
possibleHigherExp    : 66
possibleHigherExpOp  : 67
possibleIdCall       : 93
possibleTermOp       : 81
possibleTerms        : 80 81
program              : 0
returnType           : 21
term                 : 80 81
type                 : 9 16 22 27 29
varDeclar            : 3 36
vars                 : 7
while                : 61

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . globalVarDeclar functionDeclar main
    (2) globalVarDeclar -> . GLOBAL { initVarDeclar }

    GLOBAL          shift and go to state 1

    program                        shift and go to state 3
    globalVarDeclar                shift and go to state 2

state 1

    (2) globalVarDeclar -> GLOBAL . { initVarDeclar }

    {               shift and go to state 4


state 2

    (1) program -> globalVarDeclar . functionDeclar main
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (21) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 6

    function                       shift and go to state 5
    functionDeclar                 shift and go to state 7

state 3

    (0) S' -> program .



state 4

    (2) globalVarDeclar -> GLOBAL { . initVarDeclar }
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 10
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    initVarDeclar                  shift and go to state 15
    varDeclar                      shift and go to state 16
    type                           shift and go to state 14

state 5

    (5) functionDeclar -> function . functionDeclar
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (21) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 6

    function                       shift and go to state 5
    functionDeclar                 shift and go to state 17

state 6

    (21) function -> FUNCTION . funcType ID ( par ) { block RETURN returnType ; }
    (22) funcType -> . type
    (23) funcType -> . VOID
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    VOID            shift and go to state 18
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    funcType                       shift and go to state 19
    type                           shift and go to state 20

state 7

    (1) program -> globalVarDeclar functionDeclar . main
    (26) main -> . MAIN ( par ) { block }

    MAIN            shift and go to state 22

    main                           shift and go to state 21

state 8

    (15) type -> BOOLTYPE .

    ID              reduce using rule 15 (type -> BOOLTYPE .)


state 9

    (14) type -> STRINGTYPE .

    ID              reduce using rule 14 (type -> STRINGTYPE .)


state 10

    (8) varDeclar -> ARRAY . arrays ;
    (16) arrays -> . type ID [ constant ] = { expression moreExp } moreArray
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    arrays                         shift and go to state 23
    type                           shift and go to state 24

state 11

    (12) type -> INTTYPE .

    ID              reduce using rule 12 (type -> INTTYPE .)


state 12

    (7) varDeclar -> vars . ;

    ;               shift and go to state 25


state 13

    (13) type -> FLOATTYPE .

    ID              reduce using rule 13 (type -> FLOATTYPE .)


state 14

    (9) vars -> type . ID = expression moreVar

    ID              shift and go to state 26


state 15

    (2) globalVarDeclar -> GLOBAL { initVarDeclar . }

    }               shift and go to state 27


state 16

    (3) initVarDeclar -> varDeclar . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 10
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    initVarDeclar                  shift and go to state 28
    varDeclar                      shift and go to state 16
    type                           shift and go to state 14

state 17

    (5) functionDeclar -> function functionDeclar .

    MAIN            reduce using rule 5 (functionDeclar -> function functionDeclar .)


state 18

    (23) funcType -> VOID .

    ID              reduce using rule 23 (funcType -> VOID .)


state 19

    (21) function -> FUNCTION funcType . ID ( par ) { block RETURN returnType ; }

    ID              shift and go to state 29


state 20

    (22) funcType -> type .

    ID              reduce using rule 22 (funcType -> type .)


state 21

    (1) program -> globalVarDeclar functionDeclar main .

    $end            reduce using rule 1 (program -> globalVarDeclar functionDeclar main .)


state 22

    (26) main -> MAIN . ( par ) { block }

    (               shift and go to state 30


state 23

    (8) varDeclar -> ARRAY arrays . ;

    ;               shift and go to state 31


state 24

    (16) arrays -> type . ID [ constant ] = { expression moreExp } moreArray

    ID              shift and go to state 32


state 25

    (7) varDeclar -> vars ; .

    ARRAY           reduce using rule 7 (varDeclar -> vars ; .)
    ID              reduce using rule 7 (varDeclar -> vars ; .)
    IF              reduce using rule 7 (varDeclar -> vars ; .)
    CONSOLE         reduce using rule 7 (varDeclar -> vars ; .)
    INPUT           reduce using rule 7 (varDeclar -> vars ; .)
    FOR             reduce using rule 7 (varDeclar -> vars ; .)
    WHILE           reduce using rule 7 (varDeclar -> vars ; .)
    DO              reduce using rule 7 (varDeclar -> vars ; .)
    INTTYPE         reduce using rule 7 (varDeclar -> vars ; .)
    FLOATTYPE       reduce using rule 7 (varDeclar -> vars ; .)
    STRINGTYPE      reduce using rule 7 (varDeclar -> vars ; .)
    BOOLTYPE        reduce using rule 7 (varDeclar -> vars ; .)
    RETURN          reduce using rule 7 (varDeclar -> vars ; .)
    }               reduce using rule 7 (varDeclar -> vars ; .)


state 26

    (9) vars -> type ID . = expression moreVar

    =               shift and go to state 33


state 27

    (2) globalVarDeclar -> GLOBAL { initVarDeclar } .

    FUNCTION        reduce using rule 2 (globalVarDeclar -> GLOBAL { initVarDeclar } .)
    MAIN            reduce using rule 2 (globalVarDeclar -> GLOBAL { initVarDeclar } .)


state 28

    (3) initVarDeclar -> varDeclar initVarDeclar .

    }               reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)


state 29

    (21) function -> FUNCTION funcType ID . ( par ) { block RETURN returnType ; }

    (               shift and go to state 34


state 30

    (26) main -> MAIN ( . par ) { block }
    (27) par -> . type ID morePar
    (28) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 28 (par -> .)
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    par                            shift and go to state 35
    type                           shift and go to state 36

state 31

    (8) varDeclar -> ARRAY arrays ; .

    ARRAY           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    ID              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    IF              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    CONSOLE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INPUT           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FOR             reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    WHILE           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    DO              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INTTYPE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FLOATTYPE       reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    STRINGTYPE      reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    BOOLTYPE        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    RETURN          reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    }               reduce using rule 8 (varDeclar -> ARRAY arrays ; .)


state 32

    (16) arrays -> type ID . [ constant ] = { expression moreExp } moreArray

    [               shift and go to state 37


state 33

    (9) vars -> type ID = . expression moreVar
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    input                          shift and go to state 43
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    expression                     shift and go to state 53

state 34

    (21) function -> FUNCTION funcType ID ( . par ) { block RETURN returnType ; }
    (27) par -> . type ID morePar
    (28) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 28 (par -> .)
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    par                            shift and go to state 54
    type                           shift and go to state 36

state 35

    (26) main -> MAIN ( par . ) { block }

    )               shift and go to state 55


state 36

    (27) par -> type . ID morePar

    ID              shift and go to state 56


state 37

    (16) arrays -> type ID [ . constant ] = { expression moreExp } moreArray
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING

    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44

    constant                       shift and go to state 57

state 38

    (94) data -> constant .

    *               reduce using rule 94 (data -> constant .)
    /               reduce using rule 94 (data -> constant .)
    %               reduce using rule 94 (data -> constant .)
    +               reduce using rule 94 (data -> constant .)
    -               reduce using rule 94 (data -> constant .)
    LESS            reduce using rule 94 (data -> constant .)
    GREATER         reduce using rule 94 (data -> constant .)
    LESSEQUAL       reduce using rule 94 (data -> constant .)
    GREATEREQUAL    reduce using rule 94 (data -> constant .)
    DIFFERENT       reduce using rule 94 (data -> constant .)
    EQUALTO         reduce using rule 94 (data -> constant .)
    AND             reduce using rule 94 (data -> constant .)
    OR              reduce using rule 94 (data -> constant .)
    ,               reduce using rule 94 (data -> constant .)
    ;               reduce using rule 94 (data -> constant .)
    )               reduce using rule 94 (data -> constant .)
    ]               reduce using rule 94 (data -> constant .)
    }               reduce using rule 94 (data -> constant .)


state 39

    (85) term -> factor . possibleFactors
    (86) possibleFactors -> . possibleFactorOp factor possibleFactors
    (87) possibleFactors -> .
    (88) possibleFactorOp -> . *
    (89) possibleFactorOp -> . /
    (90) possibleFactorOp -> . %

    +               reduce using rule 87 (possibleFactors -> .)
    -               reduce using rule 87 (possibleFactors -> .)
    LESS            reduce using rule 87 (possibleFactors -> .)
    GREATER         reduce using rule 87 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 87 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 87 (possibleFactors -> .)
    DIFFERENT       reduce using rule 87 (possibleFactors -> .)
    EQUALTO         reduce using rule 87 (possibleFactors -> .)
    AND             reduce using rule 87 (possibleFactors -> .)
    OR              reduce using rule 87 (possibleFactors -> .)
    ,               reduce using rule 87 (possibleFactors -> .)
    ;               reduce using rule 87 (possibleFactors -> .)
    )               reduce using rule 87 (possibleFactors -> .)
    ]               reduce using rule 87 (possibleFactors -> .)
    }               reduce using rule 87 (possibleFactors -> .)
    *               shift and go to state 59
    /               shift and go to state 61
    %               shift and go to state 58

    possibleFactors                shift and go to state 60
    possibleFactorOp               shift and go to state 62

state 40

    (101) constant -> TRUE .

    *               reduce using rule 101 (constant -> TRUE .)
    /               reduce using rule 101 (constant -> TRUE .)
    %               reduce using rule 101 (constant -> TRUE .)
    +               reduce using rule 101 (constant -> TRUE .)
    -               reduce using rule 101 (constant -> TRUE .)
    ]               reduce using rule 101 (constant -> TRUE .)
    LESS            reduce using rule 101 (constant -> TRUE .)
    GREATER         reduce using rule 101 (constant -> TRUE .)
    LESSEQUAL       reduce using rule 101 (constant -> TRUE .)
    GREATEREQUAL    reduce using rule 101 (constant -> TRUE .)
    DIFFERENT       reduce using rule 101 (constant -> TRUE .)
    EQUALTO         reduce using rule 101 (constant -> TRUE .)
    AND             reduce using rule 101 (constant -> TRUE .)
    OR              reduce using rule 101 (constant -> TRUE .)
    ,               reduce using rule 101 (constant -> TRUE .)
    }               reduce using rule 101 (constant -> TRUE .)
    ;               reduce using rule 101 (constant -> TRUE .)
    )               reduce using rule 101 (constant -> TRUE .)


state 41

    (92) factor -> data .

    *               reduce using rule 92 (factor -> data .)
    /               reduce using rule 92 (factor -> data .)
    %               reduce using rule 92 (factor -> data .)
    +               reduce using rule 92 (factor -> data .)
    -               reduce using rule 92 (factor -> data .)
    LESS            reduce using rule 92 (factor -> data .)
    GREATER         reduce using rule 92 (factor -> data .)
    LESSEQUAL       reduce using rule 92 (factor -> data .)
    GREATEREQUAL    reduce using rule 92 (factor -> data .)
    DIFFERENT       reduce using rule 92 (factor -> data .)
    EQUALTO         reduce using rule 92 (factor -> data .)
    AND             reduce using rule 92 (factor -> data .)
    OR              reduce using rule 92 (factor -> data .)
    )               reduce using rule 92 (factor -> data .)
    ;               reduce using rule 92 (factor -> data .)
    ,               reduce using rule 92 (factor -> data .)
    }               reduce using rule 92 (factor -> data .)
    ]               reduce using rule 92 (factor -> data .)


state 42

    (66) expression -> higherExp . possibleHigherExp
    (67) possibleHigherExp -> . possibleHigherExpOp higherExp
    (68) possibleHigherExp -> .
    (69) possibleHigherExpOp -> . AND
    (70) possibleHigherExpOp -> . OR

    ,               reduce using rule 68 (possibleHigherExp -> .)
    ;               reduce using rule 68 (possibleHigherExp -> .)
    )               reduce using rule 68 (possibleHigherExp -> .)
    ]               reduce using rule 68 (possibleHigherExp -> .)
    }               reduce using rule 68 (possibleHigherExp -> .)
    AND             shift and go to state 63
    OR              shift and go to state 66

    possibleHigherExpOp            shift and go to state 64
    possibleHigherExp              shift and go to state 65

state 43

    (95) data -> input .

    *               reduce using rule 95 (data -> input .)
    /               reduce using rule 95 (data -> input .)
    %               reduce using rule 95 (data -> input .)
    +               reduce using rule 95 (data -> input .)
    -               reduce using rule 95 (data -> input .)
    LESS            reduce using rule 95 (data -> input .)
    GREATER         reduce using rule 95 (data -> input .)
    LESSEQUAL       reduce using rule 95 (data -> input .)
    GREATEREQUAL    reduce using rule 95 (data -> input .)
    DIFFERENT       reduce using rule 95 (data -> input .)
    EQUALTO         reduce using rule 95 (data -> input .)
    AND             reduce using rule 95 (data -> input .)
    OR              reduce using rule 95 (data -> input .)
    ,               reduce using rule 95 (data -> input .)
    ;               reduce using rule 95 (data -> input .)
    )               reduce using rule 95 (data -> input .)
    ]               reduce using rule 95 (data -> input .)
    }               reduce using rule 95 (data -> input .)


state 44

    (103) constant -> STRING .

    *               reduce using rule 103 (constant -> STRING .)
    /               reduce using rule 103 (constant -> STRING .)
    %               reduce using rule 103 (constant -> STRING .)
    +               reduce using rule 103 (constant -> STRING .)
    -               reduce using rule 103 (constant -> STRING .)
    ]               reduce using rule 103 (constant -> STRING .)
    LESS            reduce using rule 103 (constant -> STRING .)
    GREATER         reduce using rule 103 (constant -> STRING .)
    LESSEQUAL       reduce using rule 103 (constant -> STRING .)
    GREATEREQUAL    reduce using rule 103 (constant -> STRING .)
    DIFFERENT       reduce using rule 103 (constant -> STRING .)
    EQUALTO         reduce using rule 103 (constant -> STRING .)
    AND             reduce using rule 103 (constant -> STRING .)
    OR              reduce using rule 103 (constant -> STRING .)
    ,               reduce using rule 103 (constant -> STRING .)
    }               reduce using rule 103 (constant -> STRING .)
    ;               reduce using rule 103 (constant -> STRING .)
    )               reduce using rule 103 (constant -> STRING .)


state 45

    (104) input -> INPUT . ( inputPar )

    (               shift and go to state 67


state 46

    (93) data -> ID . possibleIdCall
    (96) possibleIdCall -> . [ expression ]
    (97) possibleIdCall -> . ( parIn )
    (98) possibleIdCall -> .

    [               shift and go to state 70
    (               shift and go to state 69
    *               reduce using rule 98 (possibleIdCall -> .)
    /               reduce using rule 98 (possibleIdCall -> .)
    %               reduce using rule 98 (possibleIdCall -> .)
    +               reduce using rule 98 (possibleIdCall -> .)
    -               reduce using rule 98 (possibleIdCall -> .)
    LESS            reduce using rule 98 (possibleIdCall -> .)
    GREATER         reduce using rule 98 (possibleIdCall -> .)
    LESSEQUAL       reduce using rule 98 (possibleIdCall -> .)
    GREATEREQUAL    reduce using rule 98 (possibleIdCall -> .)
    DIFFERENT       reduce using rule 98 (possibleIdCall -> .)
    EQUALTO         reduce using rule 98 (possibleIdCall -> .)
    AND             reduce using rule 98 (possibleIdCall -> .)
    OR              reduce using rule 98 (possibleIdCall -> .)
    ,               reduce using rule 98 (possibleIdCall -> .)
    ;               reduce using rule 98 (possibleIdCall -> .)
    )               reduce using rule 98 (possibleIdCall -> .)
    ]               reduce using rule 98 (possibleIdCall -> .)
    }               reduce using rule 98 (possibleIdCall -> .)

    possibleIdCall                 shift and go to state 68

state 47

    (80) exp -> term . possibleTerms
    (81) possibleTerms -> . possibleTermOp term possibleTerms
    (82) possibleTerms -> .
    (83) possibleTermOp -> . +
    (84) possibleTermOp -> . -

    LESS            reduce using rule 82 (possibleTerms -> .)
    GREATER         reduce using rule 82 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 82 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 82 (possibleTerms -> .)
    DIFFERENT       reduce using rule 82 (possibleTerms -> .)
    EQUALTO         reduce using rule 82 (possibleTerms -> .)
    AND             reduce using rule 82 (possibleTerms -> .)
    OR              reduce using rule 82 (possibleTerms -> .)
    ,               reduce using rule 82 (possibleTerms -> .)
    ;               reduce using rule 82 (possibleTerms -> .)
    )               reduce using rule 82 (possibleTerms -> .)
    ]               reduce using rule 82 (possibleTerms -> .)
    }               reduce using rule 82 (possibleTerms -> .)
    +               shift and go to state 74
    -               shift and go to state 73

    possibleTermOp                 shift and go to state 71
    possibleTerms                  shift and go to state 72

state 48

    (102) constant -> FALSE .

    *               reduce using rule 102 (constant -> FALSE .)
    /               reduce using rule 102 (constant -> FALSE .)
    %               reduce using rule 102 (constant -> FALSE .)
    +               reduce using rule 102 (constant -> FALSE .)
    -               reduce using rule 102 (constant -> FALSE .)
    ]               reduce using rule 102 (constant -> FALSE .)
    LESS            reduce using rule 102 (constant -> FALSE .)
    GREATER         reduce using rule 102 (constant -> FALSE .)
    LESSEQUAL       reduce using rule 102 (constant -> FALSE .)
    GREATEREQUAL    reduce using rule 102 (constant -> FALSE .)
    DIFFERENT       reduce using rule 102 (constant -> FALSE .)
    EQUALTO         reduce using rule 102 (constant -> FALSE .)
    AND             reduce using rule 102 (constant -> FALSE .)
    OR              reduce using rule 102 (constant -> FALSE .)
    ,               reduce using rule 102 (constant -> FALSE .)
    }               reduce using rule 102 (constant -> FALSE .)
    ;               reduce using rule 102 (constant -> FALSE .)
    )               reduce using rule 102 (constant -> FALSE .)


state 49

    (99) constant -> INT .

    *               reduce using rule 99 (constant -> INT .)
    /               reduce using rule 99 (constant -> INT .)
    %               reduce using rule 99 (constant -> INT .)
    +               reduce using rule 99 (constant -> INT .)
    -               reduce using rule 99 (constant -> INT .)
    ]               reduce using rule 99 (constant -> INT .)
    LESS            reduce using rule 99 (constant -> INT .)
    GREATER         reduce using rule 99 (constant -> INT .)
    LESSEQUAL       reduce using rule 99 (constant -> INT .)
    GREATEREQUAL    reduce using rule 99 (constant -> INT .)
    DIFFERENT       reduce using rule 99 (constant -> INT .)
    EQUALTO         reduce using rule 99 (constant -> INT .)
    AND             reduce using rule 99 (constant -> INT .)
    OR              reduce using rule 99 (constant -> INT .)
    ,               reduce using rule 99 (constant -> INT .)
    }               reduce using rule 99 (constant -> INT .)
    ;               reduce using rule 99 (constant -> INT .)
    )               reduce using rule 99 (constant -> INT .)


state 50

    (100) constant -> FLOAT .

    *               reduce using rule 100 (constant -> FLOAT .)
    /               reduce using rule 100 (constant -> FLOAT .)
    %               reduce using rule 100 (constant -> FLOAT .)
    +               reduce using rule 100 (constant -> FLOAT .)
    -               reduce using rule 100 (constant -> FLOAT .)
    ]               reduce using rule 100 (constant -> FLOAT .)
    LESS            reduce using rule 100 (constant -> FLOAT .)
    GREATER         reduce using rule 100 (constant -> FLOAT .)
    LESSEQUAL       reduce using rule 100 (constant -> FLOAT .)
    GREATEREQUAL    reduce using rule 100 (constant -> FLOAT .)
    DIFFERENT       reduce using rule 100 (constant -> FLOAT .)
    EQUALTO         reduce using rule 100 (constant -> FLOAT .)
    AND             reduce using rule 100 (constant -> FLOAT .)
    OR              reduce using rule 100 (constant -> FLOAT .)
    ,               reduce using rule 100 (constant -> FLOAT .)
    }               reduce using rule 100 (constant -> FLOAT .)
    ;               reduce using rule 100 (constant -> FLOAT .)
    )               reduce using rule 100 (constant -> FLOAT .)


state 51

    (71) higherExp -> exp . possibleExp
    (72) possibleExp -> . possibleExpOp exp
    (73) possibleExp -> .
    (74) possibleExpOp -> . LESS
    (75) possibleExpOp -> . GREATER
    (76) possibleExpOp -> . LESSEQUAL
    (77) possibleExpOp -> . GREATEREQUAL
    (78) possibleExpOp -> . DIFFERENT
    (79) possibleExpOp -> . EQUALTO

    AND             reduce using rule 73 (possibleExp -> .)
    OR              reduce using rule 73 (possibleExp -> .)
    ,               reduce using rule 73 (possibleExp -> .)
    ;               reduce using rule 73 (possibleExp -> .)
    )               reduce using rule 73 (possibleExp -> .)
    ]               reduce using rule 73 (possibleExp -> .)
    }               reduce using rule 73 (possibleExp -> .)
    LESS            shift and go to state 78
    GREATER         shift and go to state 76
    LESSEQUAL       shift and go to state 82
    GREATEREQUAL    shift and go to state 75
    DIFFERENT       shift and go to state 81
    EQUALTO         shift and go to state 80

    possibleExp                    shift and go to state 79
    possibleExpOp                  shift and go to state 77

state 52

    (91) factor -> ( . expression )
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 83

state 53

    (9) vars -> type ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 85
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 84

state 54

    (21) function -> FUNCTION funcType ID ( par . ) { block RETURN returnType ; }

    )               shift and go to state 86


state 55

    (26) main -> MAIN ( par ) . { block }

    {               shift and go to state 87


state 56

    (27) par -> type ID . morePar
    (29) morePar -> . , type ID morePar
    (30) morePar -> .

    ,               shift and go to state 89
    )               reduce using rule 30 (morePar -> .)

    morePar                        shift and go to state 88

state 57

    (16) arrays -> type ID [ constant . ] = { expression moreExp } moreArray

    ]               shift and go to state 90


state 58

    (90) possibleFactorOp -> % .

    (               reduce using rule 90 (possibleFactorOp -> % .)
    ID              reduce using rule 90 (possibleFactorOp -> % .)
    INT             reduce using rule 90 (possibleFactorOp -> % .)
    FLOAT           reduce using rule 90 (possibleFactorOp -> % .)
    TRUE            reduce using rule 90 (possibleFactorOp -> % .)
    FALSE           reduce using rule 90 (possibleFactorOp -> % .)
    STRING          reduce using rule 90 (possibleFactorOp -> % .)
    INPUT           reduce using rule 90 (possibleFactorOp -> % .)


state 59

    (88) possibleFactorOp -> * .

    (               reduce using rule 88 (possibleFactorOp -> * .)
    ID              reduce using rule 88 (possibleFactorOp -> * .)
    INT             reduce using rule 88 (possibleFactorOp -> * .)
    FLOAT           reduce using rule 88 (possibleFactorOp -> * .)
    TRUE            reduce using rule 88 (possibleFactorOp -> * .)
    FALSE           reduce using rule 88 (possibleFactorOp -> * .)
    STRING          reduce using rule 88 (possibleFactorOp -> * .)
    INPUT           reduce using rule 88 (possibleFactorOp -> * .)


state 60

    (85) term -> factor possibleFactors .

    +               reduce using rule 85 (term -> factor possibleFactors .)
    -               reduce using rule 85 (term -> factor possibleFactors .)
    ]               reduce using rule 85 (term -> factor possibleFactors .)
    LESS            reduce using rule 85 (term -> factor possibleFactors .)
    GREATER         reduce using rule 85 (term -> factor possibleFactors .)
    LESSEQUAL       reduce using rule 85 (term -> factor possibleFactors .)
    GREATEREQUAL    reduce using rule 85 (term -> factor possibleFactors .)
    DIFFERENT       reduce using rule 85 (term -> factor possibleFactors .)
    EQUALTO         reduce using rule 85 (term -> factor possibleFactors .)
    AND             reduce using rule 85 (term -> factor possibleFactors .)
    OR              reduce using rule 85 (term -> factor possibleFactors .)
    ,               reduce using rule 85 (term -> factor possibleFactors .)
    ;               reduce using rule 85 (term -> factor possibleFactors .)
    )               reduce using rule 85 (term -> factor possibleFactors .)
    }               reduce using rule 85 (term -> factor possibleFactors .)


state 61

    (89) possibleFactorOp -> / .

    (               reduce using rule 89 (possibleFactorOp -> / .)
    ID              reduce using rule 89 (possibleFactorOp -> / .)
    INT             reduce using rule 89 (possibleFactorOp -> / .)
    FLOAT           reduce using rule 89 (possibleFactorOp -> / .)
    TRUE            reduce using rule 89 (possibleFactorOp -> / .)
    FALSE           reduce using rule 89 (possibleFactorOp -> / .)
    STRING          reduce using rule 89 (possibleFactorOp -> / .)
    INPUT           reduce using rule 89 (possibleFactorOp -> / .)


state 62

    (86) possibleFactors -> possibleFactorOp . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    constant                       shift and go to state 38
    data                           shift and go to state 41
    factor                         shift and go to state 91
    input                          shift and go to state 43

state 63

    (69) possibleHigherExpOp -> AND .

    (               reduce using rule 69 (possibleHigherExpOp -> AND .)
    ID              reduce using rule 69 (possibleHigherExpOp -> AND .)
    INT             reduce using rule 69 (possibleHigherExpOp -> AND .)
    FLOAT           reduce using rule 69 (possibleHigherExpOp -> AND .)
    TRUE            reduce using rule 69 (possibleHigherExpOp -> AND .)
    FALSE           reduce using rule 69 (possibleHigherExpOp -> AND .)
    STRING          reduce using rule 69 (possibleHigherExpOp -> AND .)
    INPUT           reduce using rule 69 (possibleHigherExpOp -> AND .)


state 64

    (67) possibleHigherExp -> possibleHigherExpOp . higherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 92
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43

state 65

    (66) expression -> higherExp possibleHigherExp .

    ;               reduce using rule 66 (expression -> higherExp possibleHigherExp .)
    ]               reduce using rule 66 (expression -> higherExp possibleHigherExp .)
    )               reduce using rule 66 (expression -> higherExp possibleHigherExp .)
    ,               reduce using rule 66 (expression -> higherExp possibleHigherExp .)
    }               reduce using rule 66 (expression -> higherExp possibleHigherExp .)


state 66

    (70) possibleHigherExpOp -> OR .

    (               reduce using rule 70 (possibleHigherExpOp -> OR .)
    ID              reduce using rule 70 (possibleHigherExpOp -> OR .)
    INT             reduce using rule 70 (possibleHigherExpOp -> OR .)
    FLOAT           reduce using rule 70 (possibleHigherExpOp -> OR .)
    TRUE            reduce using rule 70 (possibleHigherExpOp -> OR .)
    FALSE           reduce using rule 70 (possibleHigherExpOp -> OR .)
    STRING          reduce using rule 70 (possibleHigherExpOp -> OR .)
    INPUT           reduce using rule 70 (possibleHigherExpOp -> OR .)


state 67

    (104) input -> INPUT ( . inputPar )
    (105) inputPar -> . STRING
    (106) inputPar -> .

    STRING          shift and go to state 93
    )               reduce using rule 106 (inputPar -> .)

    inputPar                       shift and go to state 94

state 68

    (93) data -> ID possibleIdCall .

    *               reduce using rule 93 (data -> ID possibleIdCall .)
    /               reduce using rule 93 (data -> ID possibleIdCall .)
    %               reduce using rule 93 (data -> ID possibleIdCall .)
    +               reduce using rule 93 (data -> ID possibleIdCall .)
    -               reduce using rule 93 (data -> ID possibleIdCall .)
    LESS            reduce using rule 93 (data -> ID possibleIdCall .)
    GREATER         reduce using rule 93 (data -> ID possibleIdCall .)
    LESSEQUAL       reduce using rule 93 (data -> ID possibleIdCall .)
    GREATEREQUAL    reduce using rule 93 (data -> ID possibleIdCall .)
    DIFFERENT       reduce using rule 93 (data -> ID possibleIdCall .)
    EQUALTO         reduce using rule 93 (data -> ID possibleIdCall .)
    AND             reduce using rule 93 (data -> ID possibleIdCall .)
    OR              reduce using rule 93 (data -> ID possibleIdCall .)
    ,               reduce using rule 93 (data -> ID possibleIdCall .)
    ;               reduce using rule 93 (data -> ID possibleIdCall .)
    )               reduce using rule 93 (data -> ID possibleIdCall .)
    ]               reduce using rule 93 (data -> ID possibleIdCall .)
    }               reduce using rule 93 (data -> ID possibleIdCall .)


state 69

    (97) possibleIdCall -> ( . parIn )
    (32) parIn -> . expression moreParIn
    (33) parIn -> .
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    )               reduce using rule 33 (parIn -> .)
    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    data                           shift and go to state 41
    higherExp                      shift and go to state 42
    parIn                          shift and go to state 95
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 96

state 70

    (96) possibleIdCall -> [ . expression ]
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 97

state 71

    (81) possibleTerms -> possibleTermOp . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 98
    constant                       shift and go to state 38
    data                           shift and go to state 41
    factor                         shift and go to state 39
    input                          shift and go to state 43

state 72

    (80) exp -> term possibleTerms .

    ]               reduce using rule 80 (exp -> term possibleTerms .)
    LESS            reduce using rule 80 (exp -> term possibleTerms .)
    GREATER         reduce using rule 80 (exp -> term possibleTerms .)
    LESSEQUAL       reduce using rule 80 (exp -> term possibleTerms .)
    GREATEREQUAL    reduce using rule 80 (exp -> term possibleTerms .)
    DIFFERENT       reduce using rule 80 (exp -> term possibleTerms .)
    EQUALTO         reduce using rule 80 (exp -> term possibleTerms .)
    AND             reduce using rule 80 (exp -> term possibleTerms .)
    OR              reduce using rule 80 (exp -> term possibleTerms .)
    ;               reduce using rule 80 (exp -> term possibleTerms .)
    )               reduce using rule 80 (exp -> term possibleTerms .)
    ,               reduce using rule 80 (exp -> term possibleTerms .)
    }               reduce using rule 80 (exp -> term possibleTerms .)


state 73

    (84) possibleTermOp -> - .

    (               reduce using rule 84 (possibleTermOp -> - .)
    ID              reduce using rule 84 (possibleTermOp -> - .)
    INT             reduce using rule 84 (possibleTermOp -> - .)
    FLOAT           reduce using rule 84 (possibleTermOp -> - .)
    TRUE            reduce using rule 84 (possibleTermOp -> - .)
    FALSE           reduce using rule 84 (possibleTermOp -> - .)
    STRING          reduce using rule 84 (possibleTermOp -> - .)
    INPUT           reduce using rule 84 (possibleTermOp -> - .)


state 74

    (83) possibleTermOp -> + .

    (               reduce using rule 83 (possibleTermOp -> + .)
    ID              reduce using rule 83 (possibleTermOp -> + .)
    INT             reduce using rule 83 (possibleTermOp -> + .)
    FLOAT           reduce using rule 83 (possibleTermOp -> + .)
    TRUE            reduce using rule 83 (possibleTermOp -> + .)
    FALSE           reduce using rule 83 (possibleTermOp -> + .)
    STRING          reduce using rule 83 (possibleTermOp -> + .)
    INPUT           reduce using rule 83 (possibleTermOp -> + .)


state 75

    (77) possibleExpOp -> GREATEREQUAL .

    (               reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    ID              reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    INT             reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    FLOAT           reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    TRUE            reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    FALSE           reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    STRING          reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)
    INPUT           reduce using rule 77 (possibleExpOp -> GREATEREQUAL .)


state 76

    (75) possibleExpOp -> GREATER .

    (               reduce using rule 75 (possibleExpOp -> GREATER .)
    ID              reduce using rule 75 (possibleExpOp -> GREATER .)
    INT             reduce using rule 75 (possibleExpOp -> GREATER .)
    FLOAT           reduce using rule 75 (possibleExpOp -> GREATER .)
    TRUE            reduce using rule 75 (possibleExpOp -> GREATER .)
    FALSE           reduce using rule 75 (possibleExpOp -> GREATER .)
    STRING          reduce using rule 75 (possibleExpOp -> GREATER .)
    INPUT           reduce using rule 75 (possibleExpOp -> GREATER .)


state 77

    (72) possibleExp -> possibleExpOp . exp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    data                           shift and go to state 41
    exp                            shift and go to state 99
    factor                         shift and go to state 39
    input                          shift and go to state 43

state 78

    (74) possibleExpOp -> LESS .

    (               reduce using rule 74 (possibleExpOp -> LESS .)
    ID              reduce using rule 74 (possibleExpOp -> LESS .)
    INT             reduce using rule 74 (possibleExpOp -> LESS .)
    FLOAT           reduce using rule 74 (possibleExpOp -> LESS .)
    TRUE            reduce using rule 74 (possibleExpOp -> LESS .)
    FALSE           reduce using rule 74 (possibleExpOp -> LESS .)
    STRING          reduce using rule 74 (possibleExpOp -> LESS .)
    INPUT           reduce using rule 74 (possibleExpOp -> LESS .)


state 79

    (71) higherExp -> exp possibleExp .

    AND             reduce using rule 71 (higherExp -> exp possibleExp .)
    OR              reduce using rule 71 (higherExp -> exp possibleExp .)
    ]               reduce using rule 71 (higherExp -> exp possibleExp .)
    )               reduce using rule 71 (higherExp -> exp possibleExp .)
    ,               reduce using rule 71 (higherExp -> exp possibleExp .)
    ;               reduce using rule 71 (higherExp -> exp possibleExp .)
    }               reduce using rule 71 (higherExp -> exp possibleExp .)


state 80

    (79) possibleExpOp -> EQUALTO .

    (               reduce using rule 79 (possibleExpOp -> EQUALTO .)
    ID              reduce using rule 79 (possibleExpOp -> EQUALTO .)
    INT             reduce using rule 79 (possibleExpOp -> EQUALTO .)
    FLOAT           reduce using rule 79 (possibleExpOp -> EQUALTO .)
    TRUE            reduce using rule 79 (possibleExpOp -> EQUALTO .)
    FALSE           reduce using rule 79 (possibleExpOp -> EQUALTO .)
    STRING          reduce using rule 79 (possibleExpOp -> EQUALTO .)
    INPUT           reduce using rule 79 (possibleExpOp -> EQUALTO .)


state 81

    (78) possibleExpOp -> DIFFERENT .

    (               reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    ID              reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    INT             reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    FLOAT           reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    TRUE            reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    FALSE           reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    STRING          reduce using rule 78 (possibleExpOp -> DIFFERENT .)
    INPUT           reduce using rule 78 (possibleExpOp -> DIFFERENT .)


state 82

    (76) possibleExpOp -> LESSEQUAL .

    (               reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    ID              reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    INT             reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    FLOAT           reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    TRUE            reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    FALSE           reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    STRING          reduce using rule 76 (possibleExpOp -> LESSEQUAL .)
    INPUT           reduce using rule 76 (possibleExpOp -> LESSEQUAL .)


state 83

    (91) factor -> ( expression . )

    )               shift and go to state 100


state 84

    (9) vars -> type ID = expression moreVar .

    ;               reduce using rule 9 (vars -> type ID = expression moreVar .)


state 85

    (10) moreVar -> , . ID = expression moreVar

    ID              shift and go to state 101


state 86

    (21) function -> FUNCTION funcType ID ( par ) . { block RETURN returnType ; }

    {               shift and go to state 102


state 87

    (26) main -> MAIN ( par ) { . block }
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 116
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 88

    (27) par -> type ID morePar .

    )               reduce using rule 27 (par -> type ID morePar .)


state 89

    (29) morePar -> , . type ID morePar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    type                           shift and go to state 120

state 90

    (16) arrays -> type ID [ constant ] . = { expression moreExp } moreArray

    =               shift and go to state 121


state 91

    (86) possibleFactors -> possibleFactorOp factor . possibleFactors
    (86) possibleFactors -> . possibleFactorOp factor possibleFactors
    (87) possibleFactors -> .
    (88) possibleFactorOp -> . *
    (89) possibleFactorOp -> . /
    (90) possibleFactorOp -> . %

    +               reduce using rule 87 (possibleFactors -> .)
    -               reduce using rule 87 (possibleFactors -> .)
    LESS            reduce using rule 87 (possibleFactors -> .)
    GREATER         reduce using rule 87 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 87 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 87 (possibleFactors -> .)
    DIFFERENT       reduce using rule 87 (possibleFactors -> .)
    EQUALTO         reduce using rule 87 (possibleFactors -> .)
    AND             reduce using rule 87 (possibleFactors -> .)
    OR              reduce using rule 87 (possibleFactors -> .)
    ,               reduce using rule 87 (possibleFactors -> .)
    ;               reduce using rule 87 (possibleFactors -> .)
    )               reduce using rule 87 (possibleFactors -> .)
    ]               reduce using rule 87 (possibleFactors -> .)
    }               reduce using rule 87 (possibleFactors -> .)
    *               shift and go to state 59
    /               shift and go to state 61
    %               shift and go to state 58

    possibleFactors                shift and go to state 122
    possibleFactorOp               shift and go to state 62

state 92

    (67) possibleHigherExp -> possibleHigherExpOp higherExp .

    ,               reduce using rule 67 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ;               reduce using rule 67 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    )               reduce using rule 67 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ]               reduce using rule 67 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    }               reduce using rule 67 (possibleHigherExp -> possibleHigherExpOp higherExp .)


state 93

    (105) inputPar -> STRING .

    )               reduce using rule 105 (inputPar -> STRING .)


state 94

    (104) input -> INPUT ( inputPar . )

    )               shift and go to state 123


state 95

    (97) possibleIdCall -> ( parIn . )

    )               shift and go to state 124


state 96

    (32) parIn -> expression . moreParIn
    (34) moreParIn -> . , expression moreParIn
    (35) moreParIn -> .

    ,               shift and go to state 126
    )               reduce using rule 35 (moreParIn -> .)

    moreParIn                      shift and go to state 125

state 97

    (96) possibleIdCall -> [ expression . ]

    ]               shift and go to state 127


state 98

    (81) possibleTerms -> possibleTermOp term . possibleTerms
    (81) possibleTerms -> . possibleTermOp term possibleTerms
    (82) possibleTerms -> .
    (83) possibleTermOp -> . +
    (84) possibleTermOp -> . -

    LESS            reduce using rule 82 (possibleTerms -> .)
    GREATER         reduce using rule 82 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 82 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 82 (possibleTerms -> .)
    DIFFERENT       reduce using rule 82 (possibleTerms -> .)
    EQUALTO         reduce using rule 82 (possibleTerms -> .)
    AND             reduce using rule 82 (possibleTerms -> .)
    OR              reduce using rule 82 (possibleTerms -> .)
    ,               reduce using rule 82 (possibleTerms -> .)
    ;               reduce using rule 82 (possibleTerms -> .)
    )               reduce using rule 82 (possibleTerms -> .)
    ]               reduce using rule 82 (possibleTerms -> .)
    }               reduce using rule 82 (possibleTerms -> .)
    +               shift and go to state 74
    -               shift and go to state 73

    possibleTermOp                 shift and go to state 71
    possibleTerms                  shift and go to state 128

state 99

    (72) possibleExp -> possibleExpOp exp .

    AND             reduce using rule 72 (possibleExp -> possibleExpOp exp .)
    OR              reduce using rule 72 (possibleExp -> possibleExpOp exp .)
    ,               reduce using rule 72 (possibleExp -> possibleExpOp exp .)
    ;               reduce using rule 72 (possibleExp -> possibleExpOp exp .)
    )               reduce using rule 72 (possibleExp -> possibleExpOp exp .)
    ]               reduce using rule 72 (possibleExp -> possibleExpOp exp .)
    }               reduce using rule 72 (possibleExp -> possibleExpOp exp .)


state 100

    (91) factor -> ( expression ) .

    *               reduce using rule 91 (factor -> ( expression ) .)
    /               reduce using rule 91 (factor -> ( expression ) .)
    %               reduce using rule 91 (factor -> ( expression ) .)
    +               reduce using rule 91 (factor -> ( expression ) .)
    -               reduce using rule 91 (factor -> ( expression ) .)
    LESS            reduce using rule 91 (factor -> ( expression ) .)
    GREATER         reduce using rule 91 (factor -> ( expression ) .)
    LESSEQUAL       reduce using rule 91 (factor -> ( expression ) .)
    GREATEREQUAL    reduce using rule 91 (factor -> ( expression ) .)
    DIFFERENT       reduce using rule 91 (factor -> ( expression ) .)
    EQUALTO         reduce using rule 91 (factor -> ( expression ) .)
    AND             reduce using rule 91 (factor -> ( expression ) .)
    OR              reduce using rule 91 (factor -> ( expression ) .)
    )               reduce using rule 91 (factor -> ( expression ) .)
    ;               reduce using rule 91 (factor -> ( expression ) .)
    ,               reduce using rule 91 (factor -> ( expression ) .)
    }               reduce using rule 91 (factor -> ( expression ) .)
    ]               reduce using rule 91 (factor -> ( expression ) .)


state 101

    (10) moreVar -> , ID . = expression moreVar

    =               shift and go to state 129


state 102

    (21) function -> FUNCTION funcType ID ( par ) { . block RETURN returnType ; }
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 130
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 103

    (65) doWhile -> DO . { loopBlock } WHILE ( expression ) ;

    {               shift and go to state 131


state 104

    (38) block -> conditional . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    loop                           shift and go to state 119
    output                         shift and go to state 117
    assign                         shift and go to state 118
    block                          shift and go to state 132

state 105

    (62) loop -> doWhile .

    ARRAY           reduce using rule 62 (loop -> doWhile .)
    ID              reduce using rule 62 (loop -> doWhile .)
    IF              reduce using rule 62 (loop -> doWhile .)
    CONSOLE         reduce using rule 62 (loop -> doWhile .)
    INPUT           reduce using rule 62 (loop -> doWhile .)
    FOR             reduce using rule 62 (loop -> doWhile .)
    WHILE           reduce using rule 62 (loop -> doWhile .)
    DO              reduce using rule 62 (loop -> doWhile .)
    INTTYPE         reduce using rule 62 (loop -> doWhile .)
    FLOATTYPE       reduce using rule 62 (loop -> doWhile .)
    STRINGTYPE      reduce using rule 62 (loop -> doWhile .)
    BOOLTYPE        reduce using rule 62 (loop -> doWhile .)
    }               reduce using rule 62 (loop -> doWhile .)
    RETURN          reduce using rule 62 (loop -> doWhile .)


state 106

    (64) while -> WHILE . ( expression ) { loopBlock }

    (               shift and go to state 133


state 107

    (60) loop -> for .

    ARRAY           reduce using rule 60 (loop -> for .)
    ID              reduce using rule 60 (loop -> for .)
    IF              reduce using rule 60 (loop -> for .)
    CONSOLE         reduce using rule 60 (loop -> for .)
    INPUT           reduce using rule 60 (loop -> for .)
    FOR             reduce using rule 60 (loop -> for .)
    WHILE           reduce using rule 60 (loop -> for .)
    DO              reduce using rule 60 (loop -> for .)
    INTTYPE         reduce using rule 60 (loop -> for .)
    FLOATTYPE       reduce using rule 60 (loop -> for .)
    STRINGTYPE      reduce using rule 60 (loop -> for .)
    BOOLTYPE        reduce using rule 60 (loop -> for .)
    }               reduce using rule 60 (loop -> for .)
    RETURN          reduce using rule 60 (loop -> for .)


state 108

    (42) block -> input . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 134
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 109

    (36) block -> varDeclar . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 135
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 110

    (59) output -> CONSOLE . ( expression ) ;

    (               shift and go to state 136


state 111

    (63) for -> FOR . ( expression ; assign ) { loopBlock }

    (               shift and go to state 137


state 112

    (51) assign -> ID . possibleArray = expression
    (31) funcCall -> ID . ( parIn )
    (52) possibleArray -> . [ exp ]
    (53) possibleArray -> .

    (               shift and go to state 138
    [               shift and go to state 140
    =               reduce using rule 53 (possibleArray -> .)

    possibleArray                  shift and go to state 139

state 113

    (54) conditional -> IF . ( expression ) { block } possibleElif possibleElse

    (               shift and go to state 141


state 114

    (40) block -> funcCall . ; block

    ;               shift and go to state 142


state 115

    (61) loop -> while .

    ARRAY           reduce using rule 61 (loop -> while .)
    ID              reduce using rule 61 (loop -> while .)
    IF              reduce using rule 61 (loop -> while .)
    CONSOLE         reduce using rule 61 (loop -> while .)
    INPUT           reduce using rule 61 (loop -> while .)
    FOR             reduce using rule 61 (loop -> while .)
    WHILE           reduce using rule 61 (loop -> while .)
    DO              reduce using rule 61 (loop -> while .)
    INTTYPE         reduce using rule 61 (loop -> while .)
    FLOATTYPE       reduce using rule 61 (loop -> while .)
    STRINGTYPE      reduce using rule 61 (loop -> while .)
    BOOLTYPE        reduce using rule 61 (loop -> while .)
    }               reduce using rule 61 (loop -> while .)
    RETURN          reduce using rule 61 (loop -> while .)


state 116

    (26) main -> MAIN ( par ) { block . }

    }               shift and go to state 143


state 117

    (41) block -> output . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 144
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 118

    (37) block -> assign . ; block

    ;               shift and go to state 145


state 119

    (39) block -> loop . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 146
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 120

    (29) morePar -> , type . ID morePar

    ID              shift and go to state 147


state 121

    (16) arrays -> type ID [ constant ] = . { expression moreExp } moreArray

    {               shift and go to state 148


state 122

    (86) possibleFactors -> possibleFactorOp factor possibleFactors .

    +               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    -               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESS            reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATER         reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESSEQUAL       reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATEREQUAL    reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    DIFFERENT       reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    EQUALTO         reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    AND             reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    OR              reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ,               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ;               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    )               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ]               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    }               reduce using rule 86 (possibleFactors -> possibleFactorOp factor possibleFactors .)


state 123

    (104) input -> INPUT ( inputPar ) .

    ARRAY           reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ID              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    IF              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    CONSOLE         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    INPUT           reduce using rule 104 (input -> INPUT ( inputPar ) .)
    FOR             reduce using rule 104 (input -> INPUT ( inputPar ) .)
    WHILE           reduce using rule 104 (input -> INPUT ( inputPar ) .)
    DO              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    INTTYPE         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    FLOATTYPE       reduce using rule 104 (input -> INPUT ( inputPar ) .)
    STRINGTYPE      reduce using rule 104 (input -> INPUT ( inputPar ) .)
    BOOLTYPE        reduce using rule 104 (input -> INPUT ( inputPar ) .)
    }               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    *               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    /               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    %               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    +               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    -               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ]               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    LESS            reduce using rule 104 (input -> INPUT ( inputPar ) .)
    GREATER         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    LESSEQUAL       reduce using rule 104 (input -> INPUT ( inputPar ) .)
    GREATEREQUAL    reduce using rule 104 (input -> INPUT ( inputPar ) .)
    DIFFERENT       reduce using rule 104 (input -> INPUT ( inputPar ) .)
    EQUALTO         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    AND             reduce using rule 104 (input -> INPUT ( inputPar ) .)
    OR              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ,               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ;               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    )               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    RETURN          reduce using rule 104 (input -> INPUT ( inputPar ) .)


state 124

    (97) possibleIdCall -> ( parIn ) .

    *               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    /               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    %               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    +               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    -               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    LESS            reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    GREATER         reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    LESSEQUAL       reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    GREATEREQUAL    reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    DIFFERENT       reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    EQUALTO         reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    AND             reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    OR              reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    ,               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    ;               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    )               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    ]               reduce using rule 97 (possibleIdCall -> ( parIn ) .)
    }               reduce using rule 97 (possibleIdCall -> ( parIn ) .)


state 125

    (32) parIn -> expression moreParIn .

    )               reduce using rule 32 (parIn -> expression moreParIn .)


state 126

    (34) moreParIn -> , . expression moreParIn
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 149

state 127

    (96) possibleIdCall -> [ expression ] .

    *               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    /               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    %               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    +               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    -               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    LESS            reduce using rule 96 (possibleIdCall -> [ expression ] .)
    GREATER         reduce using rule 96 (possibleIdCall -> [ expression ] .)
    LESSEQUAL       reduce using rule 96 (possibleIdCall -> [ expression ] .)
    GREATEREQUAL    reduce using rule 96 (possibleIdCall -> [ expression ] .)
    DIFFERENT       reduce using rule 96 (possibleIdCall -> [ expression ] .)
    EQUALTO         reduce using rule 96 (possibleIdCall -> [ expression ] .)
    AND             reduce using rule 96 (possibleIdCall -> [ expression ] .)
    OR              reduce using rule 96 (possibleIdCall -> [ expression ] .)
    ,               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    ;               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    )               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    ]               reduce using rule 96 (possibleIdCall -> [ expression ] .)
    }               reduce using rule 96 (possibleIdCall -> [ expression ] .)


state 128

    (81) possibleTerms -> possibleTermOp term possibleTerms .

    LESS            reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATER         reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    LESSEQUAL       reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATEREQUAL    reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    DIFFERENT       reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    EQUALTO         reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    AND             reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    OR              reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    ,               reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    ;               reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    )               reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    ]               reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)
    }               reduce using rule 81 (possibleTerms -> possibleTermOp term possibleTerms .)


state 129

    (10) moreVar -> , ID = . expression moreVar
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    input                          shift and go to state 43
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    expression                     shift and go to state 150

state 130

    (21) function -> FUNCTION funcType ID ( par ) { block . RETURN returnType ; }

    RETURN          shift and go to state 151


state 131

    (65) doWhile -> DO { . loopBlock } WHILE ( expression ) ;
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 153
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 132

    (38) block -> conditional block .

    }               reduce using rule 38 (block -> conditional block .)
    RETURN          reduce using rule 38 (block -> conditional block .)


state 133

    (64) while -> WHILE ( . expression ) { loopBlock }
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 159

state 134

    (42) block -> input block .

    }               reduce using rule 42 (block -> input block .)
    RETURN          reduce using rule 42 (block -> input block .)


state 135

    (36) block -> varDeclar block .

    }               reduce using rule 36 (block -> varDeclar block .)
    RETURN          reduce using rule 36 (block -> varDeclar block .)


state 136

    (59) output -> CONSOLE ( . expression ) ;
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 160

state 137

    (63) for -> FOR ( . expression ; assign ) { loopBlock }
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 161

state 138

    (31) funcCall -> ID ( . parIn )
    (32) parIn -> . expression moreParIn
    (33) parIn -> .
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    )               reduce using rule 33 (parIn -> .)
    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    data                           shift and go to state 41
    higherExp                      shift and go to state 42
    parIn                          shift and go to state 162
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 96

state 139

    (51) assign -> ID possibleArray . = expression

    =               shift and go to state 163


state 140

    (52) possibleArray -> [ . exp ]
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    data                           shift and go to state 41
    exp                            shift and go to state 164
    factor                         shift and go to state 39
    input                          shift and go to state 43

state 141

    (54) conditional -> IF ( . expression ) { block } possibleElif possibleElse
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    input                          shift and go to state 43
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    expression                     shift and go to state 165

state 142

    (40) block -> funcCall ; . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    loop                           shift and go to state 119
    output                         shift and go to state 117
    assign                         shift and go to state 118
    block                          shift and go to state 166

state 143

    (26) main -> MAIN ( par ) { block } .

    $end            reduce using rule 26 (main -> MAIN ( par ) { block } .)


state 144

    (41) block -> output block .

    }               reduce using rule 41 (block -> output block .)
    RETURN          reduce using rule 41 (block -> output block .)


state 145

    (37) block -> assign ; . block
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    RETURN          reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 167
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 146

    (39) block -> loop block .

    }               reduce using rule 39 (block -> loop block .)
    RETURN          reduce using rule 39 (block -> loop block .)


state 147

    (29) morePar -> , type ID . morePar
    (29) morePar -> . , type ID morePar
    (30) morePar -> .

    ,               shift and go to state 89
    )               reduce using rule 30 (morePar -> .)

    morePar                        shift and go to state 168

state 148

    (16) arrays -> type ID [ constant ] = { . expression moreExp } moreArray
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    input                          shift and go to state 43
    expression                     shift and go to state 169
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39

state 149

    (34) moreParIn -> , expression . moreParIn
    (34) moreParIn -> . , expression moreParIn
    (35) moreParIn -> .

    ,               shift and go to state 126
    )               reduce using rule 35 (moreParIn -> .)

    moreParIn                      shift and go to state 170

state 150

    (10) moreVar -> , ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 85
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 171

state 151

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN . returnType ; }
    (24) returnType -> . expression
    (25) returnType -> . VOID
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    VOID            shift and go to state 172
    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    constant                       shift and go to state 38
    term                           shift and go to state 47
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    returnType                     shift and go to state 173
    input                          shift and go to state 43
    expression                     shift and go to state 174

state 152

    (45) loopBlock -> conditional . loopBlock
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 175
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 153

    (65) doWhile -> DO { loopBlock . } WHILE ( expression ) ;

    }               shift and go to state 176


state 154

    (49) loopBlock -> input . loopBlock
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 177
    doWhile                        shift and go to state 105
    output                         shift and go to state 157
    input                          shift and go to state 154
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 155

    (47) loopBlock -> funcCall . ; loopBlock

    ;               shift and go to state 178


state 156

    (46) loopBlock -> loop . loopBlock
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 179
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 157

    (48) loopBlock -> output . loopBlock
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 180
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 158

    (44) loopBlock -> assign . ; loopBlock

    ;               shift and go to state 181


state 159

    (64) while -> WHILE ( expression . ) { loopBlock }

    )               shift and go to state 182


state 160

    (59) output -> CONSOLE ( expression . ) ;

    )               shift and go to state 183


state 161

    (63) for -> FOR ( expression . ; assign ) { loopBlock }

    ;               shift and go to state 184


state 162

    (31) funcCall -> ID ( parIn . )

    )               shift and go to state 185


state 163

    (51) assign -> ID possibleArray = . expression
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    input                          shift and go to state 43
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    expression                     shift and go to state 186

state 164

    (52) possibleArray -> [ exp . ]

    ]               shift and go to state 187


state 165

    (54) conditional -> IF ( expression . ) { block } possibleElif possibleElse

    )               shift and go to state 188


state 166

    (40) block -> funcCall ; block .

    }               reduce using rule 40 (block -> funcCall ; block .)
    RETURN          reduce using rule 40 (block -> funcCall ; block .)


state 167

    (37) block -> assign ; block .

    }               reduce using rule 37 (block -> assign ; block .)
    RETURN          reduce using rule 37 (block -> assign ; block .)


state 168

    (29) morePar -> , type ID morePar .

    )               reduce using rule 29 (morePar -> , type ID morePar .)


state 169

    (16) arrays -> type ID [ constant ] = { expression . moreExp } moreArray
    (17) moreExp -> . , expression moreExp
    (18) moreExp -> .

    ,               shift and go to state 189
    }               reduce using rule 18 (moreExp -> .)

    moreExp                        shift and go to state 190

state 170

    (34) moreParIn -> , expression moreParIn .

    )               reduce using rule 34 (moreParIn -> , expression moreParIn .)


state 171

    (10) moreVar -> , ID = expression moreVar .

    ;               reduce using rule 10 (moreVar -> , ID = expression moreVar .)


state 172

    (25) returnType -> VOID .

    ;               reduce using rule 25 (returnType -> VOID .)


state 173

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN returnType . ; }

    ;               shift and go to state 191


state 174

    (24) returnType -> expression .

    ;               reduce using rule 24 (returnType -> expression .)


state 175

    (45) loopBlock -> conditional loopBlock .

    }               reduce using rule 45 (loopBlock -> conditional loopBlock .)


state 176

    (65) doWhile -> DO { loopBlock } . WHILE ( expression ) ;

    WHILE           shift and go to state 192


state 177

    (49) loopBlock -> input loopBlock .

    }               reduce using rule 49 (loopBlock -> input loopBlock .)


state 178

    (47) loopBlock -> funcCall ; . loopBlock
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 193
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 179

    (46) loopBlock -> loop loopBlock .

    }               reduce using rule 46 (loopBlock -> loop loopBlock .)


state 180

    (48) loopBlock -> output loopBlock .

    }               reduce using rule 48 (loopBlock -> output loopBlock .)


state 181

    (44) loopBlock -> assign ; . loopBlock
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 194
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 182

    (64) while -> WHILE ( expression ) . { loopBlock }

    {               shift and go to state 195


state 183

    (59) output -> CONSOLE ( expression ) . ;

    ;               shift and go to state 196


state 184

    (63) for -> FOR ( expression ; . assign ) { loopBlock }
    (51) assign -> . ID possibleArray = expression

    ID              shift and go to state 197

    assign                         shift and go to state 198

state 185

    (31) funcCall -> ID ( parIn ) .

    ;               reduce using rule 31 (funcCall -> ID ( parIn ) .)


state 186

    (51) assign -> ID possibleArray = expression .

    ;               reduce using rule 51 (assign -> ID possibleArray = expression .)
    )               reduce using rule 51 (assign -> ID possibleArray = expression .)


state 187

    (52) possibleArray -> [ exp ] .

    =               reduce using rule 52 (possibleArray -> [ exp ] .)


state 188

    (54) conditional -> IF ( expression ) . { block } possibleElif possibleElse

    {               shift and go to state 199


state 189

    (17) moreExp -> , . expression moreExp
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 200

state 190

    (16) arrays -> type ID [ constant ] = { expression moreExp . } moreArray

    }               shift and go to state 201


state 191

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; . }

    }               shift and go to state 202


state 192

    (65) doWhile -> DO { loopBlock } WHILE . ( expression ) ;

    (               shift and go to state 203


state 193

    (47) loopBlock -> funcCall ; loopBlock .

    }               reduce using rule 47 (loopBlock -> funcCall ; loopBlock .)


state 194

    (44) loopBlock -> assign ; loopBlock .

    }               reduce using rule 44 (loopBlock -> assign ; loopBlock .)


state 195

    (64) while -> WHILE ( expression ) { . loopBlock }
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 204
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 196

    (59) output -> CONSOLE ( expression ) ; .

    ID              reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    IF              reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    CONSOLE         reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    INPUT           reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    FOR             reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    WHILE           reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    DO              reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    }               reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    ARRAY           reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    INTTYPE         reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    FLOATTYPE       reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    STRINGTYPE      reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    BOOLTYPE        reduce using rule 59 (output -> CONSOLE ( expression ) ; .)
    RETURN          reduce using rule 59 (output -> CONSOLE ( expression ) ; .)


state 197

    (51) assign -> ID . possibleArray = expression
    (52) possibleArray -> . [ exp ]
    (53) possibleArray -> .

    [               shift and go to state 140
    =               reduce using rule 53 (possibleArray -> .)

    possibleArray                  shift and go to state 139

state 198

    (63) for -> FOR ( expression ; assign . ) { loopBlock }

    )               shift and go to state 205


state 199

    (54) conditional -> IF ( expression ) { . block } possibleElif possibleElse
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    vars                           shift and go to state 12
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 206
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 200

    (17) moreExp -> , expression . moreExp
    (17) moreExp -> . , expression moreExp
    (18) moreExp -> .

    ,               shift and go to state 189
    }               reduce using rule 18 (moreExp -> .)

    moreExp                        shift and go to state 207

state 201

    (16) arrays -> type ID [ constant ] = { expression moreExp } . moreArray
    (19) moreArray -> . , ID [ constant ] = { expression moreExp } moreArray
    (20) moreArray -> .

    ,               shift and go to state 209
    ;               reduce using rule 20 (moreArray -> .)

    moreArray                      shift and go to state 208

state 202

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .

    FUNCTION        reduce using rule 21 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)
    MAIN            reduce using rule 21 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)


state 203

    (65) doWhile -> DO { loopBlock } WHILE ( . expression ) ;
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 210

state 204

    (64) while -> WHILE ( expression ) { loopBlock . }

    }               shift and go to state 211


state 205

    (63) for -> FOR ( expression ; assign ) . { loopBlock }

    {               shift and go to state 212


state 206

    (54) conditional -> IF ( expression ) { block . } possibleElif possibleElse

    }               shift and go to state 213


state 207

    (17) moreExp -> , expression moreExp .

    }               reduce using rule 17 (moreExp -> , expression moreExp .)


state 208

    (16) arrays -> type ID [ constant ] = { expression moreExp } moreArray .

    ;               reduce using rule 16 (arrays -> type ID [ constant ] = { expression moreExp } moreArray .)


state 209

    (19) moreArray -> , . ID [ constant ] = { expression moreExp } moreArray

    ID              shift and go to state 214


state 210

    (65) doWhile -> DO { loopBlock } WHILE ( expression . ) ;

    )               shift and go to state 215


state 211

    (64) while -> WHILE ( expression ) { loopBlock } .

    ARRAY           reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    ID              reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    IF              reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    CONSOLE         reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    INPUT           reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    FOR             reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    WHILE           reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    DO              reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    INTTYPE         reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    FLOATTYPE       reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    STRINGTYPE      reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    BOOLTYPE        reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    }               reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)
    RETURN          reduce using rule 64 (while -> WHILE ( expression ) { loopBlock } .)


state 212

    (63) for -> FOR ( expression ; assign ) { . loopBlock }
    (44) loopBlock -> . assign ; loopBlock
    (45) loopBlock -> . conditional loopBlock
    (46) loopBlock -> . loop loopBlock
    (47) loopBlock -> . funcCall ; loopBlock
    (48) loopBlock -> . output loopBlock
    (49) loopBlock -> . input loopBlock
    (50) loopBlock -> .
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 50 (loopBlock -> .)
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103

    funcCall                       shift and go to state 155
    conditional                    shift and go to state 152
    while                          shift and go to state 115
    for                            shift and go to state 107
    loopBlock                      shift and go to state 216
    doWhile                        shift and go to state 105
    input                          shift and go to state 154
    output                         shift and go to state 157
    assign                         shift and go to state 158
    loop                           shift and go to state 156

state 213

    (54) conditional -> IF ( expression ) { block } . possibleElif possibleElse
    (55) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (56) possibleElif -> .

    ELIF            shift and go to state 217
    ELSE            reduce using rule 56 (possibleElif -> .)
    ARRAY           reduce using rule 56 (possibleElif -> .)
    ID              reduce using rule 56 (possibleElif -> .)
    IF              reduce using rule 56 (possibleElif -> .)
    CONSOLE         reduce using rule 56 (possibleElif -> .)
    INPUT           reduce using rule 56 (possibleElif -> .)
    FOR             reduce using rule 56 (possibleElif -> .)
    WHILE           reduce using rule 56 (possibleElif -> .)
    DO              reduce using rule 56 (possibleElif -> .)
    INTTYPE         reduce using rule 56 (possibleElif -> .)
    FLOATTYPE       reduce using rule 56 (possibleElif -> .)
    STRINGTYPE      reduce using rule 56 (possibleElif -> .)
    BOOLTYPE        reduce using rule 56 (possibleElif -> .)
    }               reduce using rule 56 (possibleElif -> .)
    RETURN          reduce using rule 56 (possibleElif -> .)

    possibleElif                   shift and go to state 218

state 214

    (19) moreArray -> , ID . [ constant ] = { expression moreExp } moreArray

    [               shift and go to state 219


state 215

    (65) doWhile -> DO { loopBlock } WHILE ( expression ) . ;

    ;               shift and go to state 220


state 216

    (63) for -> FOR ( expression ; assign ) { loopBlock . }

    }               shift and go to state 221


state 217

    (55) possibleElif -> ELIF . ( expression ) { block } possibleElif

    (               shift and go to state 222


state 218

    (54) conditional -> IF ( expression ) { block } possibleElif . possibleElse
    (57) possibleElse -> . ELSE { block }
    (58) possibleElse -> .

    ELSE            shift and go to state 224
    ARRAY           reduce using rule 58 (possibleElse -> .)
    ID              reduce using rule 58 (possibleElse -> .)
    IF              reduce using rule 58 (possibleElse -> .)
    CONSOLE         reduce using rule 58 (possibleElse -> .)
    INPUT           reduce using rule 58 (possibleElse -> .)
    FOR             reduce using rule 58 (possibleElse -> .)
    WHILE           reduce using rule 58 (possibleElse -> .)
    DO              reduce using rule 58 (possibleElse -> .)
    INTTYPE         reduce using rule 58 (possibleElse -> .)
    FLOATTYPE       reduce using rule 58 (possibleElse -> .)
    STRINGTYPE      reduce using rule 58 (possibleElse -> .)
    BOOLTYPE        reduce using rule 58 (possibleElse -> .)
    }               reduce using rule 58 (possibleElse -> .)
    RETURN          reduce using rule 58 (possibleElse -> .)

    possibleElse                   shift and go to state 223

state 219

    (19) moreArray -> , ID [ . constant ] = { expression moreExp } moreArray
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING

    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44

    constant                       shift and go to state 225

state 220

    (65) doWhile -> DO { loopBlock } WHILE ( expression ) ; .

    ID              reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    IF              reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    CONSOLE         reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INPUT           reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FOR             reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    WHILE           reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    DO              reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    }               reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    ARRAY           reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INTTYPE         reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FLOATTYPE       reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    STRINGTYPE      reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    BOOLTYPE        reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    RETURN          reduce using rule 65 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)


state 221

    (63) for -> FOR ( expression ; assign ) { loopBlock } .

    ARRAY           reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    ID              reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    IF              reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    CONSOLE         reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INPUT           reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FOR             reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    WHILE           reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    DO              reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INTTYPE         reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FLOATTYPE       reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    STRINGTYPE      reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    BOOLTYPE        reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    }               reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)
    RETURN          reduce using rule 63 (for -> FOR ( expression ; assign ) { loopBlock } .)


state 222

    (55) possibleElif -> ELIF ( . expression ) { block } possibleElif
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    input                          shift and go to state 43
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    expression                     shift and go to state 226

state 223

    (54) conditional -> IF ( expression ) { block } possibleElif possibleElse .

    ID              reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    IF              reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    CONSOLE         reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INPUT           reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FOR             reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    WHILE           reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    DO              reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    }               reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    ARRAY           reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INTTYPE         reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FLOATTYPE       reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    STRINGTYPE      reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    BOOLTYPE        reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    RETURN          reduce using rule 54 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)


state 224

    (57) possibleElse -> ELSE . { block }

    {               shift and go to state 227


state 225

    (19) moreArray -> , ID [ constant . ] = { expression moreExp } moreArray

    ]               shift and go to state 228


state 226

    (55) possibleElif -> ELIF ( expression . ) { block } possibleElif

    )               shift and go to state 229


state 227

    (57) possibleElse -> ELSE { . block }
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 230
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 228

    (19) moreArray -> , ID [ constant ] . = { expression moreExp } moreArray

    =               shift and go to state 231


state 229

    (55) possibleElif -> ELIF ( expression ) . { block } possibleElif

    {               shift and go to state 232


state 230

    (57) possibleElse -> ELSE { block . }

    }               shift and go to state 233


state 231

    (19) moreArray -> , ID [ constant ] = . { expression moreExp } moreArray

    {               shift and go to state 234


state 232

    (55) possibleElif -> ELIF ( expression ) { . block } possibleElif
    (36) block -> . varDeclar block
    (37) block -> . assign ; block
    (38) block -> . conditional block
    (39) block -> . loop block
    (40) block -> . funcCall ; block
    (41) block -> . output block
    (42) block -> . input block
    (43) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (51) assign -> . ID possibleArray = expression
    (54) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (60) loop -> . for
    (61) loop -> . while
    (62) loop -> . doWhile
    (31) funcCall -> . ID ( parIn )
    (59) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (63) for -> . FOR ( expression ; assign ) { loopBlock }
    (64) while -> . WHILE ( expression ) { loopBlock }
    (65) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 43 (block -> .)
    ARRAY           shift and go to state 10
    ID              shift and go to state 112
    IF              shift and go to state 113
    CONSOLE         shift and go to state 110
    INPUT           shift and go to state 45
    FOR             shift and go to state 111
    WHILE           shift and go to state 106
    DO              shift and go to state 103
    INTTYPE         shift and go to state 11
    FLOATTYPE       shift and go to state 13
    STRINGTYPE      shift and go to state 9
    BOOLTYPE        shift and go to state 8

    vars                           shift and go to state 12
    conditional                    shift and go to state 104
    doWhile                        shift and go to state 105
    for                            shift and go to state 107
    input                          shift and go to state 108
    varDeclar                      shift and go to state 109
    type                           shift and go to state 14
    funcCall                       shift and go to state 114
    while                          shift and go to state 115
    block                          shift and go to state 235
    output                         shift and go to state 117
    assign                         shift and go to state 118
    loop                           shift and go to state 119

state 233

    (57) possibleElse -> ELSE { block } .

    ARRAY           reduce using rule 57 (possibleElse -> ELSE { block } .)
    ID              reduce using rule 57 (possibleElse -> ELSE { block } .)
    IF              reduce using rule 57 (possibleElse -> ELSE { block } .)
    CONSOLE         reduce using rule 57 (possibleElse -> ELSE { block } .)
    INPUT           reduce using rule 57 (possibleElse -> ELSE { block } .)
    FOR             reduce using rule 57 (possibleElse -> ELSE { block } .)
    WHILE           reduce using rule 57 (possibleElse -> ELSE { block } .)
    DO              reduce using rule 57 (possibleElse -> ELSE { block } .)
    INTTYPE         reduce using rule 57 (possibleElse -> ELSE { block } .)
    FLOATTYPE       reduce using rule 57 (possibleElse -> ELSE { block } .)
    STRINGTYPE      reduce using rule 57 (possibleElse -> ELSE { block } .)
    BOOLTYPE        reduce using rule 57 (possibleElse -> ELSE { block } .)
    }               reduce using rule 57 (possibleElse -> ELSE { block } .)
    RETURN          reduce using rule 57 (possibleElse -> ELSE { block } .)


state 234

    (19) moreArray -> , ID [ constant ] = { . expression moreExp } moreArray
    (66) expression -> . higherExp possibleHigherExp
    (71) higherExp -> . exp possibleExp
    (80) exp -> . term possibleTerms
    (85) term -> . factor possibleFactors
    (91) factor -> . ( expression )
    (92) factor -> . data
    (93) data -> . ID possibleIdCall
    (94) data -> . constant
    (95) data -> . input
    (99) constant -> . INT
    (100) constant -> . FLOAT
    (101) constant -> . TRUE
    (102) constant -> . FALSE
    (103) constant -> . STRING
    (104) input -> . INPUT ( inputPar )

    (               shift and go to state 52
    ID              shift and go to state 46
    INT             shift and go to state 49
    FLOAT           shift and go to state 50
    TRUE            shift and go to state 40
    FALSE           shift and go to state 48
    STRING          shift and go to state 44
    INPUT           shift and go to state 45

    term                           shift and go to state 47
    constant                       shift and go to state 38
    higherExp                      shift and go to state 42
    data                           shift and go to state 41
    exp                            shift and go to state 51
    factor                         shift and go to state 39
    input                          shift and go to state 43
    expression                     shift and go to state 236

state 235

    (55) possibleElif -> ELIF ( expression ) { block . } possibleElif

    }               shift and go to state 237


state 236

    (19) moreArray -> , ID [ constant ] = { expression . moreExp } moreArray
    (17) moreExp -> . , expression moreExp
    (18) moreExp -> .

    ,               shift and go to state 189
    }               reduce using rule 18 (moreExp -> .)

    moreExp                        shift and go to state 238

state 237

    (55) possibleElif -> ELIF ( expression ) { block } . possibleElif
    (55) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (56) possibleElif -> .

    ELIF            shift and go to state 217
    ELSE            reduce using rule 56 (possibleElif -> .)
    ARRAY           reduce using rule 56 (possibleElif -> .)
    ID              reduce using rule 56 (possibleElif -> .)
    IF              reduce using rule 56 (possibleElif -> .)
    CONSOLE         reduce using rule 56 (possibleElif -> .)
    INPUT           reduce using rule 56 (possibleElif -> .)
    FOR             reduce using rule 56 (possibleElif -> .)
    WHILE           reduce using rule 56 (possibleElif -> .)
    DO              reduce using rule 56 (possibleElif -> .)
    INTTYPE         reduce using rule 56 (possibleElif -> .)
    FLOATTYPE       reduce using rule 56 (possibleElif -> .)
    STRINGTYPE      reduce using rule 56 (possibleElif -> .)
    BOOLTYPE        reduce using rule 56 (possibleElif -> .)
    }               reduce using rule 56 (possibleElif -> .)
    RETURN          reduce using rule 56 (possibleElif -> .)

    possibleElif                   shift and go to state 239

state 238

    (19) moreArray -> , ID [ constant ] = { expression moreExp . } moreArray

    }               shift and go to state 240


state 239

    (55) possibleElif -> ELIF ( expression ) { block } possibleElif .

    ELSE            reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ARRAY           reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ID              reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    IF              reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    CONSOLE         reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INPUT           reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FOR             reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    WHILE           reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    DO              reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INTTYPE         reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FLOATTYPE       reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    STRINGTYPE      reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    BOOLTYPE        reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    }               reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    RETURN          reduce using rule 55 (possibleElif -> ELIF ( expression ) { block } possibleElif .)


state 240

    (19) moreArray -> , ID [ constant ] = { expression moreExp } . moreArray
    (19) moreArray -> . , ID [ constant ] = { expression moreExp } moreArray
    (20) moreArray -> .

    ,               shift and go to state 209
    ;               reduce using rule 20 (moreArray -> .)

    moreArray                      shift and go to state 241

state 241

    (19) moreArray -> , ID [ constant ] = { expression moreExp } moreArray .

    ;               reduce using rule 19 (moreArray -> , ID [ constant ] = { expression moreExp } moreArray .)

