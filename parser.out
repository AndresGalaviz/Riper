Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    GLOBAL

Grammar

Rule 0     S' -> program
Rule 1     program -> globalVarDeclar functionDeclar main
Rule 2     globalVarDeclar -> initVarDeclar
Rule 3     initVarDeclar -> varDeclar initVarDeclar
Rule 4     initVarDeclar -> <empty>
Rule 5     functionDeclar -> function functionDeclar
Rule 6     functionDeclar -> <empty>
Rule 7     varDeclar -> vars ;
Rule 8     varDeclar -> ARRAY arrays ;
Rule 9     vars -> type ID = expression moreVar
Rule 10    moreVar -> , ID = expression moreVar
Rule 11    moreVar -> <empty>
Rule 12    type -> INTTYPE
Rule 13    type -> FLOATTYPE
Rule 14    type -> STRINGTYPE
Rule 15    type -> BOOLTYPE
Rule 16    arrays -> firstArr moreArray
Rule 17    firstArr -> type ID [ INT ] = { expression moreExp }
Rule 18    moreExp -> , expression moreExp
Rule 19    moreExp -> <empty>
Rule 20    moreArray -> , ID [ INT ] = { expression moreExp } moreArray
Rule 21    moreArray -> <empty>
Rule 22    function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; }
Rule 23    funcType -> INTTYPE
Rule 24    funcType -> FLOATTYPE
Rule 25    funcType -> STRINGTYPE
Rule 26    funcType -> BOOLTYPE
Rule 27    funcType -> VOID
Rule 28    returnType -> expression
Rule 29    returnType -> VOID
Rule 30    main -> MAIN ( par ) { block }
Rule 31    par -> type ID morePar
Rule 32    par -> <empty>
Rule 33    morePar -> , type ID morePar
Rule 34    morePar -> <empty>
Rule 35    funcCall -> ID ( parIn )
Rule 36    parIn -> expression moreParIn
Rule 37    parIn -> <empty>
Rule 38    moreParIn -> , expression moreParIn
Rule 39    moreParIn -> <empty>
Rule 40    block -> varDeclar block
Rule 41    block -> assign ; block
Rule 42    block -> conditional block
Rule 43    block -> loop block
Rule 44    block -> funcCall ; block
Rule 45    block -> output block
Rule 46    block -> input block
Rule 47    block -> <empty>
Rule 48    loopBlock -> assign ; loopBlock
Rule 49    loopBlock -> conditional loopBlock
Rule 50    loopBlock -> loop loopBlock
Rule 51    loopBlock -> funcCall ; loopBlock
Rule 52    loopBlock -> output loopBlock
Rule 53    loopBlock -> input loopBlock
Rule 54    loopBlock -> <empty>
Rule 55    assign -> ID possibleArray = expression
Rule 56    possibleArray -> [ exp ]
Rule 57    possibleArray -> <empty>
Rule 58    conditional -> IF ( expression ) { block } possibleElif possibleElse
Rule 59    possibleElif -> ELIF ( expression ) { block } possibleElif
Rule 60    possibleElif -> <empty>
Rule 61    possibleElse -> ELSE { block }
Rule 62    possibleElse -> <empty>
Rule 63    output -> CONSOLE ( expression ) ;
Rule 64    loop -> for
Rule 65    loop -> while
Rule 66    loop -> doWhile
Rule 67    for -> FOR ( expression ; assign ) { loopBlock }
Rule 68    while -> WHILE ( expression ) { loopBlock }
Rule 69    doWhile -> DO { loopBlock } WHILE ( expression ) ;
Rule 70    expression -> higherExp possibleHigherExp
Rule 71    possibleHigherExp -> possibleHigherExpOp higherExp
Rule 72    possibleHigherExp -> <empty>
Rule 73    possibleHigherExpOp -> AND
Rule 74    possibleHigherExpOp -> OR
Rule 75    higherExp -> exp possibleExp
Rule 76    possibleExp -> possibleExpOp exp
Rule 77    possibleExp -> <empty>
Rule 78    possibleExpOp -> LESS
Rule 79    possibleExpOp -> GREATER
Rule 80    possibleExpOp -> LESSEQUAL
Rule 81    possibleExpOp -> GREATEREQUAL
Rule 82    possibleExpOp -> DIFFERENT
Rule 83    possibleExpOp -> EQUALTO
Rule 84    exp -> term possibleTerms
Rule 85    possibleTerms -> possibleTermOp term possibleTerms
Rule 86    possibleTerms -> <empty>
Rule 87    possibleTermOp -> +
Rule 88    possibleTermOp -> -
Rule 89    term -> factor possibleFactors
Rule 90    possibleFactors -> possibleFactorOp factor possibleFactors
Rule 91    possibleFactors -> <empty>
Rule 92    possibleFactorOp -> *
Rule 93    possibleFactorOp -> /
Rule 94    possibleFactorOp -> %
Rule 95    factor -> ( expression )
Rule 96    factor -> data
Rule 97    data -> ID possibleIdCall
Rule 98    data -> constant
Rule 99    data -> input
Rule 100   possibleIdCall -> [ expression ]
Rule 101   possibleIdCall -> ( parIn )
Rule 102   possibleIdCall -> <empty>
Rule 103   constant -> INT
Rule 104   constant -> FLOAT
Rule 105   constant -> TRUE
Rule 106   constant -> FALSE
Rule 107   constant -> STRING
Rule 108   input -> INPUT ( inputPar )
Rule 109   inputPar -> STRING
Rule 110   inputPar -> <empty>

Terminals, with rules where they appear

%                    : 94
(                    : 22 30 35 58 59 63 67 68 69 95 101 108
)                    : 22 30 35 58 59 63 67 68 69 95 101 108
*                    : 92
+                    : 87
,                    : 10 18 20 33 38
-                    : 88
/                    : 93
;                    : 7 8 22 41 44 48 51 63 67 69
=                    : 9 10 17 20 55
AND                  : 73
ARRAY                : 8
BOOLTYPE             : 15 26
CONSOLE              : 63
DIFFERENT            : 82
DO                   : 69
ELIF                 : 59
ELSE                 : 61
EQUALTO              : 83
FALSE                : 106
FLOAT                : 104
FLOATTYPE            : 13 24
FOR                  : 67
FUNCTION             : 22
GLOBAL               : 
GREATER              : 79
GREATEREQUAL         : 81
ID                   : 9 10 17 20 22 31 33 35 55 97
IF                   : 58
INPUT                : 108
INT                  : 17 20 103
INTTYPE              : 12 23
LESS                 : 78
LESSEQUAL            : 80
MAIN                 : 30
OR                   : 74
RETURN               : 22
STRING               : 107 109
STRINGTYPE           : 14 25
TRUE                 : 105
VOID                 : 27 29
WHILE                : 68 69
[                    : 17 20 56 100
]                    : 17 20 56 100
error                : 
{                    : 17 20 22 30 58 59 61 67 68 69
}                    : 17 20 22 30 58 59 61 67 68 69

Nonterminals, with rules where they appear

arrays               : 8
assign               : 41 48 67
block                : 22 30 40 41 42 43 44 45 46 58 59 61
conditional          : 42 49
constant             : 98
data                 : 96
doWhile              : 66
exp                  : 56 75 76
expression           : 9 10 17 18 20 28 36 38 55 58 59 63 67 68 69 95 100
factor               : 89 90
firstArr             : 16
for                  : 64
funcCall             : 44 51
funcType             : 22
function             : 5
functionDeclar       : 1 5
globalVarDeclar      : 1
higherExp            : 70 71
initVarDeclar        : 2 3
input                : 46 53 99
inputPar             : 108
loop                 : 43 50
loopBlock            : 48 49 50 51 52 53 67 68 69
main                 : 1
moreArray            : 16 20
moreExp              : 17 18 20
morePar              : 31 33
moreParIn            : 36 38
moreVar              : 9 10
output               : 45 52
par                  : 22 30
parIn                : 35 101
possibleArray        : 55
possibleElif         : 58 59
possibleElse         : 58
possibleExp          : 75
possibleExpOp        : 76
possibleFactorOp     : 90
possibleFactors      : 89 90
possibleHigherExp    : 70
possibleHigherExpOp  : 71
possibleIdCall       : 97
possibleTermOp       : 85
possibleTerms        : 84 85
program              : 0
returnType           : 22
term                 : 84 85
type                 : 9 17 31 33
varDeclar            : 3 40
vars                 : 7
while                : 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . globalVarDeclar functionDeclar main
    (2) globalVarDeclar -> . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    FUNCTION        reduce using rule 4 (initVarDeclar -> .)
    MAIN            reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    globalVarDeclar                shift and go to state 7
    program                        shift and go to state 8
    initVarDeclar                  shift and go to state 9
    type                           shift and go to state 10
    varDeclar                      shift and go to state 11

state 1

    (15) type -> BOOLTYPE .

    ID              reduce using rule 15 (type -> BOOLTYPE .)


state 2

    (14) type -> STRINGTYPE .

    ID              reduce using rule 14 (type -> STRINGTYPE .)


state 3

    (12) type -> INTTYPE .

    ID              reduce using rule 12 (type -> INTTYPE .)


state 4

    (7) varDeclar -> vars . ;

    ;               shift and go to state 12


state 5

    (13) type -> FLOATTYPE .

    ID              reduce using rule 13 (type -> FLOATTYPE .)


state 6

    (8) varDeclar -> ARRAY . arrays ;
    (16) arrays -> . firstArr moreArray
    (17) firstArr -> . type ID [ INT ] = { expression moreExp }
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    arrays                         shift and go to state 13
    type                           shift and go to state 15
    firstArr                       shift and go to state 14

state 7

    (1) program -> globalVarDeclar . functionDeclar main
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (22) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 17

    function                       shift and go to state 16
    functionDeclar                 shift and go to state 18

state 8

    (0) S' -> program .



state 9

    (2) globalVarDeclar -> initVarDeclar .

    FUNCTION        reduce using rule 2 (globalVarDeclar -> initVarDeclar .)
    MAIN            reduce using rule 2 (globalVarDeclar -> initVarDeclar .)


state 10

    (9) vars -> type . ID = expression moreVar

    ID              shift and go to state 19


state 11

    (3) initVarDeclar -> varDeclar . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    FUNCTION        reduce using rule 4 (initVarDeclar -> .)
    MAIN            reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    initVarDeclar                  shift and go to state 20
    varDeclar                      shift and go to state 11
    type                           shift and go to state 10

state 12

    (7) varDeclar -> vars ; .

    ARRAY           reduce using rule 7 (varDeclar -> vars ; .)
    ID              reduce using rule 7 (varDeclar -> vars ; .)
    IF              reduce using rule 7 (varDeclar -> vars ; .)
    CONSOLE         reduce using rule 7 (varDeclar -> vars ; .)
    INPUT           reduce using rule 7 (varDeclar -> vars ; .)
    FOR             reduce using rule 7 (varDeclar -> vars ; .)
    WHILE           reduce using rule 7 (varDeclar -> vars ; .)
    DO              reduce using rule 7 (varDeclar -> vars ; .)
    INTTYPE         reduce using rule 7 (varDeclar -> vars ; .)
    FLOATTYPE       reduce using rule 7 (varDeclar -> vars ; .)
    STRINGTYPE      reduce using rule 7 (varDeclar -> vars ; .)
    BOOLTYPE        reduce using rule 7 (varDeclar -> vars ; .)
    }               reduce using rule 7 (varDeclar -> vars ; .)
    RETURN          reduce using rule 7 (varDeclar -> vars ; .)
    FUNCTION        reduce using rule 7 (varDeclar -> vars ; .)
    MAIN            reduce using rule 7 (varDeclar -> vars ; .)


state 13

    (8) varDeclar -> ARRAY arrays . ;

    ;               shift and go to state 21


state 14

    (16) arrays -> firstArr . moreArray
    (20) moreArray -> . , ID [ INT ] = { expression moreExp } moreArray
    (21) moreArray -> .

    ,               shift and go to state 23
    ;               reduce using rule 21 (moreArray -> .)

    moreArray                      shift and go to state 22

state 15

    (17) firstArr -> type . ID [ INT ] = { expression moreExp }

    ID              shift and go to state 24


state 16

    (5) functionDeclar -> function . functionDeclar
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (22) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 17

    function                       shift and go to state 16
    functionDeclar                 shift and go to state 25

state 17

    (22) function -> FUNCTION . funcType ID ( par ) { block RETURN returnType ; }
    (23) funcType -> . INTTYPE
    (24) funcType -> . FLOATTYPE
    (25) funcType -> . STRINGTYPE
    (26) funcType -> . BOOLTYPE
    (27) funcType -> . VOID

    INTTYPE         shift and go to state 31
    FLOATTYPE       shift and go to state 27
    STRINGTYPE      shift and go to state 26
    BOOLTYPE        shift and go to state 30
    VOID            shift and go to state 29

    funcType                       shift and go to state 28

state 18

    (1) program -> globalVarDeclar functionDeclar . main
    (30) main -> . MAIN ( par ) { block }

    MAIN            shift and go to state 33

    main                           shift and go to state 32

state 19

    (9) vars -> type ID . = expression moreVar

    =               shift and go to state 34


state 20

    (3) initVarDeclar -> varDeclar initVarDeclar .

    FUNCTION        reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)
    MAIN            reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)


state 21

    (8) varDeclar -> ARRAY arrays ; .

    ARRAY           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    ID              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    IF              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    CONSOLE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INPUT           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FOR             reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    WHILE           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    DO              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INTTYPE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FLOATTYPE       reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    STRINGTYPE      reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    BOOLTYPE        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    }               reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    RETURN          reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FUNCTION        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    MAIN            reduce using rule 8 (varDeclar -> ARRAY arrays ; .)


state 22

    (16) arrays -> firstArr moreArray .

    ;               reduce using rule 16 (arrays -> firstArr moreArray .)


state 23

    (20) moreArray -> , . ID [ INT ] = { expression moreExp } moreArray

    ID              shift and go to state 35


state 24

    (17) firstArr -> type ID . [ INT ] = { expression moreExp }

    [               shift and go to state 36


state 25

    (5) functionDeclar -> function functionDeclar .

    MAIN            reduce using rule 5 (functionDeclar -> function functionDeclar .)


state 26

    (25) funcType -> STRINGTYPE .

    ID              reduce using rule 25 (funcType -> STRINGTYPE .)


state 27

    (24) funcType -> FLOATTYPE .

    ID              reduce using rule 24 (funcType -> FLOATTYPE .)


state 28

    (22) function -> FUNCTION funcType . ID ( par ) { block RETURN returnType ; }

    ID              shift and go to state 37


state 29

    (27) funcType -> VOID .

    ID              reduce using rule 27 (funcType -> VOID .)


state 30

    (26) funcType -> BOOLTYPE .

    ID              reduce using rule 26 (funcType -> BOOLTYPE .)


state 31

    (23) funcType -> INTTYPE .

    ID              reduce using rule 23 (funcType -> INTTYPE .)


state 32

    (1) program -> globalVarDeclar functionDeclar main .

    $end            reduce using rule 1 (program -> globalVarDeclar functionDeclar main .)


state 33

    (30) main -> MAIN . ( par ) { block }

    (               shift and go to state 38


state 34

    (9) vars -> type ID = . expression moreVar
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    input                          shift and go to state 44
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    expression                     shift and go to state 54

state 35

    (20) moreArray -> , ID . [ INT ] = { expression moreExp } moreArray

    [               shift and go to state 55


state 36

    (17) firstArr -> type ID [ . INT ] = { expression moreExp }

    INT             shift and go to state 56


state 37

    (22) function -> FUNCTION funcType ID . ( par ) { block RETURN returnType ; }

    (               shift and go to state 57


state 38

    (30) main -> MAIN ( . par ) { block }
    (31) par -> . type ID morePar
    (32) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 32 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 58
    type                           shift and go to state 59

state 39

    (98) data -> constant .

    *               reduce using rule 98 (data -> constant .)
    /               reduce using rule 98 (data -> constant .)
    %               reduce using rule 98 (data -> constant .)
    +               reduce using rule 98 (data -> constant .)
    -               reduce using rule 98 (data -> constant .)
    LESS            reduce using rule 98 (data -> constant .)
    GREATER         reduce using rule 98 (data -> constant .)
    LESSEQUAL       reduce using rule 98 (data -> constant .)
    GREATEREQUAL    reduce using rule 98 (data -> constant .)
    DIFFERENT       reduce using rule 98 (data -> constant .)
    EQUALTO         reduce using rule 98 (data -> constant .)
    AND             reduce using rule 98 (data -> constant .)
    OR              reduce using rule 98 (data -> constant .)
    )               reduce using rule 98 (data -> constant .)
    ,               reduce using rule 98 (data -> constant .)
    }               reduce using rule 98 (data -> constant .)
    ;               reduce using rule 98 (data -> constant .)
    ]               reduce using rule 98 (data -> constant .)


state 40

    (89) term -> factor . possibleFactors
    (90) possibleFactors -> . possibleFactorOp factor possibleFactors
    (91) possibleFactors -> .
    (92) possibleFactorOp -> . *
    (93) possibleFactorOp -> . /
    (94) possibleFactorOp -> . %

    +               reduce using rule 91 (possibleFactors -> .)
    -               reduce using rule 91 (possibleFactors -> .)
    LESS            reduce using rule 91 (possibleFactors -> .)
    GREATER         reduce using rule 91 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 91 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 91 (possibleFactors -> .)
    DIFFERENT       reduce using rule 91 (possibleFactors -> .)
    EQUALTO         reduce using rule 91 (possibleFactors -> .)
    AND             reduce using rule 91 (possibleFactors -> .)
    OR              reduce using rule 91 (possibleFactors -> .)
    ,               reduce using rule 91 (possibleFactors -> .)
    ;               reduce using rule 91 (possibleFactors -> .)
    )               reduce using rule 91 (possibleFactors -> .)
    ]               reduce using rule 91 (possibleFactors -> .)
    }               reduce using rule 91 (possibleFactors -> .)
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 60

    possibleFactors                shift and go to state 62
    possibleFactorOp               shift and go to state 64

state 41

    (105) constant -> TRUE .

    *               reduce using rule 105 (constant -> TRUE .)
    /               reduce using rule 105 (constant -> TRUE .)
    %               reduce using rule 105 (constant -> TRUE .)
    +               reduce using rule 105 (constant -> TRUE .)
    -               reduce using rule 105 (constant -> TRUE .)
    LESS            reduce using rule 105 (constant -> TRUE .)
    GREATER         reduce using rule 105 (constant -> TRUE .)
    LESSEQUAL       reduce using rule 105 (constant -> TRUE .)
    GREATEREQUAL    reduce using rule 105 (constant -> TRUE .)
    DIFFERENT       reduce using rule 105 (constant -> TRUE .)
    EQUALTO         reduce using rule 105 (constant -> TRUE .)
    AND             reduce using rule 105 (constant -> TRUE .)
    OR              reduce using rule 105 (constant -> TRUE .)
    ;               reduce using rule 105 (constant -> TRUE .)
    ,               reduce using rule 105 (constant -> TRUE .)
    )               reduce using rule 105 (constant -> TRUE .)
    ]               reduce using rule 105 (constant -> TRUE .)
    }               reduce using rule 105 (constant -> TRUE .)


state 42

    (96) factor -> data .

    *               reduce using rule 96 (factor -> data .)
    /               reduce using rule 96 (factor -> data .)
    %               reduce using rule 96 (factor -> data .)
    +               reduce using rule 96 (factor -> data .)
    -               reduce using rule 96 (factor -> data .)
    LESS            reduce using rule 96 (factor -> data .)
    GREATER         reduce using rule 96 (factor -> data .)
    LESSEQUAL       reduce using rule 96 (factor -> data .)
    GREATEREQUAL    reduce using rule 96 (factor -> data .)
    DIFFERENT       reduce using rule 96 (factor -> data .)
    EQUALTO         reduce using rule 96 (factor -> data .)
    AND             reduce using rule 96 (factor -> data .)
    OR              reduce using rule 96 (factor -> data .)
    )               reduce using rule 96 (factor -> data .)
    ;               reduce using rule 96 (factor -> data .)
    ]               reduce using rule 96 (factor -> data .)
    ,               reduce using rule 96 (factor -> data .)
    }               reduce using rule 96 (factor -> data .)


state 43

    (70) expression -> higherExp . possibleHigherExp
    (71) possibleHigherExp -> . possibleHigherExpOp higherExp
    (72) possibleHigherExp -> .
    (73) possibleHigherExpOp -> . AND
    (74) possibleHigherExpOp -> . OR

    ,               reduce using rule 72 (possibleHigherExp -> .)
    ;               reduce using rule 72 (possibleHigherExp -> .)
    )               reduce using rule 72 (possibleHigherExp -> .)
    ]               reduce using rule 72 (possibleHigherExp -> .)
    }               reduce using rule 72 (possibleHigherExp -> .)
    AND             shift and go to state 65
    OR              shift and go to state 68

    possibleHigherExpOp            shift and go to state 66
    possibleHigherExp              shift and go to state 67

state 44

    (99) data -> input .

    *               reduce using rule 99 (data -> input .)
    /               reduce using rule 99 (data -> input .)
    %               reduce using rule 99 (data -> input .)
    +               reduce using rule 99 (data -> input .)
    -               reduce using rule 99 (data -> input .)
    LESS            reduce using rule 99 (data -> input .)
    GREATER         reduce using rule 99 (data -> input .)
    LESSEQUAL       reduce using rule 99 (data -> input .)
    GREATEREQUAL    reduce using rule 99 (data -> input .)
    DIFFERENT       reduce using rule 99 (data -> input .)
    EQUALTO         reduce using rule 99 (data -> input .)
    AND             reduce using rule 99 (data -> input .)
    OR              reduce using rule 99 (data -> input .)
    )               reduce using rule 99 (data -> input .)
    ,               reduce using rule 99 (data -> input .)
    }               reduce using rule 99 (data -> input .)
    ;               reduce using rule 99 (data -> input .)
    ]               reduce using rule 99 (data -> input .)


state 45

    (107) constant -> STRING .

    *               reduce using rule 107 (constant -> STRING .)
    /               reduce using rule 107 (constant -> STRING .)
    %               reduce using rule 107 (constant -> STRING .)
    +               reduce using rule 107 (constant -> STRING .)
    -               reduce using rule 107 (constant -> STRING .)
    LESS            reduce using rule 107 (constant -> STRING .)
    GREATER         reduce using rule 107 (constant -> STRING .)
    LESSEQUAL       reduce using rule 107 (constant -> STRING .)
    GREATEREQUAL    reduce using rule 107 (constant -> STRING .)
    DIFFERENT       reduce using rule 107 (constant -> STRING .)
    EQUALTO         reduce using rule 107 (constant -> STRING .)
    AND             reduce using rule 107 (constant -> STRING .)
    OR              reduce using rule 107 (constant -> STRING .)
    ;               reduce using rule 107 (constant -> STRING .)
    ,               reduce using rule 107 (constant -> STRING .)
    )               reduce using rule 107 (constant -> STRING .)
    ]               reduce using rule 107 (constant -> STRING .)
    }               reduce using rule 107 (constant -> STRING .)


state 46

    (108) input -> INPUT . ( inputPar )

    (               shift and go to state 69


state 47

    (97) data -> ID . possibleIdCall
    (100) possibleIdCall -> . [ expression ]
    (101) possibleIdCall -> . ( parIn )
    (102) possibleIdCall -> .

    [               shift and go to state 72
    (               shift and go to state 71
    *               reduce using rule 102 (possibleIdCall -> .)
    /               reduce using rule 102 (possibleIdCall -> .)
    %               reduce using rule 102 (possibleIdCall -> .)
    +               reduce using rule 102 (possibleIdCall -> .)
    -               reduce using rule 102 (possibleIdCall -> .)
    LESS            reduce using rule 102 (possibleIdCall -> .)
    GREATER         reduce using rule 102 (possibleIdCall -> .)
    LESSEQUAL       reduce using rule 102 (possibleIdCall -> .)
    GREATEREQUAL    reduce using rule 102 (possibleIdCall -> .)
    DIFFERENT       reduce using rule 102 (possibleIdCall -> .)
    EQUALTO         reduce using rule 102 (possibleIdCall -> .)
    AND             reduce using rule 102 (possibleIdCall -> .)
    OR              reduce using rule 102 (possibleIdCall -> .)
    ,               reduce using rule 102 (possibleIdCall -> .)
    ;               reduce using rule 102 (possibleIdCall -> .)
    )               reduce using rule 102 (possibleIdCall -> .)
    ]               reduce using rule 102 (possibleIdCall -> .)
    }               reduce using rule 102 (possibleIdCall -> .)

    possibleIdCall                 shift and go to state 70

state 48

    (84) exp -> term . possibleTerms
    (85) possibleTerms -> . possibleTermOp term possibleTerms
    (86) possibleTerms -> .
    (87) possibleTermOp -> . +
    (88) possibleTermOp -> . -

    LESS            reduce using rule 86 (possibleTerms -> .)
    GREATER         reduce using rule 86 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 86 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 86 (possibleTerms -> .)
    DIFFERENT       reduce using rule 86 (possibleTerms -> .)
    EQUALTO         reduce using rule 86 (possibleTerms -> .)
    AND             reduce using rule 86 (possibleTerms -> .)
    OR              reduce using rule 86 (possibleTerms -> .)
    ,               reduce using rule 86 (possibleTerms -> .)
    ;               reduce using rule 86 (possibleTerms -> .)
    )               reduce using rule 86 (possibleTerms -> .)
    ]               reduce using rule 86 (possibleTerms -> .)
    }               reduce using rule 86 (possibleTerms -> .)
    +               shift and go to state 76
    -               shift and go to state 75

    possibleTermOp                 shift and go to state 73
    possibleTerms                  shift and go to state 74

state 49

    (106) constant -> FALSE .

    *               reduce using rule 106 (constant -> FALSE .)
    /               reduce using rule 106 (constant -> FALSE .)
    %               reduce using rule 106 (constant -> FALSE .)
    +               reduce using rule 106 (constant -> FALSE .)
    -               reduce using rule 106 (constant -> FALSE .)
    LESS            reduce using rule 106 (constant -> FALSE .)
    GREATER         reduce using rule 106 (constant -> FALSE .)
    LESSEQUAL       reduce using rule 106 (constant -> FALSE .)
    GREATEREQUAL    reduce using rule 106 (constant -> FALSE .)
    DIFFERENT       reduce using rule 106 (constant -> FALSE .)
    EQUALTO         reduce using rule 106 (constant -> FALSE .)
    AND             reduce using rule 106 (constant -> FALSE .)
    OR              reduce using rule 106 (constant -> FALSE .)
    ;               reduce using rule 106 (constant -> FALSE .)
    ,               reduce using rule 106 (constant -> FALSE .)
    )               reduce using rule 106 (constant -> FALSE .)
    ]               reduce using rule 106 (constant -> FALSE .)
    }               reduce using rule 106 (constant -> FALSE .)


state 50

    (103) constant -> INT .

    *               reduce using rule 103 (constant -> INT .)
    /               reduce using rule 103 (constant -> INT .)
    %               reduce using rule 103 (constant -> INT .)
    +               reduce using rule 103 (constant -> INT .)
    -               reduce using rule 103 (constant -> INT .)
    LESS            reduce using rule 103 (constant -> INT .)
    GREATER         reduce using rule 103 (constant -> INT .)
    LESSEQUAL       reduce using rule 103 (constant -> INT .)
    GREATEREQUAL    reduce using rule 103 (constant -> INT .)
    DIFFERENT       reduce using rule 103 (constant -> INT .)
    EQUALTO         reduce using rule 103 (constant -> INT .)
    AND             reduce using rule 103 (constant -> INT .)
    OR              reduce using rule 103 (constant -> INT .)
    ;               reduce using rule 103 (constant -> INT .)
    ,               reduce using rule 103 (constant -> INT .)
    )               reduce using rule 103 (constant -> INT .)
    ]               reduce using rule 103 (constant -> INT .)
    }               reduce using rule 103 (constant -> INT .)


state 51

    (104) constant -> FLOAT .

    *               reduce using rule 104 (constant -> FLOAT .)
    /               reduce using rule 104 (constant -> FLOAT .)
    %               reduce using rule 104 (constant -> FLOAT .)
    +               reduce using rule 104 (constant -> FLOAT .)
    -               reduce using rule 104 (constant -> FLOAT .)
    LESS            reduce using rule 104 (constant -> FLOAT .)
    GREATER         reduce using rule 104 (constant -> FLOAT .)
    LESSEQUAL       reduce using rule 104 (constant -> FLOAT .)
    GREATEREQUAL    reduce using rule 104 (constant -> FLOAT .)
    DIFFERENT       reduce using rule 104 (constant -> FLOAT .)
    EQUALTO         reduce using rule 104 (constant -> FLOAT .)
    AND             reduce using rule 104 (constant -> FLOAT .)
    OR              reduce using rule 104 (constant -> FLOAT .)
    ;               reduce using rule 104 (constant -> FLOAT .)
    ,               reduce using rule 104 (constant -> FLOAT .)
    )               reduce using rule 104 (constant -> FLOAT .)
    ]               reduce using rule 104 (constant -> FLOAT .)
    }               reduce using rule 104 (constant -> FLOAT .)


state 52

    (75) higherExp -> exp . possibleExp
    (76) possibleExp -> . possibleExpOp exp
    (77) possibleExp -> .
    (78) possibleExpOp -> . LESS
    (79) possibleExpOp -> . GREATER
    (80) possibleExpOp -> . LESSEQUAL
    (81) possibleExpOp -> . GREATEREQUAL
    (82) possibleExpOp -> . DIFFERENT
    (83) possibleExpOp -> . EQUALTO

    AND             reduce using rule 77 (possibleExp -> .)
    OR              reduce using rule 77 (possibleExp -> .)
    ,               reduce using rule 77 (possibleExp -> .)
    ;               reduce using rule 77 (possibleExp -> .)
    )               reduce using rule 77 (possibleExp -> .)
    ]               reduce using rule 77 (possibleExp -> .)
    }               reduce using rule 77 (possibleExp -> .)
    LESS            shift and go to state 80
    GREATER         shift and go to state 78
    LESSEQUAL       shift and go to state 84
    GREATEREQUAL    shift and go to state 77
    DIFFERENT       shift and go to state 83
    EQUALTO         shift and go to state 82

    possibleExp                    shift and go to state 81
    possibleExpOp                  shift and go to state 79

state 53

    (95) factor -> ( . expression )
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 85

state 54

    (9) vars -> type ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 87
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 86

state 55

    (20) moreArray -> , ID [ . INT ] = { expression moreExp } moreArray

    INT             shift and go to state 88


state 56

    (17) firstArr -> type ID [ INT . ] = { expression moreExp }

    ]               shift and go to state 89


state 57

    (22) function -> FUNCTION funcType ID ( . par ) { block RETURN returnType ; }
    (31) par -> . type ID morePar
    (32) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 32 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 90
    type                           shift and go to state 59

state 58

    (30) main -> MAIN ( par . ) { block }

    )               shift and go to state 91


state 59

    (31) par -> type . ID morePar

    ID              shift and go to state 92


state 60

    (94) possibleFactorOp -> % .

    (               reduce using rule 94 (possibleFactorOp -> % .)
    ID              reduce using rule 94 (possibleFactorOp -> % .)
    INT             reduce using rule 94 (possibleFactorOp -> % .)
    FLOAT           reduce using rule 94 (possibleFactorOp -> % .)
    TRUE            reduce using rule 94 (possibleFactorOp -> % .)
    FALSE           reduce using rule 94 (possibleFactorOp -> % .)
    STRING          reduce using rule 94 (possibleFactorOp -> % .)
    INPUT           reduce using rule 94 (possibleFactorOp -> % .)


state 61

    (92) possibleFactorOp -> * .

    (               reduce using rule 92 (possibleFactorOp -> * .)
    ID              reduce using rule 92 (possibleFactorOp -> * .)
    INT             reduce using rule 92 (possibleFactorOp -> * .)
    FLOAT           reduce using rule 92 (possibleFactorOp -> * .)
    TRUE            reduce using rule 92 (possibleFactorOp -> * .)
    FALSE           reduce using rule 92 (possibleFactorOp -> * .)
    STRING          reduce using rule 92 (possibleFactorOp -> * .)
    INPUT           reduce using rule 92 (possibleFactorOp -> * .)


state 62

    (89) term -> factor possibleFactors .

    +               reduce using rule 89 (term -> factor possibleFactors .)
    -               reduce using rule 89 (term -> factor possibleFactors .)
    LESS            reduce using rule 89 (term -> factor possibleFactors .)
    GREATER         reduce using rule 89 (term -> factor possibleFactors .)
    LESSEQUAL       reduce using rule 89 (term -> factor possibleFactors .)
    GREATEREQUAL    reduce using rule 89 (term -> factor possibleFactors .)
    DIFFERENT       reduce using rule 89 (term -> factor possibleFactors .)
    EQUALTO         reduce using rule 89 (term -> factor possibleFactors .)
    AND             reduce using rule 89 (term -> factor possibleFactors .)
    OR              reduce using rule 89 (term -> factor possibleFactors .)
    ;               reduce using rule 89 (term -> factor possibleFactors .)
    )               reduce using rule 89 (term -> factor possibleFactors .)
    ]               reduce using rule 89 (term -> factor possibleFactors .)
    ,               reduce using rule 89 (term -> factor possibleFactors .)
    }               reduce using rule 89 (term -> factor possibleFactors .)


state 63

    (93) possibleFactorOp -> / .

    (               reduce using rule 93 (possibleFactorOp -> / .)
    ID              reduce using rule 93 (possibleFactorOp -> / .)
    INT             reduce using rule 93 (possibleFactorOp -> / .)
    FLOAT           reduce using rule 93 (possibleFactorOp -> / .)
    TRUE            reduce using rule 93 (possibleFactorOp -> / .)
    FALSE           reduce using rule 93 (possibleFactorOp -> / .)
    STRING          reduce using rule 93 (possibleFactorOp -> / .)
    INPUT           reduce using rule 93 (possibleFactorOp -> / .)


state 64

    (90) possibleFactors -> possibleFactorOp . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    constant                       shift and go to state 39
    data                           shift and go to state 42
    factor                         shift and go to state 93
    input                          shift and go to state 44

state 65

    (73) possibleHigherExpOp -> AND .

    (               reduce using rule 73 (possibleHigherExpOp -> AND .)
    ID              reduce using rule 73 (possibleHigherExpOp -> AND .)
    INT             reduce using rule 73 (possibleHigherExpOp -> AND .)
    FLOAT           reduce using rule 73 (possibleHigherExpOp -> AND .)
    TRUE            reduce using rule 73 (possibleHigherExpOp -> AND .)
    FALSE           reduce using rule 73 (possibleHigherExpOp -> AND .)
    STRING          reduce using rule 73 (possibleHigherExpOp -> AND .)
    INPUT           reduce using rule 73 (possibleHigherExpOp -> AND .)


state 66

    (71) possibleHigherExp -> possibleHigherExpOp . higherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 94
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44

state 67

    (70) expression -> higherExp possibleHigherExp .

    ,               reduce using rule 70 (expression -> higherExp possibleHigherExp .)
    )               reduce using rule 70 (expression -> higherExp possibleHigherExp .)
    }               reduce using rule 70 (expression -> higherExp possibleHigherExp .)
    ]               reduce using rule 70 (expression -> higherExp possibleHigherExp .)
    ;               reduce using rule 70 (expression -> higherExp possibleHigherExp .)


state 68

    (74) possibleHigherExpOp -> OR .

    (               reduce using rule 74 (possibleHigherExpOp -> OR .)
    ID              reduce using rule 74 (possibleHigherExpOp -> OR .)
    INT             reduce using rule 74 (possibleHigherExpOp -> OR .)
    FLOAT           reduce using rule 74 (possibleHigherExpOp -> OR .)
    TRUE            reduce using rule 74 (possibleHigherExpOp -> OR .)
    FALSE           reduce using rule 74 (possibleHigherExpOp -> OR .)
    STRING          reduce using rule 74 (possibleHigherExpOp -> OR .)
    INPUT           reduce using rule 74 (possibleHigherExpOp -> OR .)


state 69

    (108) input -> INPUT ( . inputPar )
    (109) inputPar -> . STRING
    (110) inputPar -> .

    STRING          shift and go to state 95
    )               reduce using rule 110 (inputPar -> .)

    inputPar                       shift and go to state 96

state 70

    (97) data -> ID possibleIdCall .

    *               reduce using rule 97 (data -> ID possibleIdCall .)
    /               reduce using rule 97 (data -> ID possibleIdCall .)
    %               reduce using rule 97 (data -> ID possibleIdCall .)
    +               reduce using rule 97 (data -> ID possibleIdCall .)
    -               reduce using rule 97 (data -> ID possibleIdCall .)
    LESS            reduce using rule 97 (data -> ID possibleIdCall .)
    GREATER         reduce using rule 97 (data -> ID possibleIdCall .)
    LESSEQUAL       reduce using rule 97 (data -> ID possibleIdCall .)
    GREATEREQUAL    reduce using rule 97 (data -> ID possibleIdCall .)
    DIFFERENT       reduce using rule 97 (data -> ID possibleIdCall .)
    EQUALTO         reduce using rule 97 (data -> ID possibleIdCall .)
    AND             reduce using rule 97 (data -> ID possibleIdCall .)
    OR              reduce using rule 97 (data -> ID possibleIdCall .)
    )               reduce using rule 97 (data -> ID possibleIdCall .)
    ,               reduce using rule 97 (data -> ID possibleIdCall .)
    }               reduce using rule 97 (data -> ID possibleIdCall .)
    ;               reduce using rule 97 (data -> ID possibleIdCall .)
    ]               reduce using rule 97 (data -> ID possibleIdCall .)


state 71

    (101) possibleIdCall -> ( . parIn )
    (36) parIn -> . expression moreParIn
    (37) parIn -> .
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    )               reduce using rule 37 (parIn -> .)
    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    data                           shift and go to state 42
    higherExp                      shift and go to state 43
    parIn                          shift and go to state 97
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 98

state 72

    (100) possibleIdCall -> [ . expression ]
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 99

state 73

    (85) possibleTerms -> possibleTermOp . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 100
    constant                       shift and go to state 39
    data                           shift and go to state 42
    factor                         shift and go to state 40
    input                          shift and go to state 44

state 74

    (84) exp -> term possibleTerms .

    LESS            reduce using rule 84 (exp -> term possibleTerms .)
    GREATER         reduce using rule 84 (exp -> term possibleTerms .)
    LESSEQUAL       reduce using rule 84 (exp -> term possibleTerms .)
    GREATEREQUAL    reduce using rule 84 (exp -> term possibleTerms .)
    DIFFERENT       reduce using rule 84 (exp -> term possibleTerms .)
    EQUALTO         reduce using rule 84 (exp -> term possibleTerms .)
    AND             reduce using rule 84 (exp -> term possibleTerms .)
    OR              reduce using rule 84 (exp -> term possibleTerms .)
    )               reduce using rule 84 (exp -> term possibleTerms .)
    ,               reduce using rule 84 (exp -> term possibleTerms .)
    }               reduce using rule 84 (exp -> term possibleTerms .)
    ;               reduce using rule 84 (exp -> term possibleTerms .)
    ]               reduce using rule 84 (exp -> term possibleTerms .)


state 75

    (88) possibleTermOp -> - .

    (               reduce using rule 88 (possibleTermOp -> - .)
    ID              reduce using rule 88 (possibleTermOp -> - .)
    INT             reduce using rule 88 (possibleTermOp -> - .)
    FLOAT           reduce using rule 88 (possibleTermOp -> - .)
    TRUE            reduce using rule 88 (possibleTermOp -> - .)
    FALSE           reduce using rule 88 (possibleTermOp -> - .)
    STRING          reduce using rule 88 (possibleTermOp -> - .)
    INPUT           reduce using rule 88 (possibleTermOp -> - .)


state 76

    (87) possibleTermOp -> + .

    (               reduce using rule 87 (possibleTermOp -> + .)
    ID              reduce using rule 87 (possibleTermOp -> + .)
    INT             reduce using rule 87 (possibleTermOp -> + .)
    FLOAT           reduce using rule 87 (possibleTermOp -> + .)
    TRUE            reduce using rule 87 (possibleTermOp -> + .)
    FALSE           reduce using rule 87 (possibleTermOp -> + .)
    STRING          reduce using rule 87 (possibleTermOp -> + .)
    INPUT           reduce using rule 87 (possibleTermOp -> + .)


state 77

    (81) possibleExpOp -> GREATEREQUAL .

    (               reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    ID              reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    INT             reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    FLOAT           reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    TRUE            reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    FALSE           reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    STRING          reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)
    INPUT           reduce using rule 81 (possibleExpOp -> GREATEREQUAL .)


state 78

    (79) possibleExpOp -> GREATER .

    (               reduce using rule 79 (possibleExpOp -> GREATER .)
    ID              reduce using rule 79 (possibleExpOp -> GREATER .)
    INT             reduce using rule 79 (possibleExpOp -> GREATER .)
    FLOAT           reduce using rule 79 (possibleExpOp -> GREATER .)
    TRUE            reduce using rule 79 (possibleExpOp -> GREATER .)
    FALSE           reduce using rule 79 (possibleExpOp -> GREATER .)
    STRING          reduce using rule 79 (possibleExpOp -> GREATER .)
    INPUT           reduce using rule 79 (possibleExpOp -> GREATER .)


state 79

    (76) possibleExp -> possibleExpOp . exp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    data                           shift and go to state 42
    exp                            shift and go to state 101
    factor                         shift and go to state 40
    input                          shift and go to state 44

state 80

    (78) possibleExpOp -> LESS .

    (               reduce using rule 78 (possibleExpOp -> LESS .)
    ID              reduce using rule 78 (possibleExpOp -> LESS .)
    INT             reduce using rule 78 (possibleExpOp -> LESS .)
    FLOAT           reduce using rule 78 (possibleExpOp -> LESS .)
    TRUE            reduce using rule 78 (possibleExpOp -> LESS .)
    FALSE           reduce using rule 78 (possibleExpOp -> LESS .)
    STRING          reduce using rule 78 (possibleExpOp -> LESS .)
    INPUT           reduce using rule 78 (possibleExpOp -> LESS .)


state 81

    (75) higherExp -> exp possibleExp .

    AND             reduce using rule 75 (higherExp -> exp possibleExp .)
    OR              reduce using rule 75 (higherExp -> exp possibleExp .)
    )               reduce using rule 75 (higherExp -> exp possibleExp .)
    ,               reduce using rule 75 (higherExp -> exp possibleExp .)
    ;               reduce using rule 75 (higherExp -> exp possibleExp .)
    }               reduce using rule 75 (higherExp -> exp possibleExp .)
    ]               reduce using rule 75 (higherExp -> exp possibleExp .)


state 82

    (83) possibleExpOp -> EQUALTO .

    (               reduce using rule 83 (possibleExpOp -> EQUALTO .)
    ID              reduce using rule 83 (possibleExpOp -> EQUALTO .)
    INT             reduce using rule 83 (possibleExpOp -> EQUALTO .)
    FLOAT           reduce using rule 83 (possibleExpOp -> EQUALTO .)
    TRUE            reduce using rule 83 (possibleExpOp -> EQUALTO .)
    FALSE           reduce using rule 83 (possibleExpOp -> EQUALTO .)
    STRING          reduce using rule 83 (possibleExpOp -> EQUALTO .)
    INPUT           reduce using rule 83 (possibleExpOp -> EQUALTO .)


state 83

    (82) possibleExpOp -> DIFFERENT .

    (               reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    ID              reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    INT             reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    FLOAT           reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    TRUE            reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    FALSE           reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    STRING          reduce using rule 82 (possibleExpOp -> DIFFERENT .)
    INPUT           reduce using rule 82 (possibleExpOp -> DIFFERENT .)


state 84

    (80) possibleExpOp -> LESSEQUAL .

    (               reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    ID              reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    INT             reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    FLOAT           reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    TRUE            reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    FALSE           reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    STRING          reduce using rule 80 (possibleExpOp -> LESSEQUAL .)
    INPUT           reduce using rule 80 (possibleExpOp -> LESSEQUAL .)


state 85

    (95) factor -> ( expression . )

    )               shift and go to state 102


state 86

    (9) vars -> type ID = expression moreVar .

    ;               reduce using rule 9 (vars -> type ID = expression moreVar .)


state 87

    (10) moreVar -> , . ID = expression moreVar

    ID              shift and go to state 103


state 88

    (20) moreArray -> , ID [ INT . ] = { expression moreExp } moreArray

    ]               shift and go to state 104


state 89

    (17) firstArr -> type ID [ INT ] . = { expression moreExp }

    =               shift and go to state 105


state 90

    (22) function -> FUNCTION funcType ID ( par . ) { block RETURN returnType ; }

    )               shift and go to state 106


state 91

    (30) main -> MAIN ( par ) . { block }

    {               shift and go to state 107


state 92

    (31) par -> type ID . morePar
    (33) morePar -> . , type ID morePar
    (34) morePar -> .

    ,               shift and go to state 109
    )               reduce using rule 34 (morePar -> .)

    morePar                        shift and go to state 108

state 93

    (90) possibleFactors -> possibleFactorOp factor . possibleFactors
    (90) possibleFactors -> . possibleFactorOp factor possibleFactors
    (91) possibleFactors -> .
    (92) possibleFactorOp -> . *
    (93) possibleFactorOp -> . /
    (94) possibleFactorOp -> . %

    +               reduce using rule 91 (possibleFactors -> .)
    -               reduce using rule 91 (possibleFactors -> .)
    LESS            reduce using rule 91 (possibleFactors -> .)
    GREATER         reduce using rule 91 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 91 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 91 (possibleFactors -> .)
    DIFFERENT       reduce using rule 91 (possibleFactors -> .)
    EQUALTO         reduce using rule 91 (possibleFactors -> .)
    AND             reduce using rule 91 (possibleFactors -> .)
    OR              reduce using rule 91 (possibleFactors -> .)
    ,               reduce using rule 91 (possibleFactors -> .)
    ;               reduce using rule 91 (possibleFactors -> .)
    )               reduce using rule 91 (possibleFactors -> .)
    ]               reduce using rule 91 (possibleFactors -> .)
    }               reduce using rule 91 (possibleFactors -> .)
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 60

    possibleFactors                shift and go to state 110
    possibleFactorOp               shift and go to state 64

state 94

    (71) possibleHigherExp -> possibleHigherExpOp higherExp .

    ,               reduce using rule 71 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ;               reduce using rule 71 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    )               reduce using rule 71 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ]               reduce using rule 71 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    }               reduce using rule 71 (possibleHigherExp -> possibleHigherExpOp higherExp .)


state 95

    (109) inputPar -> STRING .

    )               reduce using rule 109 (inputPar -> STRING .)


state 96

    (108) input -> INPUT ( inputPar . )

    )               shift and go to state 111


state 97

    (101) possibleIdCall -> ( parIn . )

    )               shift and go to state 112


state 98

    (36) parIn -> expression . moreParIn
    (38) moreParIn -> . , expression moreParIn
    (39) moreParIn -> .

    ,               shift and go to state 114
    )               reduce using rule 39 (moreParIn -> .)

    moreParIn                      shift and go to state 113

state 99

    (100) possibleIdCall -> [ expression . ]

    ]               shift and go to state 115


state 100

    (85) possibleTerms -> possibleTermOp term . possibleTerms
    (85) possibleTerms -> . possibleTermOp term possibleTerms
    (86) possibleTerms -> .
    (87) possibleTermOp -> . +
    (88) possibleTermOp -> . -

    LESS            reduce using rule 86 (possibleTerms -> .)
    GREATER         reduce using rule 86 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 86 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 86 (possibleTerms -> .)
    DIFFERENT       reduce using rule 86 (possibleTerms -> .)
    EQUALTO         reduce using rule 86 (possibleTerms -> .)
    AND             reduce using rule 86 (possibleTerms -> .)
    OR              reduce using rule 86 (possibleTerms -> .)
    ,               reduce using rule 86 (possibleTerms -> .)
    ;               reduce using rule 86 (possibleTerms -> .)
    )               reduce using rule 86 (possibleTerms -> .)
    ]               reduce using rule 86 (possibleTerms -> .)
    }               reduce using rule 86 (possibleTerms -> .)
    +               shift and go to state 76
    -               shift and go to state 75

    possibleTermOp                 shift and go to state 73
    possibleTerms                  shift and go to state 116

state 101

    (76) possibleExp -> possibleExpOp exp .

    AND             reduce using rule 76 (possibleExp -> possibleExpOp exp .)
    OR              reduce using rule 76 (possibleExp -> possibleExpOp exp .)
    ,               reduce using rule 76 (possibleExp -> possibleExpOp exp .)
    ;               reduce using rule 76 (possibleExp -> possibleExpOp exp .)
    )               reduce using rule 76 (possibleExp -> possibleExpOp exp .)
    ]               reduce using rule 76 (possibleExp -> possibleExpOp exp .)
    }               reduce using rule 76 (possibleExp -> possibleExpOp exp .)


state 102

    (95) factor -> ( expression ) .

    *               reduce using rule 95 (factor -> ( expression ) .)
    /               reduce using rule 95 (factor -> ( expression ) .)
    %               reduce using rule 95 (factor -> ( expression ) .)
    +               reduce using rule 95 (factor -> ( expression ) .)
    -               reduce using rule 95 (factor -> ( expression ) .)
    LESS            reduce using rule 95 (factor -> ( expression ) .)
    GREATER         reduce using rule 95 (factor -> ( expression ) .)
    LESSEQUAL       reduce using rule 95 (factor -> ( expression ) .)
    GREATEREQUAL    reduce using rule 95 (factor -> ( expression ) .)
    DIFFERENT       reduce using rule 95 (factor -> ( expression ) .)
    EQUALTO         reduce using rule 95 (factor -> ( expression ) .)
    AND             reduce using rule 95 (factor -> ( expression ) .)
    OR              reduce using rule 95 (factor -> ( expression ) .)
    )               reduce using rule 95 (factor -> ( expression ) .)
    ;               reduce using rule 95 (factor -> ( expression ) .)
    ]               reduce using rule 95 (factor -> ( expression ) .)
    ,               reduce using rule 95 (factor -> ( expression ) .)
    }               reduce using rule 95 (factor -> ( expression ) .)


state 103

    (10) moreVar -> , ID . = expression moreVar

    =               shift and go to state 117


state 104

    (20) moreArray -> , ID [ INT ] . = { expression moreExp } moreArray

    =               shift and go to state 118


state 105

    (17) firstArr -> type ID [ INT ] = . { expression moreExp }

    {               shift and go to state 119


state 106

    (22) function -> FUNCTION funcType ID ( par ) . { block RETURN returnType ; }

    {               shift and go to state 120


state 107

    (30) main -> MAIN ( par ) { . block }
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 134
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 108

    (31) par -> type ID morePar .

    )               reduce using rule 31 (par -> type ID morePar .)


state 109

    (33) morePar -> , . type ID morePar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    type                           shift and go to state 138

state 110

    (90) possibleFactors -> possibleFactorOp factor possibleFactors .

    +               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    -               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESS            reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATER         reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESSEQUAL       reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATEREQUAL    reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    DIFFERENT       reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    EQUALTO         reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    AND             reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    OR              reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ,               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ;               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    )               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ]               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    }               reduce using rule 90 (possibleFactors -> possibleFactorOp factor possibleFactors .)


state 111

    (108) input -> INPUT ( inputPar ) .

    ID              reduce using rule 108 (input -> INPUT ( inputPar ) .)
    IF              reduce using rule 108 (input -> INPUT ( inputPar ) .)
    CONSOLE         reduce using rule 108 (input -> INPUT ( inputPar ) .)
    INPUT           reduce using rule 108 (input -> INPUT ( inputPar ) .)
    FOR             reduce using rule 108 (input -> INPUT ( inputPar ) .)
    WHILE           reduce using rule 108 (input -> INPUT ( inputPar ) .)
    DO              reduce using rule 108 (input -> INPUT ( inputPar ) .)
    }               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    *               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    /               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    %               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    +               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    -               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    LESS            reduce using rule 108 (input -> INPUT ( inputPar ) .)
    GREATER         reduce using rule 108 (input -> INPUT ( inputPar ) .)
    LESSEQUAL       reduce using rule 108 (input -> INPUT ( inputPar ) .)
    GREATEREQUAL    reduce using rule 108 (input -> INPUT ( inputPar ) .)
    DIFFERENT       reduce using rule 108 (input -> INPUT ( inputPar ) .)
    EQUALTO         reduce using rule 108 (input -> INPUT ( inputPar ) .)
    AND             reduce using rule 108 (input -> INPUT ( inputPar ) .)
    OR              reduce using rule 108 (input -> INPUT ( inputPar ) .)
    ,               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    ;               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    ]               reduce using rule 108 (input -> INPUT ( inputPar ) .)
    ARRAY           reduce using rule 108 (input -> INPUT ( inputPar ) .)
    INTTYPE         reduce using rule 108 (input -> INPUT ( inputPar ) .)
    FLOATTYPE       reduce using rule 108 (input -> INPUT ( inputPar ) .)
    STRINGTYPE      reduce using rule 108 (input -> INPUT ( inputPar ) .)
    BOOLTYPE        reduce using rule 108 (input -> INPUT ( inputPar ) .)
    RETURN          reduce using rule 108 (input -> INPUT ( inputPar ) .)
    )               reduce using rule 108 (input -> INPUT ( inputPar ) .)


state 112

    (101) possibleIdCall -> ( parIn ) .

    *               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    /               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    %               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    +               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    -               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    LESS            reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    GREATER         reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    LESSEQUAL       reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    GREATEREQUAL    reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    DIFFERENT       reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    EQUALTO         reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    AND             reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    OR              reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    ,               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    ;               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    )               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    ]               reduce using rule 101 (possibleIdCall -> ( parIn ) .)
    }               reduce using rule 101 (possibleIdCall -> ( parIn ) .)


state 113

    (36) parIn -> expression moreParIn .

    )               reduce using rule 36 (parIn -> expression moreParIn .)


state 114

    (38) moreParIn -> , . expression moreParIn
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 139

state 115

    (100) possibleIdCall -> [ expression ] .

    *               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    /               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    %               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    +               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    -               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    LESS            reduce using rule 100 (possibleIdCall -> [ expression ] .)
    GREATER         reduce using rule 100 (possibleIdCall -> [ expression ] .)
    LESSEQUAL       reduce using rule 100 (possibleIdCall -> [ expression ] .)
    GREATEREQUAL    reduce using rule 100 (possibleIdCall -> [ expression ] .)
    DIFFERENT       reduce using rule 100 (possibleIdCall -> [ expression ] .)
    EQUALTO         reduce using rule 100 (possibleIdCall -> [ expression ] .)
    AND             reduce using rule 100 (possibleIdCall -> [ expression ] .)
    OR              reduce using rule 100 (possibleIdCall -> [ expression ] .)
    ,               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    ;               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    )               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    ]               reduce using rule 100 (possibleIdCall -> [ expression ] .)
    }               reduce using rule 100 (possibleIdCall -> [ expression ] .)


state 116

    (85) possibleTerms -> possibleTermOp term possibleTerms .

    LESS            reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATER         reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    LESSEQUAL       reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATEREQUAL    reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    DIFFERENT       reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    EQUALTO         reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    AND             reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    OR              reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    ,               reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    ;               reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    )               reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    ]               reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)
    }               reduce using rule 85 (possibleTerms -> possibleTermOp term possibleTerms .)


state 117

    (10) moreVar -> , ID = . expression moreVar
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    input                          shift and go to state 44
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    expression                     shift and go to state 140

state 118

    (20) moreArray -> , ID [ INT ] = . { expression moreExp } moreArray

    {               shift and go to state 141


state 119

    (17) firstArr -> type ID [ INT ] = { . expression moreExp }
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    input                          shift and go to state 44
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    expression                     shift and go to state 142

state 120

    (22) function -> FUNCTION funcType ID ( par ) { . block RETURN returnType ; }
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 143
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 121

    (69) doWhile -> DO . { loopBlock } WHILE ( expression ) ;

    {               shift and go to state 144


state 122

    (42) block -> conditional . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    loop                           shift and go to state 137
    output                         shift and go to state 135
    assign                         shift and go to state 136
    block                          shift and go to state 145

state 123

    (66) loop -> doWhile .

    ID              reduce using rule 66 (loop -> doWhile .)
    IF              reduce using rule 66 (loop -> doWhile .)
    CONSOLE         reduce using rule 66 (loop -> doWhile .)
    INPUT           reduce using rule 66 (loop -> doWhile .)
    FOR             reduce using rule 66 (loop -> doWhile .)
    WHILE           reduce using rule 66 (loop -> doWhile .)
    DO              reduce using rule 66 (loop -> doWhile .)
    }               reduce using rule 66 (loop -> doWhile .)
    ARRAY           reduce using rule 66 (loop -> doWhile .)
    INTTYPE         reduce using rule 66 (loop -> doWhile .)
    FLOATTYPE       reduce using rule 66 (loop -> doWhile .)
    STRINGTYPE      reduce using rule 66 (loop -> doWhile .)
    BOOLTYPE        reduce using rule 66 (loop -> doWhile .)
    RETURN          reduce using rule 66 (loop -> doWhile .)


state 124

    (68) while -> WHILE . ( expression ) { loopBlock }

    (               shift and go to state 146


state 125

    (64) loop -> for .

    ID              reduce using rule 64 (loop -> for .)
    IF              reduce using rule 64 (loop -> for .)
    CONSOLE         reduce using rule 64 (loop -> for .)
    INPUT           reduce using rule 64 (loop -> for .)
    FOR             reduce using rule 64 (loop -> for .)
    WHILE           reduce using rule 64 (loop -> for .)
    DO              reduce using rule 64 (loop -> for .)
    }               reduce using rule 64 (loop -> for .)
    ARRAY           reduce using rule 64 (loop -> for .)
    INTTYPE         reduce using rule 64 (loop -> for .)
    FLOATTYPE       reduce using rule 64 (loop -> for .)
    STRINGTYPE      reduce using rule 64 (loop -> for .)
    BOOLTYPE        reduce using rule 64 (loop -> for .)
    RETURN          reduce using rule 64 (loop -> for .)


state 126

    (46) block -> input . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 147
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 127

    (40) block -> varDeclar . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 148
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 128

    (63) output -> CONSOLE . ( expression ) ;

    (               shift and go to state 149


state 129

    (67) for -> FOR . ( expression ; assign ) { loopBlock }

    (               shift and go to state 150


state 130

    (55) assign -> ID . possibleArray = expression
    (35) funcCall -> ID . ( parIn )
    (56) possibleArray -> . [ exp ]
    (57) possibleArray -> .

    (               shift and go to state 151
    [               shift and go to state 153
    =               reduce using rule 57 (possibleArray -> .)

    possibleArray                  shift and go to state 152

state 131

    (58) conditional -> IF . ( expression ) { block } possibleElif possibleElse

    (               shift and go to state 154


state 132

    (44) block -> funcCall . ; block

    ;               shift and go to state 155


state 133

    (65) loop -> while .

    ID              reduce using rule 65 (loop -> while .)
    IF              reduce using rule 65 (loop -> while .)
    CONSOLE         reduce using rule 65 (loop -> while .)
    INPUT           reduce using rule 65 (loop -> while .)
    FOR             reduce using rule 65 (loop -> while .)
    WHILE           reduce using rule 65 (loop -> while .)
    DO              reduce using rule 65 (loop -> while .)
    }               reduce using rule 65 (loop -> while .)
    ARRAY           reduce using rule 65 (loop -> while .)
    INTTYPE         reduce using rule 65 (loop -> while .)
    FLOATTYPE       reduce using rule 65 (loop -> while .)
    STRINGTYPE      reduce using rule 65 (loop -> while .)
    BOOLTYPE        reduce using rule 65 (loop -> while .)
    RETURN          reduce using rule 65 (loop -> while .)


state 134

    (30) main -> MAIN ( par ) { block . }

    }               shift and go to state 156


state 135

    (45) block -> output . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 157
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 136

    (41) block -> assign . ; block

    ;               shift and go to state 158


state 137

    (43) block -> loop . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 159
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 138

    (33) morePar -> , type . ID morePar

    ID              shift and go to state 160


state 139

    (38) moreParIn -> , expression . moreParIn
    (38) moreParIn -> . , expression moreParIn
    (39) moreParIn -> .

    ,               shift and go to state 114
    )               reduce using rule 39 (moreParIn -> .)

    moreParIn                      shift and go to state 161

state 140

    (10) moreVar -> , ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 87
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 162

state 141

    (20) moreArray -> , ID [ INT ] = { . expression moreExp } moreArray
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 163

state 142

    (17) firstArr -> type ID [ INT ] = { expression . moreExp }
    (18) moreExp -> . , expression moreExp
    (19) moreExp -> .

    ,               shift and go to state 164
    }               reduce using rule 19 (moreExp -> .)

    moreExp                        shift and go to state 165

state 143

    (22) function -> FUNCTION funcType ID ( par ) { block . RETURN returnType ; }

    RETURN          shift and go to state 166


state 144

    (69) doWhile -> DO { . loopBlock } WHILE ( expression ) ;
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 168
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 145

    (42) block -> conditional block .

    }               reduce using rule 42 (block -> conditional block .)
    RETURN          reduce using rule 42 (block -> conditional block .)


state 146

    (68) while -> WHILE ( . expression ) { loopBlock }
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 174

state 147

    (46) block -> input block .

    }               reduce using rule 46 (block -> input block .)
    RETURN          reduce using rule 46 (block -> input block .)


state 148

    (40) block -> varDeclar block .

    }               reduce using rule 40 (block -> varDeclar block .)
    RETURN          reduce using rule 40 (block -> varDeclar block .)


state 149

    (63) output -> CONSOLE ( . expression ) ;
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 175

state 150

    (67) for -> FOR ( . expression ; assign ) { loopBlock }
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 176

state 151

    (35) funcCall -> ID ( . parIn )
    (36) parIn -> . expression moreParIn
    (37) parIn -> .
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    )               reduce using rule 37 (parIn -> .)
    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    data                           shift and go to state 42
    higherExp                      shift and go to state 43
    parIn                          shift and go to state 177
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 98

state 152

    (55) assign -> ID possibleArray . = expression

    =               shift and go to state 178


state 153

    (56) possibleArray -> [ . exp ]
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    data                           shift and go to state 42
    exp                            shift and go to state 179
    factor                         shift and go to state 40
    input                          shift and go to state 44

state 154

    (58) conditional -> IF ( . expression ) { block } possibleElif possibleElse
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    input                          shift and go to state 44
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    expression                     shift and go to state 180

state 155

    (44) block -> funcCall ; . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    loop                           shift and go to state 137
    output                         shift and go to state 135
    assign                         shift and go to state 136
    block                          shift and go to state 181

state 156

    (30) main -> MAIN ( par ) { block } .

    $end            reduce using rule 30 (main -> MAIN ( par ) { block } .)


state 157

    (45) block -> output block .

    }               reduce using rule 45 (block -> output block .)
    RETURN          reduce using rule 45 (block -> output block .)


state 158

    (41) block -> assign ; . block
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    RETURN          reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 182
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 159

    (43) block -> loop block .

    }               reduce using rule 43 (block -> loop block .)
    RETURN          reduce using rule 43 (block -> loop block .)


state 160

    (33) morePar -> , type ID . morePar
    (33) morePar -> . , type ID morePar
    (34) morePar -> .

    ,               shift and go to state 109
    )               reduce using rule 34 (morePar -> .)

    morePar                        shift and go to state 183

state 161

    (38) moreParIn -> , expression moreParIn .

    )               reduce using rule 38 (moreParIn -> , expression moreParIn .)


state 162

    (10) moreVar -> , ID = expression moreVar .

    ;               reduce using rule 10 (moreVar -> , ID = expression moreVar .)


state 163

    (20) moreArray -> , ID [ INT ] = { expression . moreExp } moreArray
    (18) moreExp -> . , expression moreExp
    (19) moreExp -> .

    ,               shift and go to state 164
    }               reduce using rule 19 (moreExp -> .)

    moreExp                        shift and go to state 184

state 164

    (18) moreExp -> , . expression moreExp
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 185

state 165

    (17) firstArr -> type ID [ INT ] = { expression moreExp . }

    }               shift and go to state 186


state 166

    (22) function -> FUNCTION funcType ID ( par ) { block RETURN . returnType ; }
    (28) returnType -> . expression
    (29) returnType -> . VOID
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    VOID            shift and go to state 187
    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    constant                       shift and go to state 39
    term                           shift and go to state 48
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    returnType                     shift and go to state 188
    input                          shift and go to state 44
    expression                     shift and go to state 189

state 167

    (49) loopBlock -> conditional . loopBlock
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 190
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 168

    (69) doWhile -> DO { loopBlock . } WHILE ( expression ) ;

    }               shift and go to state 191


state 169

    (53) loopBlock -> input . loopBlock
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 192
    doWhile                        shift and go to state 123
    output                         shift and go to state 172
    input                          shift and go to state 169
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 170

    (51) loopBlock -> funcCall . ; loopBlock

    ;               shift and go to state 193


state 171

    (50) loopBlock -> loop . loopBlock
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 194
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 172

    (52) loopBlock -> output . loopBlock
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 195
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 173

    (48) loopBlock -> assign . ; loopBlock

    ;               shift and go to state 196


state 174

    (68) while -> WHILE ( expression . ) { loopBlock }

    )               shift and go to state 197


state 175

    (63) output -> CONSOLE ( expression . ) ;

    )               shift and go to state 198


state 176

    (67) for -> FOR ( expression . ; assign ) { loopBlock }

    ;               shift and go to state 199


state 177

    (35) funcCall -> ID ( parIn . )

    )               shift and go to state 200


state 178

    (55) assign -> ID possibleArray = . expression
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    input                          shift and go to state 44
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    expression                     shift and go to state 201

state 179

    (56) possibleArray -> [ exp . ]

    ]               shift and go to state 202


state 180

    (58) conditional -> IF ( expression . ) { block } possibleElif possibleElse

    )               shift and go to state 203


state 181

    (44) block -> funcCall ; block .

    }               reduce using rule 44 (block -> funcCall ; block .)
    RETURN          reduce using rule 44 (block -> funcCall ; block .)


state 182

    (41) block -> assign ; block .

    }               reduce using rule 41 (block -> assign ; block .)
    RETURN          reduce using rule 41 (block -> assign ; block .)


state 183

    (33) morePar -> , type ID morePar .

    )               reduce using rule 33 (morePar -> , type ID morePar .)


state 184

    (20) moreArray -> , ID [ INT ] = { expression moreExp . } moreArray

    }               shift and go to state 204


state 185

    (18) moreExp -> , expression . moreExp
    (18) moreExp -> . , expression moreExp
    (19) moreExp -> .

    ,               shift and go to state 164
    }               reduce using rule 19 (moreExp -> .)

    moreExp                        shift and go to state 205

state 186

    (17) firstArr -> type ID [ INT ] = { expression moreExp } .

    ,               reduce using rule 17 (firstArr -> type ID [ INT ] = { expression moreExp } .)
    ;               reduce using rule 17 (firstArr -> type ID [ INT ] = { expression moreExp } .)


state 187

    (29) returnType -> VOID .

    ;               reduce using rule 29 (returnType -> VOID .)


state 188

    (22) function -> FUNCTION funcType ID ( par ) { block RETURN returnType . ; }

    ;               shift and go to state 206


state 189

    (28) returnType -> expression .

    ;               reduce using rule 28 (returnType -> expression .)


state 190

    (49) loopBlock -> conditional loopBlock .

    }               reduce using rule 49 (loopBlock -> conditional loopBlock .)


state 191

    (69) doWhile -> DO { loopBlock } . WHILE ( expression ) ;

    WHILE           shift and go to state 207


state 192

    (53) loopBlock -> input loopBlock .

    }               reduce using rule 53 (loopBlock -> input loopBlock .)


state 193

    (51) loopBlock -> funcCall ; . loopBlock
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 208
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 194

    (50) loopBlock -> loop loopBlock .

    }               reduce using rule 50 (loopBlock -> loop loopBlock .)


state 195

    (52) loopBlock -> output loopBlock .

    }               reduce using rule 52 (loopBlock -> output loopBlock .)


state 196

    (48) loopBlock -> assign ; . loopBlock
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 209
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 197

    (68) while -> WHILE ( expression ) . { loopBlock }

    {               shift and go to state 210


state 198

    (63) output -> CONSOLE ( expression ) . ;

    ;               shift and go to state 211


state 199

    (67) for -> FOR ( expression ; . assign ) { loopBlock }
    (55) assign -> . ID possibleArray = expression

    ID              shift and go to state 212

    assign                         shift and go to state 213

state 200

    (35) funcCall -> ID ( parIn ) .

    ;               reduce using rule 35 (funcCall -> ID ( parIn ) .)


state 201

    (55) assign -> ID possibleArray = expression .

    ;               reduce using rule 55 (assign -> ID possibleArray = expression .)
    )               reduce using rule 55 (assign -> ID possibleArray = expression .)


state 202

    (56) possibleArray -> [ exp ] .

    =               reduce using rule 56 (possibleArray -> [ exp ] .)


state 203

    (58) conditional -> IF ( expression ) . { block } possibleElif possibleElse

    {               shift and go to state 214


state 204

    (20) moreArray -> , ID [ INT ] = { expression moreExp } . moreArray
    (20) moreArray -> . , ID [ INT ] = { expression moreExp } moreArray
    (21) moreArray -> .

    ,               shift and go to state 23
    ;               reduce using rule 21 (moreArray -> .)

    moreArray                      shift and go to state 215

state 205

    (18) moreExp -> , expression moreExp .

    }               reduce using rule 18 (moreExp -> , expression moreExp .)


state 206

    (22) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; . }

    }               shift and go to state 216


state 207

    (69) doWhile -> DO { loopBlock } WHILE . ( expression ) ;

    (               shift and go to state 217


state 208

    (51) loopBlock -> funcCall ; loopBlock .

    }               reduce using rule 51 (loopBlock -> funcCall ; loopBlock .)


state 209

    (48) loopBlock -> assign ; loopBlock .

    }               reduce using rule 48 (loopBlock -> assign ; loopBlock .)


state 210

    (68) while -> WHILE ( expression ) { . loopBlock }
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 218
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 211

    (63) output -> CONSOLE ( expression ) ; .

    ARRAY           reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    ID              reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    IF              reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    CONSOLE         reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    INPUT           reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    FOR             reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    WHILE           reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    DO              reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    INTTYPE         reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    FLOATTYPE       reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    STRINGTYPE      reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    BOOLTYPE        reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    }               reduce using rule 63 (output -> CONSOLE ( expression ) ; .)
    RETURN          reduce using rule 63 (output -> CONSOLE ( expression ) ; .)


state 212

    (55) assign -> ID . possibleArray = expression
    (56) possibleArray -> . [ exp ]
    (57) possibleArray -> .

    [               shift and go to state 153
    =               reduce using rule 57 (possibleArray -> .)

    possibleArray                  shift and go to state 152

state 213

    (67) for -> FOR ( expression ; assign . ) { loopBlock }

    )               shift and go to state 219


state 214

    (58) conditional -> IF ( expression ) { . block } possibleElif possibleElse
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    vars                           shift and go to state 4
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 220
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 215

    (20) moreArray -> , ID [ INT ] = { expression moreExp } moreArray .

    ;               reduce using rule 20 (moreArray -> , ID [ INT ] = { expression moreExp } moreArray .)


state 216

    (22) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .

    FUNCTION        reduce using rule 22 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)
    MAIN            reduce using rule 22 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)


state 217

    (69) doWhile -> DO { loopBlock } WHILE ( . expression ) ;
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    input                          shift and go to state 44
    expression                     shift and go to state 221

state 218

    (68) while -> WHILE ( expression ) { loopBlock . }

    }               shift and go to state 222


state 219

    (67) for -> FOR ( expression ; assign ) . { loopBlock }

    {               shift and go to state 223


state 220

    (58) conditional -> IF ( expression ) { block . } possibleElif possibleElse

    }               shift and go to state 224


state 221

    (69) doWhile -> DO { loopBlock } WHILE ( expression . ) ;

    )               shift and go to state 225


state 222

    (68) while -> WHILE ( expression ) { loopBlock } .

    ARRAY           reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    ID              reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    IF              reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    CONSOLE         reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    INPUT           reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    FOR             reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    WHILE           reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    DO              reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    INTTYPE         reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    FLOATTYPE       reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    STRINGTYPE      reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    BOOLTYPE        reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    }               reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)
    RETURN          reduce using rule 68 (while -> WHILE ( expression ) { loopBlock } .)


state 223

    (67) for -> FOR ( expression ; assign ) { . loopBlock }
    (48) loopBlock -> . assign ; loopBlock
    (49) loopBlock -> . conditional loopBlock
    (50) loopBlock -> . loop loopBlock
    (51) loopBlock -> . funcCall ; loopBlock
    (52) loopBlock -> . output loopBlock
    (53) loopBlock -> . input loopBlock
    (54) loopBlock -> .
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 54 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 170
    conditional                    shift and go to state 167
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 226
    doWhile                        shift and go to state 123
    input                          shift and go to state 169
    output                         shift and go to state 172
    assign                         shift and go to state 173
    loop                           shift and go to state 171

state 224

    (58) conditional -> IF ( expression ) { block } . possibleElif possibleElse
    (59) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (60) possibleElif -> .

    ELIF            shift and go to state 227
    ELSE            reduce using rule 60 (possibleElif -> .)
    ARRAY           reduce using rule 60 (possibleElif -> .)
    ID              reduce using rule 60 (possibleElif -> .)
    IF              reduce using rule 60 (possibleElif -> .)
    CONSOLE         reduce using rule 60 (possibleElif -> .)
    INPUT           reduce using rule 60 (possibleElif -> .)
    FOR             reduce using rule 60 (possibleElif -> .)
    WHILE           reduce using rule 60 (possibleElif -> .)
    DO              reduce using rule 60 (possibleElif -> .)
    INTTYPE         reduce using rule 60 (possibleElif -> .)
    FLOATTYPE       reduce using rule 60 (possibleElif -> .)
    STRINGTYPE      reduce using rule 60 (possibleElif -> .)
    BOOLTYPE        reduce using rule 60 (possibleElif -> .)
    }               reduce using rule 60 (possibleElif -> .)
    RETURN          reduce using rule 60 (possibleElif -> .)

    possibleElif                   shift and go to state 228

state 225

    (69) doWhile -> DO { loopBlock } WHILE ( expression ) . ;

    ;               shift and go to state 229


state 226

    (67) for -> FOR ( expression ; assign ) { loopBlock . }

    }               shift and go to state 230


state 227

    (59) possibleElif -> ELIF . ( expression ) { block } possibleElif

    (               shift and go to state 231


state 228

    (58) conditional -> IF ( expression ) { block } possibleElif . possibleElse
    (61) possibleElse -> . ELSE { block }
    (62) possibleElse -> .

    ELSE            shift and go to state 233
    ARRAY           reduce using rule 62 (possibleElse -> .)
    ID              reduce using rule 62 (possibleElse -> .)
    IF              reduce using rule 62 (possibleElse -> .)
    CONSOLE         reduce using rule 62 (possibleElse -> .)
    INPUT           reduce using rule 62 (possibleElse -> .)
    FOR             reduce using rule 62 (possibleElse -> .)
    WHILE           reduce using rule 62 (possibleElse -> .)
    DO              reduce using rule 62 (possibleElse -> .)
    INTTYPE         reduce using rule 62 (possibleElse -> .)
    FLOATTYPE       reduce using rule 62 (possibleElse -> .)
    STRINGTYPE      reduce using rule 62 (possibleElse -> .)
    BOOLTYPE        reduce using rule 62 (possibleElse -> .)
    }               reduce using rule 62 (possibleElse -> .)
    RETURN          reduce using rule 62 (possibleElse -> .)

    possibleElse                   shift and go to state 232

state 229

    (69) doWhile -> DO { loopBlock } WHILE ( expression ) ; .

    ID              reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    IF              reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    CONSOLE         reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INPUT           reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FOR             reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    WHILE           reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    DO              reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    }               reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    ARRAY           reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INTTYPE         reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FLOATTYPE       reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    STRINGTYPE      reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    BOOLTYPE        reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    RETURN          reduce using rule 69 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)


state 230

    (67) for -> FOR ( expression ; assign ) { loopBlock } .

    ARRAY           reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    ID              reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    IF              reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    CONSOLE         reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INPUT           reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FOR             reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    WHILE           reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    DO              reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INTTYPE         reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FLOATTYPE       reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    STRINGTYPE      reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    BOOLTYPE        reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    }               reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)
    RETURN          reduce using rule 67 (for -> FOR ( expression ; assign ) { loopBlock } .)


state 231

    (59) possibleElif -> ELIF ( . expression ) { block } possibleElif
    (70) expression -> . higherExp possibleHigherExp
    (75) higherExp -> . exp possibleExp
    (84) exp -> . term possibleTerms
    (89) term -> . factor possibleFactors
    (95) factor -> . ( expression )
    (96) factor -> . data
    (97) data -> . ID possibleIdCall
    (98) data -> . constant
    (99) data -> . input
    (103) constant -> . INT
    (104) constant -> . FLOAT
    (105) constant -> . TRUE
    (106) constant -> . FALSE
    (107) constant -> . STRING
    (108) input -> . INPUT ( inputPar )

    (               shift and go to state 53
    ID              shift and go to state 47
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    TRUE            shift and go to state 41
    FALSE           shift and go to state 49
    STRING          shift and go to state 45
    INPUT           shift and go to state 46

    term                           shift and go to state 48
    constant                       shift and go to state 39
    input                          shift and go to state 44
    higherExp                      shift and go to state 43
    data                           shift and go to state 42
    exp                            shift and go to state 52
    factor                         shift and go to state 40
    expression                     shift and go to state 234

state 232

    (58) conditional -> IF ( expression ) { block } possibleElif possibleElse .

    ID              reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    IF              reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    CONSOLE         reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INPUT           reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FOR             reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    WHILE           reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    DO              reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    }               reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    ARRAY           reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INTTYPE         reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FLOATTYPE       reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    STRINGTYPE      reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    BOOLTYPE        reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    RETURN          reduce using rule 58 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)


state 233

    (61) possibleElse -> ELSE . { block }

    {               shift and go to state 235


state 234

    (59) possibleElif -> ELIF ( expression . ) { block } possibleElif

    )               shift and go to state 236


state 235

    (61) possibleElse -> ELSE { . block }
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 237
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 236

    (59) possibleElif -> ELIF ( expression ) . { block } possibleElif

    {               shift and go to state 238


state 237

    (61) possibleElse -> ELSE { block . }

    }               shift and go to state 239


state 238

    (59) possibleElif -> ELIF ( expression ) { . block } possibleElif
    (40) block -> . varDeclar block
    (41) block -> . assign ; block
    (42) block -> . conditional block
    (43) block -> . loop block
    (44) block -> . funcCall ; block
    (45) block -> . output block
    (46) block -> . input block
    (47) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (55) assign -> . ID possibleArray = expression
    (58) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (64) loop -> . for
    (65) loop -> . while
    (66) loop -> . doWhile
    (35) funcCall -> . ID ( parIn )
    (63) output -> . CONSOLE ( expression ) ;
    (108) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (67) for -> . FOR ( expression ; assign ) { loopBlock }
    (68) while -> . WHILE ( expression ) { loopBlock }
    (69) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 47 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 46
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 240
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 239

    (61) possibleElse -> ELSE { block } .

    ARRAY           reduce using rule 61 (possibleElse -> ELSE { block } .)
    ID              reduce using rule 61 (possibleElse -> ELSE { block } .)
    IF              reduce using rule 61 (possibleElse -> ELSE { block } .)
    CONSOLE         reduce using rule 61 (possibleElse -> ELSE { block } .)
    INPUT           reduce using rule 61 (possibleElse -> ELSE { block } .)
    FOR             reduce using rule 61 (possibleElse -> ELSE { block } .)
    WHILE           reduce using rule 61 (possibleElse -> ELSE { block } .)
    DO              reduce using rule 61 (possibleElse -> ELSE { block } .)
    INTTYPE         reduce using rule 61 (possibleElse -> ELSE { block } .)
    FLOATTYPE       reduce using rule 61 (possibleElse -> ELSE { block } .)
    STRINGTYPE      reduce using rule 61 (possibleElse -> ELSE { block } .)
    BOOLTYPE        reduce using rule 61 (possibleElse -> ELSE { block } .)
    }               reduce using rule 61 (possibleElse -> ELSE { block } .)
    RETURN          reduce using rule 61 (possibleElse -> ELSE { block } .)


state 240

    (59) possibleElif -> ELIF ( expression ) { block . } possibleElif

    }               shift and go to state 241


state 241

    (59) possibleElif -> ELIF ( expression ) { block } . possibleElif
    (59) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (60) possibleElif -> .

    ELIF            shift and go to state 227
    ELSE            reduce using rule 60 (possibleElif -> .)
    ARRAY           reduce using rule 60 (possibleElif -> .)
    ID              reduce using rule 60 (possibleElif -> .)
    IF              reduce using rule 60 (possibleElif -> .)
    CONSOLE         reduce using rule 60 (possibleElif -> .)
    INPUT           reduce using rule 60 (possibleElif -> .)
    FOR             reduce using rule 60 (possibleElif -> .)
    WHILE           reduce using rule 60 (possibleElif -> .)
    DO              reduce using rule 60 (possibleElif -> .)
    INTTYPE         reduce using rule 60 (possibleElif -> .)
    FLOATTYPE       reduce using rule 60 (possibleElif -> .)
    STRINGTYPE      reduce using rule 60 (possibleElif -> .)
    BOOLTYPE        reduce using rule 60 (possibleElif -> .)
    }               reduce using rule 60 (possibleElif -> .)
    RETURN          reduce using rule 60 (possibleElif -> .)

    possibleElif                   shift and go to state 242

state 242

    (59) possibleElif -> ELIF ( expression ) { block } possibleElif .

    ELSE            reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ARRAY           reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ID              reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    IF              reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    CONSOLE         reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INPUT           reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FOR             reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    WHILE           reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    DO              reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INTTYPE         reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FLOATTYPE       reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    STRINGTYPE      reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    BOOLTYPE        reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    }               reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    RETURN          reduce using rule 59 (possibleElif -> ELIF ( expression ) { block } possibleElif .)

