Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    GLOBAL

Grammar

Rule 0     S' -> program
Rule 1     program -> globalVarDeclar functionDeclar main
Rule 2     globalVarDeclar -> initVarDeclar
Rule 3     initVarDeclar -> varDeclar initVarDeclar
Rule 4     initVarDeclar -> <empty>
Rule 5     functionDeclar -> function functionDeclar
Rule 6     functionDeclar -> <empty>
Rule 7     varDeclar -> vars ;
Rule 8     varDeclar -> ARRAY arrays ;
Rule 9     vars -> type ID = expression moreVar
Rule 10    moreVar -> , ID = expression moreVar
Rule 11    moreVar -> <empty>
Rule 12    type -> INTTYPE
Rule 13    type -> FLOATTYPE
Rule 14    type -> STRINGTYPE
Rule 15    type -> BOOLTYPE
Rule 16    arrays -> type ID [ constant ] = { expression moreExp } moreArray
Rule 17    moreExp -> , expression moreExp
Rule 18    moreExp -> <empty>
Rule 19    moreArray -> , ID [ constant ] = { expression moreExp } moreArray
Rule 20    moreArray -> <empty>
Rule 21    function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; }
Rule 22    funcType -> INTTYPE
Rule 23    funcType -> FLOATTYPE
Rule 24    funcType -> STRINGTYPE
Rule 25    funcType -> BOOLTYPE
Rule 26    funcType -> VOID
Rule 27    returnType -> expression
Rule 28    returnType -> VOID
Rule 29    main -> MAIN ( par ) { block }
Rule 30    par -> type ID morePar
Rule 31    par -> <empty>
Rule 32    morePar -> , type ID morePar
Rule 33    morePar -> <empty>
Rule 34    funcCall -> ID ( parIn )
Rule 35    parIn -> expression moreParIn
Rule 36    parIn -> <empty>
Rule 37    moreParIn -> , expression moreParIn
Rule 38    moreParIn -> <empty>
Rule 39    block -> varDeclar block
Rule 40    block -> assign ; block
Rule 41    block -> conditional block
Rule 42    block -> loop block
Rule 43    block -> funcCall ; block
Rule 44    block -> output block
Rule 45    block -> input block
Rule 46    block -> <empty>
Rule 47    loopBlock -> assign ; loopBlock
Rule 48    loopBlock -> conditional loopBlock
Rule 49    loopBlock -> loop loopBlock
Rule 50    loopBlock -> funcCall ; loopBlock
Rule 51    loopBlock -> output loopBlock
Rule 52    loopBlock -> input loopBlock
Rule 53    loopBlock -> <empty>
Rule 54    assign -> ID possibleArray = expression
Rule 55    possibleArray -> [ exp ]
Rule 56    possibleArray -> <empty>
Rule 57    conditional -> IF ( expression ) { block } possibleElif possibleElse
Rule 58    possibleElif -> ELIF ( expression ) { block } possibleElif
Rule 59    possibleElif -> <empty>
Rule 60    possibleElse -> ELSE { block }
Rule 61    possibleElse -> <empty>
Rule 62    output -> CONSOLE ( expression ) ;
Rule 63    loop -> for
Rule 64    loop -> while
Rule 65    loop -> doWhile
Rule 66    for -> FOR ( expression ; assign ) { loopBlock }
Rule 67    while -> WHILE ( expression ) { loopBlock }
Rule 68    doWhile -> DO { loopBlock } WHILE ( expression ) ;
Rule 69    expression -> higherExp possibleHigherExp
Rule 70    possibleHigherExp -> possibleHigherExpOp higherExp
Rule 71    possibleHigherExp -> <empty>
Rule 72    possibleHigherExpOp -> AND
Rule 73    possibleHigherExpOp -> OR
Rule 74    higherExp -> exp possibleExp
Rule 75    possibleExp -> possibleExpOp exp
Rule 76    possibleExp -> <empty>
Rule 77    possibleExpOp -> LESS
Rule 78    possibleExpOp -> GREATER
Rule 79    possibleExpOp -> LESSEQUAL
Rule 80    possibleExpOp -> GREATEREQUAL
Rule 81    possibleExpOp -> DIFFERENT
Rule 82    possibleExpOp -> EQUALTO
Rule 83    exp -> term possibleTerms
Rule 84    possibleTerms -> possibleTermOp term possibleTerms
Rule 85    possibleTerms -> <empty>
Rule 86    possibleTermOp -> +
Rule 87    possibleTermOp -> -
Rule 88    term -> factor possibleFactors
Rule 89    possibleFactors -> possibleFactorOp factor possibleFactors
Rule 90    possibleFactors -> <empty>
Rule 91    possibleFactorOp -> *
Rule 92    possibleFactorOp -> /
Rule 93    possibleFactorOp -> %
Rule 94    factor -> ( expression )
Rule 95    factor -> data
Rule 96    data -> ID possibleIdCall
Rule 97    data -> constant
Rule 98    data -> input
Rule 99    possibleIdCall -> [ expression ]
Rule 100   possibleIdCall -> ( parIn )
Rule 101   possibleIdCall -> <empty>
Rule 102   constant -> INT
Rule 103   constant -> FLOAT
Rule 104   constant -> TRUE
Rule 105   constant -> FALSE
Rule 106   constant -> STRING
Rule 107   input -> INPUT ( inputPar )
Rule 108   inputPar -> STRING
Rule 109   inputPar -> <empty>

Terminals, with rules where they appear

%                    : 93
(                    : 21 29 34 57 58 62 66 67 68 94 100 107
)                    : 21 29 34 57 58 62 66 67 68 94 100 107
*                    : 91
+                    : 86
,                    : 10 17 19 32 37
-                    : 87
/                    : 92
;                    : 7 8 21 40 43 47 50 62 66 68
=                    : 9 10 16 19 54
AND                  : 72
ARRAY                : 8
BOOLTYPE             : 15 25
CONSOLE              : 62
DIFFERENT            : 81
DO                   : 68
ELIF                 : 58
ELSE                 : 60
EQUALTO              : 82
FALSE                : 105
FLOAT                : 103
FLOATTYPE            : 13 23
FOR                  : 66
FUNCTION             : 21
GLOBAL               : 
GREATER              : 78
GREATEREQUAL         : 80
ID                   : 9 10 16 19 21 30 32 34 54 96
IF                   : 57
INPUT                : 107
INT                  : 102
INTTYPE              : 12 22
LESS                 : 77
LESSEQUAL            : 79
MAIN                 : 29
OR                   : 73
RETURN               : 21
STRING               : 106 108
STRINGTYPE           : 14 24
TRUE                 : 104
VOID                 : 26 28
WHILE                : 67 68
[                    : 16 19 55 99
]                    : 16 19 55 99
error                : 
{                    : 16 19 21 29 57 58 60 66 67 68
}                    : 16 19 21 29 57 58 60 66 67 68

Nonterminals, with rules where they appear

arrays               : 8
assign               : 40 47 66
block                : 21 29 39 40 41 42 43 44 45 57 58 60
conditional          : 41 48
constant             : 16 19 97
data                 : 95
doWhile              : 65
exp                  : 55 74 75
expression           : 9 10 16 17 19 27 35 37 54 57 58 62 66 67 68 94 99
factor               : 88 89
for                  : 63
funcCall             : 43 50
funcType             : 21
function             : 5
functionDeclar       : 1 5
globalVarDeclar      : 1
higherExp            : 69 70
initVarDeclar        : 2 3
input                : 45 52 98
inputPar             : 107
loop                 : 42 49
loopBlock            : 47 48 49 50 51 52 66 67 68
main                 : 1
moreArray            : 16 19
moreExp              : 16 17 19
morePar              : 30 32
moreParIn            : 35 37
moreVar              : 9 10
output               : 44 51
par                  : 21 29
parIn                : 34 100
possibleArray        : 54
possibleElif         : 57 58
possibleElse         : 57
possibleExp          : 74
possibleExpOp        : 75
possibleFactorOp     : 89
possibleFactors      : 88 89
possibleHigherExp    : 69
possibleHigherExpOp  : 70
possibleIdCall       : 96
possibleTermOp       : 84
possibleTerms        : 83 84
program              : 0
returnType           : 21
term                 : 83 84
type                 : 9 16 30 32
varDeclar            : 3 39
vars                 : 7
while                : 64

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . globalVarDeclar functionDeclar main
    (2) globalVarDeclar -> . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    FUNCTION        reduce using rule 4 (initVarDeclar -> .)
    MAIN            reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    globalVarDeclar                shift and go to state 7
    program                        shift and go to state 8
    initVarDeclar                  shift and go to state 9
    type                           shift and go to state 10
    varDeclar                      shift and go to state 11

state 1

    (15) type -> BOOLTYPE .

    ID              reduce using rule 15 (type -> BOOLTYPE .)


state 2

    (14) type -> STRINGTYPE .

    ID              reduce using rule 14 (type -> STRINGTYPE .)


state 3

    (12) type -> INTTYPE .

    ID              reduce using rule 12 (type -> INTTYPE .)


state 4

    (7) varDeclar -> vars . ;

    ;               shift and go to state 12


state 5

    (13) type -> FLOATTYPE .

    ID              reduce using rule 13 (type -> FLOATTYPE .)


state 6

    (8) varDeclar -> ARRAY . arrays ;
    (16) arrays -> . type ID [ constant ] = { expression moreExp } moreArray
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    arrays                         shift and go to state 13
    type                           shift and go to state 14

state 7

    (1) program -> globalVarDeclar . functionDeclar main
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (21) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 16

    function                       shift and go to state 15
    functionDeclar                 shift and go to state 17

state 8

    (0) S' -> program .



state 9

    (2) globalVarDeclar -> initVarDeclar .

    FUNCTION        reduce using rule 2 (globalVarDeclar -> initVarDeclar .)
    MAIN            reduce using rule 2 (globalVarDeclar -> initVarDeclar .)


state 10

    (9) vars -> type . ID = expression moreVar

    ID              shift and go to state 18


state 11

    (3) initVarDeclar -> varDeclar . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    FUNCTION        reduce using rule 4 (initVarDeclar -> .)
    MAIN            reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    initVarDeclar                  shift and go to state 19
    varDeclar                      shift and go to state 11
    type                           shift and go to state 10

state 12

    (7) varDeclar -> vars ; .

    ARRAY           reduce using rule 7 (varDeclar -> vars ; .)
    ID              reduce using rule 7 (varDeclar -> vars ; .)
    IF              reduce using rule 7 (varDeclar -> vars ; .)
    CONSOLE         reduce using rule 7 (varDeclar -> vars ; .)
    INPUT           reduce using rule 7 (varDeclar -> vars ; .)
    FOR             reduce using rule 7 (varDeclar -> vars ; .)
    WHILE           reduce using rule 7 (varDeclar -> vars ; .)
    DO              reduce using rule 7 (varDeclar -> vars ; .)
    INTTYPE         reduce using rule 7 (varDeclar -> vars ; .)
    FLOATTYPE       reduce using rule 7 (varDeclar -> vars ; .)
    STRINGTYPE      reduce using rule 7 (varDeclar -> vars ; .)
    BOOLTYPE        reduce using rule 7 (varDeclar -> vars ; .)
    }               reduce using rule 7 (varDeclar -> vars ; .)
    RETURN          reduce using rule 7 (varDeclar -> vars ; .)
    FUNCTION        reduce using rule 7 (varDeclar -> vars ; .)
    MAIN            reduce using rule 7 (varDeclar -> vars ; .)


state 13

    (8) varDeclar -> ARRAY arrays . ;

    ;               shift and go to state 20


state 14

    (16) arrays -> type . ID [ constant ] = { expression moreExp } moreArray

    ID              shift and go to state 21


state 15

    (5) functionDeclar -> function . functionDeclar
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (21) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 16

    function                       shift and go to state 15
    functionDeclar                 shift and go to state 22

state 16

    (21) function -> FUNCTION . funcType ID ( par ) { block RETURN returnType ; }
    (22) funcType -> . INTTYPE
    (23) funcType -> . FLOATTYPE
    (24) funcType -> . STRINGTYPE
    (25) funcType -> . BOOLTYPE
    (26) funcType -> . VOID

    INTTYPE         shift and go to state 28
    FLOATTYPE       shift and go to state 24
    STRINGTYPE      shift and go to state 23
    BOOLTYPE        shift and go to state 27
    VOID            shift and go to state 26

    funcType                       shift and go to state 25

state 17

    (1) program -> globalVarDeclar functionDeclar . main
    (29) main -> . MAIN ( par ) { block }

    MAIN            shift and go to state 30

    main                           shift and go to state 29

state 18

    (9) vars -> type ID . = expression moreVar

    =               shift and go to state 31


state 19

    (3) initVarDeclar -> varDeclar initVarDeclar .

    FUNCTION        reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)
    MAIN            reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)


state 20

    (8) varDeclar -> ARRAY arrays ; .

    ARRAY           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    ID              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    IF              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    CONSOLE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INPUT           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FOR             reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    WHILE           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    DO              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INTTYPE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FLOATTYPE       reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    STRINGTYPE      reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    BOOLTYPE        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    }               reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    RETURN          reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FUNCTION        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    MAIN            reduce using rule 8 (varDeclar -> ARRAY arrays ; .)


state 21

    (16) arrays -> type ID . [ constant ] = { expression moreExp } moreArray

    [               shift and go to state 32


state 22

    (5) functionDeclar -> function functionDeclar .

    MAIN            reduce using rule 5 (functionDeclar -> function functionDeclar .)


state 23

    (24) funcType -> STRINGTYPE .

    ID              reduce using rule 24 (funcType -> STRINGTYPE .)


state 24

    (23) funcType -> FLOATTYPE .

    ID              reduce using rule 23 (funcType -> FLOATTYPE .)


state 25

    (21) function -> FUNCTION funcType . ID ( par ) { block RETURN returnType ; }

    ID              shift and go to state 33


state 26

    (26) funcType -> VOID .

    ID              reduce using rule 26 (funcType -> VOID .)


state 27

    (25) funcType -> BOOLTYPE .

    ID              reduce using rule 25 (funcType -> BOOLTYPE .)


state 28

    (22) funcType -> INTTYPE .

    ID              reduce using rule 22 (funcType -> INTTYPE .)


state 29

    (1) program -> globalVarDeclar functionDeclar main .

    $end            reduce using rule 1 (program -> globalVarDeclar functionDeclar main .)


state 30

    (29) main -> MAIN . ( par ) { block }

    (               shift and go to state 34


state 31

    (9) vars -> type ID = . expression moreVar
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    input                          shift and go to state 40
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    expression                     shift and go to state 50

state 32

    (16) arrays -> type ID [ . constant ] = { expression moreExp } moreArray
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING

    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41

    constant                       shift and go to state 51

state 33

    (21) function -> FUNCTION funcType ID . ( par ) { block RETURN returnType ; }

    (               shift and go to state 52


state 34

    (29) main -> MAIN ( . par ) { block }
    (30) par -> . type ID morePar
    (31) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 31 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 53
    type                           shift and go to state 54

state 35

    (97) data -> constant .

    *               reduce using rule 97 (data -> constant .)
    /               reduce using rule 97 (data -> constant .)
    %               reduce using rule 97 (data -> constant .)
    +               reduce using rule 97 (data -> constant .)
    -               reduce using rule 97 (data -> constant .)
    LESS            reduce using rule 97 (data -> constant .)
    GREATER         reduce using rule 97 (data -> constant .)
    LESSEQUAL       reduce using rule 97 (data -> constant .)
    GREATEREQUAL    reduce using rule 97 (data -> constant .)
    DIFFERENT       reduce using rule 97 (data -> constant .)
    EQUALTO         reduce using rule 97 (data -> constant .)
    ,               reduce using rule 97 (data -> constant .)
    ;               reduce using rule 97 (data -> constant .)
    )               reduce using rule 97 (data -> constant .)
    ]               reduce using rule 97 (data -> constant .)
    }               reduce using rule 97 (data -> constant .)
    AND             reduce using rule 97 (data -> constant .)
    OR              reduce using rule 97 (data -> constant .)


state 36

    (88) term -> factor . possibleFactors
    (89) possibleFactors -> . possibleFactorOp factor possibleFactors
    (90) possibleFactors -> .
    (91) possibleFactorOp -> . *
    (92) possibleFactorOp -> . /
    (93) possibleFactorOp -> . %

    +               reduce using rule 90 (possibleFactors -> .)
    -               reduce using rule 90 (possibleFactors -> .)
    LESS            reduce using rule 90 (possibleFactors -> .)
    GREATER         reduce using rule 90 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 90 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 90 (possibleFactors -> .)
    DIFFERENT       reduce using rule 90 (possibleFactors -> .)
    EQUALTO         reduce using rule 90 (possibleFactors -> .)
    AND             reduce using rule 90 (possibleFactors -> .)
    OR              reduce using rule 90 (possibleFactors -> .)
    ,               reduce using rule 90 (possibleFactors -> .)
    ;               reduce using rule 90 (possibleFactors -> .)
    )               reduce using rule 90 (possibleFactors -> .)
    ]               reduce using rule 90 (possibleFactors -> .)
    }               reduce using rule 90 (possibleFactors -> .)
    *               shift and go to state 56
    /               shift and go to state 58
    %               shift and go to state 55

    possibleFactors                shift and go to state 57
    possibleFactorOp               shift and go to state 59

state 37

    (104) constant -> TRUE .

    *               reduce using rule 104 (constant -> TRUE .)
    /               reduce using rule 104 (constant -> TRUE .)
    %               reduce using rule 104 (constant -> TRUE .)
    +               reduce using rule 104 (constant -> TRUE .)
    -               reduce using rule 104 (constant -> TRUE .)
    LESS            reduce using rule 104 (constant -> TRUE .)
    GREATER         reduce using rule 104 (constant -> TRUE .)
    LESSEQUAL       reduce using rule 104 (constant -> TRUE .)
    GREATEREQUAL    reduce using rule 104 (constant -> TRUE .)
    DIFFERENT       reduce using rule 104 (constant -> TRUE .)
    EQUALTO         reduce using rule 104 (constant -> TRUE .)
    AND             reduce using rule 104 (constant -> TRUE .)
    OR              reduce using rule 104 (constant -> TRUE .)
    ,               reduce using rule 104 (constant -> TRUE .)
    ;               reduce using rule 104 (constant -> TRUE .)
    )               reduce using rule 104 (constant -> TRUE .)
    ]               reduce using rule 104 (constant -> TRUE .)
    }               reduce using rule 104 (constant -> TRUE .)


state 38

    (95) factor -> data .

    *               reduce using rule 95 (factor -> data .)
    /               reduce using rule 95 (factor -> data .)
    %               reduce using rule 95 (factor -> data .)
    +               reduce using rule 95 (factor -> data .)
    -               reduce using rule 95 (factor -> data .)
    AND             reduce using rule 95 (factor -> data .)
    OR              reduce using rule 95 (factor -> data .)
    ,               reduce using rule 95 (factor -> data .)
    ;               reduce using rule 95 (factor -> data .)
    )               reduce using rule 95 (factor -> data .)
    ]               reduce using rule 95 (factor -> data .)
    }               reduce using rule 95 (factor -> data .)
    LESS            reduce using rule 95 (factor -> data .)
    GREATER         reduce using rule 95 (factor -> data .)
    LESSEQUAL       reduce using rule 95 (factor -> data .)
    GREATEREQUAL    reduce using rule 95 (factor -> data .)
    DIFFERENT       reduce using rule 95 (factor -> data .)
    EQUALTO         reduce using rule 95 (factor -> data .)


state 39

    (69) expression -> higherExp . possibleHigherExp
    (70) possibleHigherExp -> . possibleHigherExpOp higherExp
    (71) possibleHigherExp -> .
    (72) possibleHigherExpOp -> . AND
    (73) possibleHigherExpOp -> . OR

    ,               reduce using rule 71 (possibleHigherExp -> .)
    ;               reduce using rule 71 (possibleHigherExp -> .)
    )               reduce using rule 71 (possibleHigherExp -> .)
    ]               reduce using rule 71 (possibleHigherExp -> .)
    }               reduce using rule 71 (possibleHigherExp -> .)
    AND             shift and go to state 60
    OR              shift and go to state 63

    possibleHigherExpOp            shift and go to state 61
    possibleHigherExp              shift and go to state 62

state 40

    (98) data -> input .

    *               reduce using rule 98 (data -> input .)
    /               reduce using rule 98 (data -> input .)
    %               reduce using rule 98 (data -> input .)
    +               reduce using rule 98 (data -> input .)
    -               reduce using rule 98 (data -> input .)
    LESS            reduce using rule 98 (data -> input .)
    GREATER         reduce using rule 98 (data -> input .)
    LESSEQUAL       reduce using rule 98 (data -> input .)
    GREATEREQUAL    reduce using rule 98 (data -> input .)
    DIFFERENT       reduce using rule 98 (data -> input .)
    EQUALTO         reduce using rule 98 (data -> input .)
    ,               reduce using rule 98 (data -> input .)
    ;               reduce using rule 98 (data -> input .)
    )               reduce using rule 98 (data -> input .)
    ]               reduce using rule 98 (data -> input .)
    }               reduce using rule 98 (data -> input .)
    AND             reduce using rule 98 (data -> input .)
    OR              reduce using rule 98 (data -> input .)


state 41

    (106) constant -> STRING .

    *               reduce using rule 106 (constant -> STRING .)
    /               reduce using rule 106 (constant -> STRING .)
    %               reduce using rule 106 (constant -> STRING .)
    +               reduce using rule 106 (constant -> STRING .)
    -               reduce using rule 106 (constant -> STRING .)
    LESS            reduce using rule 106 (constant -> STRING .)
    GREATER         reduce using rule 106 (constant -> STRING .)
    LESSEQUAL       reduce using rule 106 (constant -> STRING .)
    GREATEREQUAL    reduce using rule 106 (constant -> STRING .)
    DIFFERENT       reduce using rule 106 (constant -> STRING .)
    EQUALTO         reduce using rule 106 (constant -> STRING .)
    AND             reduce using rule 106 (constant -> STRING .)
    OR              reduce using rule 106 (constant -> STRING .)
    ,               reduce using rule 106 (constant -> STRING .)
    ;               reduce using rule 106 (constant -> STRING .)
    )               reduce using rule 106 (constant -> STRING .)
    ]               reduce using rule 106 (constant -> STRING .)
    }               reduce using rule 106 (constant -> STRING .)


state 42

    (107) input -> INPUT . ( inputPar )

    (               shift and go to state 64


state 43

    (96) data -> ID . possibleIdCall
    (99) possibleIdCall -> . [ expression ]
    (100) possibleIdCall -> . ( parIn )
    (101) possibleIdCall -> .

    [               shift and go to state 67
    (               shift and go to state 66
    *               reduce using rule 101 (possibleIdCall -> .)
    /               reduce using rule 101 (possibleIdCall -> .)
    %               reduce using rule 101 (possibleIdCall -> .)
    +               reduce using rule 101 (possibleIdCall -> .)
    -               reduce using rule 101 (possibleIdCall -> .)
    LESS            reduce using rule 101 (possibleIdCall -> .)
    GREATER         reduce using rule 101 (possibleIdCall -> .)
    LESSEQUAL       reduce using rule 101 (possibleIdCall -> .)
    GREATEREQUAL    reduce using rule 101 (possibleIdCall -> .)
    DIFFERENT       reduce using rule 101 (possibleIdCall -> .)
    EQUALTO         reduce using rule 101 (possibleIdCall -> .)
    AND             reduce using rule 101 (possibleIdCall -> .)
    OR              reduce using rule 101 (possibleIdCall -> .)
    ,               reduce using rule 101 (possibleIdCall -> .)
    ;               reduce using rule 101 (possibleIdCall -> .)
    )               reduce using rule 101 (possibleIdCall -> .)
    ]               reduce using rule 101 (possibleIdCall -> .)
    }               reduce using rule 101 (possibleIdCall -> .)

    possibleIdCall                 shift and go to state 65

state 44

    (83) exp -> term . possibleTerms
    (84) possibleTerms -> . possibleTermOp term possibleTerms
    (85) possibleTerms -> .
    (86) possibleTermOp -> . +
    (87) possibleTermOp -> . -

    LESS            reduce using rule 85 (possibleTerms -> .)
    GREATER         reduce using rule 85 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 85 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 85 (possibleTerms -> .)
    DIFFERENT       reduce using rule 85 (possibleTerms -> .)
    EQUALTO         reduce using rule 85 (possibleTerms -> .)
    AND             reduce using rule 85 (possibleTerms -> .)
    OR              reduce using rule 85 (possibleTerms -> .)
    ,               reduce using rule 85 (possibleTerms -> .)
    ;               reduce using rule 85 (possibleTerms -> .)
    )               reduce using rule 85 (possibleTerms -> .)
    ]               reduce using rule 85 (possibleTerms -> .)
    }               reduce using rule 85 (possibleTerms -> .)
    +               shift and go to state 71
    -               shift and go to state 70

    possibleTermOp                 shift and go to state 68
    possibleTerms                  shift and go to state 69

state 45

    (105) constant -> FALSE .

    *               reduce using rule 105 (constant -> FALSE .)
    /               reduce using rule 105 (constant -> FALSE .)
    %               reduce using rule 105 (constant -> FALSE .)
    +               reduce using rule 105 (constant -> FALSE .)
    -               reduce using rule 105 (constant -> FALSE .)
    LESS            reduce using rule 105 (constant -> FALSE .)
    GREATER         reduce using rule 105 (constant -> FALSE .)
    LESSEQUAL       reduce using rule 105 (constant -> FALSE .)
    GREATEREQUAL    reduce using rule 105 (constant -> FALSE .)
    DIFFERENT       reduce using rule 105 (constant -> FALSE .)
    EQUALTO         reduce using rule 105 (constant -> FALSE .)
    AND             reduce using rule 105 (constant -> FALSE .)
    OR              reduce using rule 105 (constant -> FALSE .)
    ,               reduce using rule 105 (constant -> FALSE .)
    ;               reduce using rule 105 (constant -> FALSE .)
    )               reduce using rule 105 (constant -> FALSE .)
    ]               reduce using rule 105 (constant -> FALSE .)
    }               reduce using rule 105 (constant -> FALSE .)


state 46

    (102) constant -> INT .

    *               reduce using rule 102 (constant -> INT .)
    /               reduce using rule 102 (constant -> INT .)
    %               reduce using rule 102 (constant -> INT .)
    +               reduce using rule 102 (constant -> INT .)
    -               reduce using rule 102 (constant -> INT .)
    LESS            reduce using rule 102 (constant -> INT .)
    GREATER         reduce using rule 102 (constant -> INT .)
    LESSEQUAL       reduce using rule 102 (constant -> INT .)
    GREATEREQUAL    reduce using rule 102 (constant -> INT .)
    DIFFERENT       reduce using rule 102 (constant -> INT .)
    EQUALTO         reduce using rule 102 (constant -> INT .)
    AND             reduce using rule 102 (constant -> INT .)
    OR              reduce using rule 102 (constant -> INT .)
    ,               reduce using rule 102 (constant -> INT .)
    ;               reduce using rule 102 (constant -> INT .)
    )               reduce using rule 102 (constant -> INT .)
    ]               reduce using rule 102 (constant -> INT .)
    }               reduce using rule 102 (constant -> INT .)


state 47

    (103) constant -> FLOAT .

    *               reduce using rule 103 (constant -> FLOAT .)
    /               reduce using rule 103 (constant -> FLOAT .)
    %               reduce using rule 103 (constant -> FLOAT .)
    +               reduce using rule 103 (constant -> FLOAT .)
    -               reduce using rule 103 (constant -> FLOAT .)
    LESS            reduce using rule 103 (constant -> FLOAT .)
    GREATER         reduce using rule 103 (constant -> FLOAT .)
    LESSEQUAL       reduce using rule 103 (constant -> FLOAT .)
    GREATEREQUAL    reduce using rule 103 (constant -> FLOAT .)
    DIFFERENT       reduce using rule 103 (constant -> FLOAT .)
    EQUALTO         reduce using rule 103 (constant -> FLOAT .)
    AND             reduce using rule 103 (constant -> FLOAT .)
    OR              reduce using rule 103 (constant -> FLOAT .)
    ,               reduce using rule 103 (constant -> FLOAT .)
    ;               reduce using rule 103 (constant -> FLOAT .)
    )               reduce using rule 103 (constant -> FLOAT .)
    ]               reduce using rule 103 (constant -> FLOAT .)
    }               reduce using rule 103 (constant -> FLOAT .)


state 48

    (74) higherExp -> exp . possibleExp
    (75) possibleExp -> . possibleExpOp exp
    (76) possibleExp -> .
    (77) possibleExpOp -> . LESS
    (78) possibleExpOp -> . GREATER
    (79) possibleExpOp -> . LESSEQUAL
    (80) possibleExpOp -> . GREATEREQUAL
    (81) possibleExpOp -> . DIFFERENT
    (82) possibleExpOp -> . EQUALTO

    AND             reduce using rule 76 (possibleExp -> .)
    OR              reduce using rule 76 (possibleExp -> .)
    ,               reduce using rule 76 (possibleExp -> .)
    ;               reduce using rule 76 (possibleExp -> .)
    )               reduce using rule 76 (possibleExp -> .)
    ]               reduce using rule 76 (possibleExp -> .)
    }               reduce using rule 76 (possibleExp -> .)
    LESS            shift and go to state 75
    GREATER         shift and go to state 73
    LESSEQUAL       shift and go to state 79
    GREATEREQUAL    shift and go to state 72
    DIFFERENT       shift and go to state 78
    EQUALTO         shift and go to state 77

    possibleExp                    shift and go to state 76
    possibleExpOp                  shift and go to state 74

state 49

    (94) factor -> ( . expression )
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 80

state 50

    (9) vars -> type ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 82
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 81

state 51

    (16) arrays -> type ID [ constant . ] = { expression moreExp } moreArray

    ]               shift and go to state 83


state 52

    (21) function -> FUNCTION funcType ID ( . par ) { block RETURN returnType ; }
    (30) par -> . type ID morePar
    (31) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 31 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 84
    type                           shift and go to state 54

state 53

    (29) main -> MAIN ( par . ) { block }

    )               shift and go to state 85


state 54

    (30) par -> type . ID morePar

    ID              shift and go to state 86


state 55

    (93) possibleFactorOp -> % .

    (               reduce using rule 93 (possibleFactorOp -> % .)
    ID              reduce using rule 93 (possibleFactorOp -> % .)
    INT             reduce using rule 93 (possibleFactorOp -> % .)
    FLOAT           reduce using rule 93 (possibleFactorOp -> % .)
    TRUE            reduce using rule 93 (possibleFactorOp -> % .)
    FALSE           reduce using rule 93 (possibleFactorOp -> % .)
    STRING          reduce using rule 93 (possibleFactorOp -> % .)
    INPUT           reduce using rule 93 (possibleFactorOp -> % .)


state 56

    (91) possibleFactorOp -> * .

    (               reduce using rule 91 (possibleFactorOp -> * .)
    ID              reduce using rule 91 (possibleFactorOp -> * .)
    INT             reduce using rule 91 (possibleFactorOp -> * .)
    FLOAT           reduce using rule 91 (possibleFactorOp -> * .)
    TRUE            reduce using rule 91 (possibleFactorOp -> * .)
    FALSE           reduce using rule 91 (possibleFactorOp -> * .)
    STRING          reduce using rule 91 (possibleFactorOp -> * .)
    INPUT           reduce using rule 91 (possibleFactorOp -> * .)


state 57

    (88) term -> factor possibleFactors .

    +               reduce using rule 88 (term -> factor possibleFactors .)
    -               reduce using rule 88 (term -> factor possibleFactors .)
    LESS            reduce using rule 88 (term -> factor possibleFactors .)
    GREATER         reduce using rule 88 (term -> factor possibleFactors .)
    LESSEQUAL       reduce using rule 88 (term -> factor possibleFactors .)
    GREATEREQUAL    reduce using rule 88 (term -> factor possibleFactors .)
    DIFFERENT       reduce using rule 88 (term -> factor possibleFactors .)
    EQUALTO         reduce using rule 88 (term -> factor possibleFactors .)
    AND             reduce using rule 88 (term -> factor possibleFactors .)
    OR              reduce using rule 88 (term -> factor possibleFactors .)
    ,               reduce using rule 88 (term -> factor possibleFactors .)
    }               reduce using rule 88 (term -> factor possibleFactors .)
    )               reduce using rule 88 (term -> factor possibleFactors .)
    ;               reduce using rule 88 (term -> factor possibleFactors .)
    ]               reduce using rule 88 (term -> factor possibleFactors .)


state 58

    (92) possibleFactorOp -> / .

    (               reduce using rule 92 (possibleFactorOp -> / .)
    ID              reduce using rule 92 (possibleFactorOp -> / .)
    INT             reduce using rule 92 (possibleFactorOp -> / .)
    FLOAT           reduce using rule 92 (possibleFactorOp -> / .)
    TRUE            reduce using rule 92 (possibleFactorOp -> / .)
    FALSE           reduce using rule 92 (possibleFactorOp -> / .)
    STRING          reduce using rule 92 (possibleFactorOp -> / .)
    INPUT           reduce using rule 92 (possibleFactorOp -> / .)


state 59

    (89) possibleFactors -> possibleFactorOp . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    constant                       shift and go to state 35
    data                           shift and go to state 38
    factor                         shift and go to state 87
    input                          shift and go to state 40

state 60

    (72) possibleHigherExpOp -> AND .

    (               reduce using rule 72 (possibleHigherExpOp -> AND .)
    ID              reduce using rule 72 (possibleHigherExpOp -> AND .)
    INT             reduce using rule 72 (possibleHigherExpOp -> AND .)
    FLOAT           reduce using rule 72 (possibleHigherExpOp -> AND .)
    TRUE            reduce using rule 72 (possibleHigherExpOp -> AND .)
    FALSE           reduce using rule 72 (possibleHigherExpOp -> AND .)
    STRING          reduce using rule 72 (possibleHigherExpOp -> AND .)
    INPUT           reduce using rule 72 (possibleHigherExpOp -> AND .)


state 61

    (70) possibleHigherExp -> possibleHigherExpOp . higherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 88
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40

state 62

    (69) expression -> higherExp possibleHigherExp .

    ;               reduce using rule 69 (expression -> higherExp possibleHigherExp .)
    )               reduce using rule 69 (expression -> higherExp possibleHigherExp .)
    ,               reduce using rule 69 (expression -> higherExp possibleHigherExp .)
    }               reduce using rule 69 (expression -> higherExp possibleHigherExp .)
    ]               reduce using rule 69 (expression -> higherExp possibleHigherExp .)


state 63

    (73) possibleHigherExpOp -> OR .

    (               reduce using rule 73 (possibleHigherExpOp -> OR .)
    ID              reduce using rule 73 (possibleHigherExpOp -> OR .)
    INT             reduce using rule 73 (possibleHigherExpOp -> OR .)
    FLOAT           reduce using rule 73 (possibleHigherExpOp -> OR .)
    TRUE            reduce using rule 73 (possibleHigherExpOp -> OR .)
    FALSE           reduce using rule 73 (possibleHigherExpOp -> OR .)
    STRING          reduce using rule 73 (possibleHigherExpOp -> OR .)
    INPUT           reduce using rule 73 (possibleHigherExpOp -> OR .)


state 64

    (107) input -> INPUT ( . inputPar )
    (108) inputPar -> . STRING
    (109) inputPar -> .

    STRING          shift and go to state 89
    )               reduce using rule 109 (inputPar -> .)

    inputPar                       shift and go to state 90

state 65

    (96) data -> ID possibleIdCall .

    *               reduce using rule 96 (data -> ID possibleIdCall .)
    /               reduce using rule 96 (data -> ID possibleIdCall .)
    %               reduce using rule 96 (data -> ID possibleIdCall .)
    +               reduce using rule 96 (data -> ID possibleIdCall .)
    -               reduce using rule 96 (data -> ID possibleIdCall .)
    LESS            reduce using rule 96 (data -> ID possibleIdCall .)
    GREATER         reduce using rule 96 (data -> ID possibleIdCall .)
    LESSEQUAL       reduce using rule 96 (data -> ID possibleIdCall .)
    GREATEREQUAL    reduce using rule 96 (data -> ID possibleIdCall .)
    DIFFERENT       reduce using rule 96 (data -> ID possibleIdCall .)
    EQUALTO         reduce using rule 96 (data -> ID possibleIdCall .)
    ,               reduce using rule 96 (data -> ID possibleIdCall .)
    ;               reduce using rule 96 (data -> ID possibleIdCall .)
    )               reduce using rule 96 (data -> ID possibleIdCall .)
    ]               reduce using rule 96 (data -> ID possibleIdCall .)
    }               reduce using rule 96 (data -> ID possibleIdCall .)
    AND             reduce using rule 96 (data -> ID possibleIdCall .)
    OR              reduce using rule 96 (data -> ID possibleIdCall .)


state 66

    (100) possibleIdCall -> ( . parIn )
    (35) parIn -> . expression moreParIn
    (36) parIn -> .
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    )               reduce using rule 36 (parIn -> .)
    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    data                           shift and go to state 38
    higherExp                      shift and go to state 39
    parIn                          shift and go to state 91
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 92

state 67

    (99) possibleIdCall -> [ . expression ]
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 93

state 68

    (84) possibleTerms -> possibleTermOp . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 94
    constant                       shift and go to state 35
    data                           shift and go to state 38
    factor                         shift and go to state 36
    input                          shift and go to state 40

state 69

    (83) exp -> term possibleTerms .

    LESS            reduce using rule 83 (exp -> term possibleTerms .)
    GREATER         reduce using rule 83 (exp -> term possibleTerms .)
    LESSEQUAL       reduce using rule 83 (exp -> term possibleTerms .)
    GREATEREQUAL    reduce using rule 83 (exp -> term possibleTerms .)
    DIFFERENT       reduce using rule 83 (exp -> term possibleTerms .)
    EQUALTO         reduce using rule 83 (exp -> term possibleTerms .)
    AND             reduce using rule 83 (exp -> term possibleTerms .)
    OR              reduce using rule 83 (exp -> term possibleTerms .)
    )               reduce using rule 83 (exp -> term possibleTerms .)
    ,               reduce using rule 83 (exp -> term possibleTerms .)
    ;               reduce using rule 83 (exp -> term possibleTerms .)
    ]               reduce using rule 83 (exp -> term possibleTerms .)
    }               reduce using rule 83 (exp -> term possibleTerms .)


state 70

    (87) possibleTermOp -> - .

    (               reduce using rule 87 (possibleTermOp -> - .)
    ID              reduce using rule 87 (possibleTermOp -> - .)
    INT             reduce using rule 87 (possibleTermOp -> - .)
    FLOAT           reduce using rule 87 (possibleTermOp -> - .)
    TRUE            reduce using rule 87 (possibleTermOp -> - .)
    FALSE           reduce using rule 87 (possibleTermOp -> - .)
    STRING          reduce using rule 87 (possibleTermOp -> - .)
    INPUT           reduce using rule 87 (possibleTermOp -> - .)


state 71

    (86) possibleTermOp -> + .

    (               reduce using rule 86 (possibleTermOp -> + .)
    ID              reduce using rule 86 (possibleTermOp -> + .)
    INT             reduce using rule 86 (possibleTermOp -> + .)
    FLOAT           reduce using rule 86 (possibleTermOp -> + .)
    TRUE            reduce using rule 86 (possibleTermOp -> + .)
    FALSE           reduce using rule 86 (possibleTermOp -> + .)
    STRING          reduce using rule 86 (possibleTermOp -> + .)
    INPUT           reduce using rule 86 (possibleTermOp -> + .)


state 72

    (80) possibleExpOp -> GREATEREQUAL .

    (               reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    ID              reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    INT             reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    FLOAT           reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    TRUE            reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    FALSE           reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    STRING          reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)
    INPUT           reduce using rule 80 (possibleExpOp -> GREATEREQUAL .)


state 73

    (78) possibleExpOp -> GREATER .

    (               reduce using rule 78 (possibleExpOp -> GREATER .)
    ID              reduce using rule 78 (possibleExpOp -> GREATER .)
    INT             reduce using rule 78 (possibleExpOp -> GREATER .)
    FLOAT           reduce using rule 78 (possibleExpOp -> GREATER .)
    TRUE            reduce using rule 78 (possibleExpOp -> GREATER .)
    FALSE           reduce using rule 78 (possibleExpOp -> GREATER .)
    STRING          reduce using rule 78 (possibleExpOp -> GREATER .)
    INPUT           reduce using rule 78 (possibleExpOp -> GREATER .)


state 74

    (75) possibleExp -> possibleExpOp . exp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    data                           shift and go to state 38
    exp                            shift and go to state 95
    factor                         shift and go to state 36
    input                          shift and go to state 40

state 75

    (77) possibleExpOp -> LESS .

    (               reduce using rule 77 (possibleExpOp -> LESS .)
    ID              reduce using rule 77 (possibleExpOp -> LESS .)
    INT             reduce using rule 77 (possibleExpOp -> LESS .)
    FLOAT           reduce using rule 77 (possibleExpOp -> LESS .)
    TRUE            reduce using rule 77 (possibleExpOp -> LESS .)
    FALSE           reduce using rule 77 (possibleExpOp -> LESS .)
    STRING          reduce using rule 77 (possibleExpOp -> LESS .)
    INPUT           reduce using rule 77 (possibleExpOp -> LESS .)


state 76

    (74) higherExp -> exp possibleExp .

    AND             reduce using rule 74 (higherExp -> exp possibleExp .)
    OR              reduce using rule 74 (higherExp -> exp possibleExp .)
    ,               reduce using rule 74 (higherExp -> exp possibleExp .)
    }               reduce using rule 74 (higherExp -> exp possibleExp .)
    ;               reduce using rule 74 (higherExp -> exp possibleExp .)
    )               reduce using rule 74 (higherExp -> exp possibleExp .)
    ]               reduce using rule 74 (higherExp -> exp possibleExp .)


state 77

    (82) possibleExpOp -> EQUALTO .

    (               reduce using rule 82 (possibleExpOp -> EQUALTO .)
    ID              reduce using rule 82 (possibleExpOp -> EQUALTO .)
    INT             reduce using rule 82 (possibleExpOp -> EQUALTO .)
    FLOAT           reduce using rule 82 (possibleExpOp -> EQUALTO .)
    TRUE            reduce using rule 82 (possibleExpOp -> EQUALTO .)
    FALSE           reduce using rule 82 (possibleExpOp -> EQUALTO .)
    STRING          reduce using rule 82 (possibleExpOp -> EQUALTO .)
    INPUT           reduce using rule 82 (possibleExpOp -> EQUALTO .)


state 78

    (81) possibleExpOp -> DIFFERENT .

    (               reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    ID              reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    INT             reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    FLOAT           reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    TRUE            reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    FALSE           reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    STRING          reduce using rule 81 (possibleExpOp -> DIFFERENT .)
    INPUT           reduce using rule 81 (possibleExpOp -> DIFFERENT .)


state 79

    (79) possibleExpOp -> LESSEQUAL .

    (               reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    ID              reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    INT             reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    FLOAT           reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    TRUE            reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    FALSE           reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    STRING          reduce using rule 79 (possibleExpOp -> LESSEQUAL .)
    INPUT           reduce using rule 79 (possibleExpOp -> LESSEQUAL .)


state 80

    (94) factor -> ( expression . )

    )               shift and go to state 96


state 81

    (9) vars -> type ID = expression moreVar .

    ;               reduce using rule 9 (vars -> type ID = expression moreVar .)


state 82

    (10) moreVar -> , . ID = expression moreVar

    ID              shift and go to state 97


state 83

    (16) arrays -> type ID [ constant ] . = { expression moreExp } moreArray

    =               shift and go to state 98


state 84

    (21) function -> FUNCTION funcType ID ( par . ) { block RETURN returnType ; }

    )               shift and go to state 99


state 85

    (29) main -> MAIN ( par ) . { block }

    {               shift and go to state 100


state 86

    (30) par -> type ID . morePar
    (32) morePar -> . , type ID morePar
    (33) morePar -> .

    ,               shift and go to state 102
    )               reduce using rule 33 (morePar -> .)

    morePar                        shift and go to state 101

state 87

    (89) possibleFactors -> possibleFactorOp factor . possibleFactors
    (89) possibleFactors -> . possibleFactorOp factor possibleFactors
    (90) possibleFactors -> .
    (91) possibleFactorOp -> . *
    (92) possibleFactorOp -> . /
    (93) possibleFactorOp -> . %

    +               reduce using rule 90 (possibleFactors -> .)
    -               reduce using rule 90 (possibleFactors -> .)
    LESS            reduce using rule 90 (possibleFactors -> .)
    GREATER         reduce using rule 90 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 90 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 90 (possibleFactors -> .)
    DIFFERENT       reduce using rule 90 (possibleFactors -> .)
    EQUALTO         reduce using rule 90 (possibleFactors -> .)
    AND             reduce using rule 90 (possibleFactors -> .)
    OR              reduce using rule 90 (possibleFactors -> .)
    ,               reduce using rule 90 (possibleFactors -> .)
    ;               reduce using rule 90 (possibleFactors -> .)
    )               reduce using rule 90 (possibleFactors -> .)
    ]               reduce using rule 90 (possibleFactors -> .)
    }               reduce using rule 90 (possibleFactors -> .)
    *               shift and go to state 56
    /               shift and go to state 58
    %               shift and go to state 55

    possibleFactors                shift and go to state 103
    possibleFactorOp               shift and go to state 59

state 88

    (70) possibleHigherExp -> possibleHigherExpOp higherExp .

    ,               reduce using rule 70 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ;               reduce using rule 70 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    )               reduce using rule 70 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ]               reduce using rule 70 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    }               reduce using rule 70 (possibleHigherExp -> possibleHigherExpOp higherExp .)


state 89

    (108) inputPar -> STRING .

    )               reduce using rule 108 (inputPar -> STRING .)


state 90

    (107) input -> INPUT ( inputPar . )

    )               shift and go to state 104


state 91

    (100) possibleIdCall -> ( parIn . )

    )               shift and go to state 105


state 92

    (35) parIn -> expression . moreParIn
    (37) moreParIn -> . , expression moreParIn
    (38) moreParIn -> .

    ,               shift and go to state 107
    )               reduce using rule 38 (moreParIn -> .)

    moreParIn                      shift and go to state 106

state 93

    (99) possibleIdCall -> [ expression . ]

    ]               shift and go to state 108


state 94

    (84) possibleTerms -> possibleTermOp term . possibleTerms
    (84) possibleTerms -> . possibleTermOp term possibleTerms
    (85) possibleTerms -> .
    (86) possibleTermOp -> . +
    (87) possibleTermOp -> . -

    LESS            reduce using rule 85 (possibleTerms -> .)
    GREATER         reduce using rule 85 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 85 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 85 (possibleTerms -> .)
    DIFFERENT       reduce using rule 85 (possibleTerms -> .)
    EQUALTO         reduce using rule 85 (possibleTerms -> .)
    AND             reduce using rule 85 (possibleTerms -> .)
    OR              reduce using rule 85 (possibleTerms -> .)
    ,               reduce using rule 85 (possibleTerms -> .)
    ;               reduce using rule 85 (possibleTerms -> .)
    )               reduce using rule 85 (possibleTerms -> .)
    ]               reduce using rule 85 (possibleTerms -> .)
    }               reduce using rule 85 (possibleTerms -> .)
    +               shift and go to state 71
    -               shift and go to state 70

    possibleTermOp                 shift and go to state 68
    possibleTerms                  shift and go to state 109

state 95

    (75) possibleExp -> possibleExpOp exp .

    AND             reduce using rule 75 (possibleExp -> possibleExpOp exp .)
    OR              reduce using rule 75 (possibleExp -> possibleExpOp exp .)
    ,               reduce using rule 75 (possibleExp -> possibleExpOp exp .)
    ;               reduce using rule 75 (possibleExp -> possibleExpOp exp .)
    )               reduce using rule 75 (possibleExp -> possibleExpOp exp .)
    ]               reduce using rule 75 (possibleExp -> possibleExpOp exp .)
    }               reduce using rule 75 (possibleExp -> possibleExpOp exp .)


state 96

    (94) factor -> ( expression ) .

    *               reduce using rule 94 (factor -> ( expression ) .)
    /               reduce using rule 94 (factor -> ( expression ) .)
    %               reduce using rule 94 (factor -> ( expression ) .)
    +               reduce using rule 94 (factor -> ( expression ) .)
    -               reduce using rule 94 (factor -> ( expression ) .)
    AND             reduce using rule 94 (factor -> ( expression ) .)
    OR              reduce using rule 94 (factor -> ( expression ) .)
    ,               reduce using rule 94 (factor -> ( expression ) .)
    ;               reduce using rule 94 (factor -> ( expression ) .)
    )               reduce using rule 94 (factor -> ( expression ) .)
    ]               reduce using rule 94 (factor -> ( expression ) .)
    }               reduce using rule 94 (factor -> ( expression ) .)
    LESS            reduce using rule 94 (factor -> ( expression ) .)
    GREATER         reduce using rule 94 (factor -> ( expression ) .)
    LESSEQUAL       reduce using rule 94 (factor -> ( expression ) .)
    GREATEREQUAL    reduce using rule 94 (factor -> ( expression ) .)
    DIFFERENT       reduce using rule 94 (factor -> ( expression ) .)
    EQUALTO         reduce using rule 94 (factor -> ( expression ) .)


state 97

    (10) moreVar -> , ID . = expression moreVar

    =               shift and go to state 110


state 98

    (16) arrays -> type ID [ constant ] = . { expression moreExp } moreArray

    {               shift and go to state 111


state 99

    (21) function -> FUNCTION funcType ID ( par ) . { block RETURN returnType ; }

    {               shift and go to state 112


state 100

    (29) main -> MAIN ( par ) { . block }
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 126
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 101

    (30) par -> type ID morePar .

    )               reduce using rule 30 (par -> type ID morePar .)


state 102

    (32) morePar -> , . type ID morePar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    type                           shift and go to state 130

state 103

    (89) possibleFactors -> possibleFactorOp factor possibleFactors .

    +               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    -               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESS            reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATER         reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESSEQUAL       reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATEREQUAL    reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    DIFFERENT       reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    EQUALTO         reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    AND             reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    OR              reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ,               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ;               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    )               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ]               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    }               reduce using rule 89 (possibleFactors -> possibleFactorOp factor possibleFactors .)


state 104

    (107) input -> INPUT ( inputPar ) .

    ARRAY           reduce using rule 107 (input -> INPUT ( inputPar ) .)
    ID              reduce using rule 107 (input -> INPUT ( inputPar ) .)
    IF              reduce using rule 107 (input -> INPUT ( inputPar ) .)
    CONSOLE         reduce using rule 107 (input -> INPUT ( inputPar ) .)
    INPUT           reduce using rule 107 (input -> INPUT ( inputPar ) .)
    FOR             reduce using rule 107 (input -> INPUT ( inputPar ) .)
    WHILE           reduce using rule 107 (input -> INPUT ( inputPar ) .)
    DO              reduce using rule 107 (input -> INPUT ( inputPar ) .)
    INTTYPE         reduce using rule 107 (input -> INPUT ( inputPar ) .)
    FLOATTYPE       reduce using rule 107 (input -> INPUT ( inputPar ) .)
    STRINGTYPE      reduce using rule 107 (input -> INPUT ( inputPar ) .)
    BOOLTYPE        reduce using rule 107 (input -> INPUT ( inputPar ) .)
    }               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    *               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    /               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    %               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    +               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    -               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    ]               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    LESS            reduce using rule 107 (input -> INPUT ( inputPar ) .)
    GREATER         reduce using rule 107 (input -> INPUT ( inputPar ) .)
    LESSEQUAL       reduce using rule 107 (input -> INPUT ( inputPar ) .)
    GREATEREQUAL    reduce using rule 107 (input -> INPUT ( inputPar ) .)
    DIFFERENT       reduce using rule 107 (input -> INPUT ( inputPar ) .)
    EQUALTO         reduce using rule 107 (input -> INPUT ( inputPar ) .)
    AND             reduce using rule 107 (input -> INPUT ( inputPar ) .)
    OR              reduce using rule 107 (input -> INPUT ( inputPar ) .)
    )               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    RETURN          reduce using rule 107 (input -> INPUT ( inputPar ) .)
    ,               reduce using rule 107 (input -> INPUT ( inputPar ) .)
    ;               reduce using rule 107 (input -> INPUT ( inputPar ) .)


state 105

    (100) possibleIdCall -> ( parIn ) .

    *               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    /               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    %               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    +               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    -               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    LESS            reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    GREATER         reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    LESSEQUAL       reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    GREATEREQUAL    reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    DIFFERENT       reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    EQUALTO         reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    AND             reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    OR              reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    ,               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    ;               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    )               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    ]               reduce using rule 100 (possibleIdCall -> ( parIn ) .)
    }               reduce using rule 100 (possibleIdCall -> ( parIn ) .)


state 106

    (35) parIn -> expression moreParIn .

    )               reduce using rule 35 (parIn -> expression moreParIn .)


state 107

    (37) moreParIn -> , . expression moreParIn
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 131

state 108

    (99) possibleIdCall -> [ expression ] .

    *               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    /               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    %               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    +               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    -               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    LESS            reduce using rule 99 (possibleIdCall -> [ expression ] .)
    GREATER         reduce using rule 99 (possibleIdCall -> [ expression ] .)
    LESSEQUAL       reduce using rule 99 (possibleIdCall -> [ expression ] .)
    GREATEREQUAL    reduce using rule 99 (possibleIdCall -> [ expression ] .)
    DIFFERENT       reduce using rule 99 (possibleIdCall -> [ expression ] .)
    EQUALTO         reduce using rule 99 (possibleIdCall -> [ expression ] .)
    AND             reduce using rule 99 (possibleIdCall -> [ expression ] .)
    OR              reduce using rule 99 (possibleIdCall -> [ expression ] .)
    ,               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    ;               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    )               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    ]               reduce using rule 99 (possibleIdCall -> [ expression ] .)
    }               reduce using rule 99 (possibleIdCall -> [ expression ] .)


state 109

    (84) possibleTerms -> possibleTermOp term possibleTerms .

    LESS            reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATER         reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    LESSEQUAL       reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATEREQUAL    reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    DIFFERENT       reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    EQUALTO         reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    AND             reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    OR              reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    ,               reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    ;               reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    )               reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    ]               reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)
    }               reduce using rule 84 (possibleTerms -> possibleTermOp term possibleTerms .)


state 110

    (10) moreVar -> , ID = . expression moreVar
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    input                          shift and go to state 40
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    expression                     shift and go to state 132

state 111

    (16) arrays -> type ID [ constant ] = { . expression moreExp } moreArray
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    input                          shift and go to state 40
    expression                     shift and go to state 133
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36

state 112

    (21) function -> FUNCTION funcType ID ( par ) { . block RETURN returnType ; }
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 134
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 113

    (68) doWhile -> DO . { loopBlock } WHILE ( expression ) ;

    {               shift and go to state 135


state 114

    (41) block -> conditional . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    loop                           shift and go to state 129
    output                         shift and go to state 127
    assign                         shift and go to state 128
    block                          shift and go to state 136

state 115

    (65) loop -> doWhile .

    ARRAY           reduce using rule 65 (loop -> doWhile .)
    ID              reduce using rule 65 (loop -> doWhile .)
    IF              reduce using rule 65 (loop -> doWhile .)
    CONSOLE         reduce using rule 65 (loop -> doWhile .)
    INPUT           reduce using rule 65 (loop -> doWhile .)
    FOR             reduce using rule 65 (loop -> doWhile .)
    WHILE           reduce using rule 65 (loop -> doWhile .)
    DO              reduce using rule 65 (loop -> doWhile .)
    INTTYPE         reduce using rule 65 (loop -> doWhile .)
    FLOATTYPE       reduce using rule 65 (loop -> doWhile .)
    STRINGTYPE      reduce using rule 65 (loop -> doWhile .)
    BOOLTYPE        reduce using rule 65 (loop -> doWhile .)
    RETURN          reduce using rule 65 (loop -> doWhile .)
    }               reduce using rule 65 (loop -> doWhile .)


state 116

    (67) while -> WHILE . ( expression ) { loopBlock }

    (               shift and go to state 137


state 117

    (63) loop -> for .

    ARRAY           reduce using rule 63 (loop -> for .)
    ID              reduce using rule 63 (loop -> for .)
    IF              reduce using rule 63 (loop -> for .)
    CONSOLE         reduce using rule 63 (loop -> for .)
    INPUT           reduce using rule 63 (loop -> for .)
    FOR             reduce using rule 63 (loop -> for .)
    WHILE           reduce using rule 63 (loop -> for .)
    DO              reduce using rule 63 (loop -> for .)
    INTTYPE         reduce using rule 63 (loop -> for .)
    FLOATTYPE       reduce using rule 63 (loop -> for .)
    STRINGTYPE      reduce using rule 63 (loop -> for .)
    BOOLTYPE        reduce using rule 63 (loop -> for .)
    RETURN          reduce using rule 63 (loop -> for .)
    }               reduce using rule 63 (loop -> for .)


state 118

    (45) block -> input . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 138
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 119

    (39) block -> varDeclar . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 139
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 120

    (62) output -> CONSOLE . ( expression ) ;

    (               shift and go to state 140


state 121

    (66) for -> FOR . ( expression ; assign ) { loopBlock }

    (               shift and go to state 141


state 122

    (54) assign -> ID . possibleArray = expression
    (34) funcCall -> ID . ( parIn )
    (55) possibleArray -> . [ exp ]
    (56) possibleArray -> .

    (               shift and go to state 142
    [               shift and go to state 144
    =               reduce using rule 56 (possibleArray -> .)

    possibleArray                  shift and go to state 143

state 123

    (57) conditional -> IF . ( expression ) { block } possibleElif possibleElse

    (               shift and go to state 145


state 124

    (43) block -> funcCall . ; block

    ;               shift and go to state 146


state 125

    (64) loop -> while .

    ARRAY           reduce using rule 64 (loop -> while .)
    ID              reduce using rule 64 (loop -> while .)
    IF              reduce using rule 64 (loop -> while .)
    CONSOLE         reduce using rule 64 (loop -> while .)
    INPUT           reduce using rule 64 (loop -> while .)
    FOR             reduce using rule 64 (loop -> while .)
    WHILE           reduce using rule 64 (loop -> while .)
    DO              reduce using rule 64 (loop -> while .)
    INTTYPE         reduce using rule 64 (loop -> while .)
    FLOATTYPE       reduce using rule 64 (loop -> while .)
    STRINGTYPE      reduce using rule 64 (loop -> while .)
    BOOLTYPE        reduce using rule 64 (loop -> while .)
    RETURN          reduce using rule 64 (loop -> while .)
    }               reduce using rule 64 (loop -> while .)


state 126

    (29) main -> MAIN ( par ) { block . }

    }               shift and go to state 147


state 127

    (44) block -> output . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 148
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 128

    (40) block -> assign . ; block

    ;               shift and go to state 149


state 129

    (42) block -> loop . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 150
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 130

    (32) morePar -> , type . ID morePar

    ID              shift and go to state 151


state 131

    (37) moreParIn -> , expression . moreParIn
    (37) moreParIn -> . , expression moreParIn
    (38) moreParIn -> .

    ,               shift and go to state 107
    )               reduce using rule 38 (moreParIn -> .)

    moreParIn                      shift and go to state 152

state 132

    (10) moreVar -> , ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 82
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 153

state 133

    (16) arrays -> type ID [ constant ] = { expression . moreExp } moreArray
    (17) moreExp -> . , expression moreExp
    (18) moreExp -> .

    ,               shift and go to state 154
    }               reduce using rule 18 (moreExp -> .)

    moreExp                        shift and go to state 155

state 134

    (21) function -> FUNCTION funcType ID ( par ) { block . RETURN returnType ; }

    RETURN          shift and go to state 156


state 135

    (68) doWhile -> DO { . loopBlock } WHILE ( expression ) ;
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 158
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 136

    (41) block -> conditional block .

    }               reduce using rule 41 (block -> conditional block .)
    RETURN          reduce using rule 41 (block -> conditional block .)


state 137

    (67) while -> WHILE ( . expression ) { loopBlock }
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 164

state 138

    (45) block -> input block .

    }               reduce using rule 45 (block -> input block .)
    RETURN          reduce using rule 45 (block -> input block .)


state 139

    (39) block -> varDeclar block .

    }               reduce using rule 39 (block -> varDeclar block .)
    RETURN          reduce using rule 39 (block -> varDeclar block .)


state 140

    (62) output -> CONSOLE ( . expression ) ;
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 165

state 141

    (66) for -> FOR ( . expression ; assign ) { loopBlock }
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 166

state 142

    (34) funcCall -> ID ( . parIn )
    (35) parIn -> . expression moreParIn
    (36) parIn -> .
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    )               reduce using rule 36 (parIn -> .)
    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    data                           shift and go to state 38
    higherExp                      shift and go to state 39
    parIn                          shift and go to state 167
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 92

state 143

    (54) assign -> ID possibleArray . = expression

    =               shift and go to state 168


state 144

    (55) possibleArray -> [ . exp ]
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    data                           shift and go to state 38
    exp                            shift and go to state 169
    factor                         shift and go to state 36
    input                          shift and go to state 40

state 145

    (57) conditional -> IF ( . expression ) { block } possibleElif possibleElse
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    input                          shift and go to state 40
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    expression                     shift and go to state 170

state 146

    (43) block -> funcCall ; . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    loop                           shift and go to state 129
    output                         shift and go to state 127
    assign                         shift and go to state 128
    block                          shift and go to state 171

state 147

    (29) main -> MAIN ( par ) { block } .

    $end            reduce using rule 29 (main -> MAIN ( par ) { block } .)


state 148

    (44) block -> output block .

    }               reduce using rule 44 (block -> output block .)
    RETURN          reduce using rule 44 (block -> output block .)


state 149

    (40) block -> assign ; . block
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    RETURN          reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 172
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 150

    (42) block -> loop block .

    }               reduce using rule 42 (block -> loop block .)
    RETURN          reduce using rule 42 (block -> loop block .)


state 151

    (32) morePar -> , type ID . morePar
    (32) morePar -> . , type ID morePar
    (33) morePar -> .

    ,               shift and go to state 102
    )               reduce using rule 33 (morePar -> .)

    morePar                        shift and go to state 173

state 152

    (37) moreParIn -> , expression moreParIn .

    )               reduce using rule 37 (moreParIn -> , expression moreParIn .)


state 153

    (10) moreVar -> , ID = expression moreVar .

    ;               reduce using rule 10 (moreVar -> , ID = expression moreVar .)


state 154

    (17) moreExp -> , . expression moreExp
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 174

state 155

    (16) arrays -> type ID [ constant ] = { expression moreExp . } moreArray

    }               shift and go to state 175


state 156

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN . returnType ; }
    (27) returnType -> . expression
    (28) returnType -> . VOID
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    VOID            shift and go to state 176
    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    constant                       shift and go to state 35
    term                           shift and go to state 44
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    returnType                     shift and go to state 177
    input                          shift and go to state 40
    expression                     shift and go to state 178

state 157

    (48) loopBlock -> conditional . loopBlock
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 179
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 158

    (68) doWhile -> DO { loopBlock . } WHILE ( expression ) ;

    }               shift and go to state 180


state 159

    (52) loopBlock -> input . loopBlock
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 181
    doWhile                        shift and go to state 115
    output                         shift and go to state 162
    input                          shift and go to state 159
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 160

    (50) loopBlock -> funcCall . ; loopBlock

    ;               shift and go to state 182


state 161

    (49) loopBlock -> loop . loopBlock
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 183
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 162

    (51) loopBlock -> output . loopBlock
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 184
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 163

    (47) loopBlock -> assign . ; loopBlock

    ;               shift and go to state 185


state 164

    (67) while -> WHILE ( expression . ) { loopBlock }

    )               shift and go to state 186


state 165

    (62) output -> CONSOLE ( expression . ) ;

    )               shift and go to state 187


state 166

    (66) for -> FOR ( expression . ; assign ) { loopBlock }

    ;               shift and go to state 188


state 167

    (34) funcCall -> ID ( parIn . )

    )               shift and go to state 189


state 168

    (54) assign -> ID possibleArray = . expression
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    input                          shift and go to state 40
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    expression                     shift and go to state 190

state 169

    (55) possibleArray -> [ exp . ]

    ]               shift and go to state 191


state 170

    (57) conditional -> IF ( expression . ) { block } possibleElif possibleElse

    )               shift and go to state 192


state 171

    (43) block -> funcCall ; block .

    }               reduce using rule 43 (block -> funcCall ; block .)
    RETURN          reduce using rule 43 (block -> funcCall ; block .)


state 172

    (40) block -> assign ; block .

    }               reduce using rule 40 (block -> assign ; block .)
    RETURN          reduce using rule 40 (block -> assign ; block .)


state 173

    (32) morePar -> , type ID morePar .

    )               reduce using rule 32 (morePar -> , type ID morePar .)


state 174

    (17) moreExp -> , expression . moreExp
    (17) moreExp -> . , expression moreExp
    (18) moreExp -> .

    ,               shift and go to state 154
    }               reduce using rule 18 (moreExp -> .)

    moreExp                        shift and go to state 193

state 175

    (16) arrays -> type ID [ constant ] = { expression moreExp } . moreArray
    (19) moreArray -> . , ID [ constant ] = { expression moreExp } moreArray
    (20) moreArray -> .

    ,               shift and go to state 195
    ;               reduce using rule 20 (moreArray -> .)

    moreArray                      shift and go to state 194

state 176

    (28) returnType -> VOID .

    ;               reduce using rule 28 (returnType -> VOID .)


state 177

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN returnType . ; }

    ;               shift and go to state 196


state 178

    (27) returnType -> expression .

    ;               reduce using rule 27 (returnType -> expression .)


state 179

    (48) loopBlock -> conditional loopBlock .

    }               reduce using rule 48 (loopBlock -> conditional loopBlock .)


state 180

    (68) doWhile -> DO { loopBlock } . WHILE ( expression ) ;

    WHILE           shift and go to state 197


state 181

    (52) loopBlock -> input loopBlock .

    }               reduce using rule 52 (loopBlock -> input loopBlock .)


state 182

    (50) loopBlock -> funcCall ; . loopBlock
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 198
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 183

    (49) loopBlock -> loop loopBlock .

    }               reduce using rule 49 (loopBlock -> loop loopBlock .)


state 184

    (51) loopBlock -> output loopBlock .

    }               reduce using rule 51 (loopBlock -> output loopBlock .)


state 185

    (47) loopBlock -> assign ; . loopBlock
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 199
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 186

    (67) while -> WHILE ( expression ) . { loopBlock }

    {               shift and go to state 200


state 187

    (62) output -> CONSOLE ( expression ) . ;

    ;               shift and go to state 201


state 188

    (66) for -> FOR ( expression ; . assign ) { loopBlock }
    (54) assign -> . ID possibleArray = expression

    ID              shift and go to state 202

    assign                         shift and go to state 203

state 189

    (34) funcCall -> ID ( parIn ) .

    ;               reduce using rule 34 (funcCall -> ID ( parIn ) .)


state 190

    (54) assign -> ID possibleArray = expression .

    )               reduce using rule 54 (assign -> ID possibleArray = expression .)
    ;               reduce using rule 54 (assign -> ID possibleArray = expression .)


state 191

    (55) possibleArray -> [ exp ] .

    =               reduce using rule 55 (possibleArray -> [ exp ] .)


state 192

    (57) conditional -> IF ( expression ) . { block } possibleElif possibleElse

    {               shift and go to state 204


state 193

    (17) moreExp -> , expression moreExp .

    }               reduce using rule 17 (moreExp -> , expression moreExp .)


state 194

    (16) arrays -> type ID [ constant ] = { expression moreExp } moreArray .

    ;               reduce using rule 16 (arrays -> type ID [ constant ] = { expression moreExp } moreArray .)


state 195

    (19) moreArray -> , . ID [ constant ] = { expression moreExp } moreArray

    ID              shift and go to state 205


state 196

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; . }

    }               shift and go to state 206


state 197

    (68) doWhile -> DO { loopBlock } WHILE . ( expression ) ;

    (               shift and go to state 207


state 198

    (50) loopBlock -> funcCall ; loopBlock .

    }               reduce using rule 50 (loopBlock -> funcCall ; loopBlock .)


state 199

    (47) loopBlock -> assign ; loopBlock .

    }               reduce using rule 47 (loopBlock -> assign ; loopBlock .)


state 200

    (67) while -> WHILE ( expression ) { . loopBlock }
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 208
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 201

    (62) output -> CONSOLE ( expression ) ; .

    ID              reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    IF              reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    CONSOLE         reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    INPUT           reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    FOR             reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    WHILE           reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    DO              reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    }               reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    ARRAY           reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    INTTYPE         reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    FLOATTYPE       reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    STRINGTYPE      reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    BOOLTYPE        reduce using rule 62 (output -> CONSOLE ( expression ) ; .)
    RETURN          reduce using rule 62 (output -> CONSOLE ( expression ) ; .)


state 202

    (54) assign -> ID . possibleArray = expression
    (55) possibleArray -> . [ exp ]
    (56) possibleArray -> .

    [               shift and go to state 144
    =               reduce using rule 56 (possibleArray -> .)

    possibleArray                  shift and go to state 143

state 203

    (66) for -> FOR ( expression ; assign . ) { loopBlock }

    )               shift and go to state 209


state 204

    (57) conditional -> IF ( expression ) { . block } possibleElif possibleElse
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    vars                           shift and go to state 4
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 210
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 205

    (19) moreArray -> , ID . [ constant ] = { expression moreExp } moreArray

    [               shift and go to state 211


state 206

    (21) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .

    FUNCTION        reduce using rule 21 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)
    MAIN            reduce using rule 21 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)


state 207

    (68) doWhile -> DO { loopBlock } WHILE ( . expression ) ;
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 212

state 208

    (67) while -> WHILE ( expression ) { loopBlock . }

    }               shift and go to state 213


state 209

    (66) for -> FOR ( expression ; assign ) . { loopBlock }

    {               shift and go to state 214


state 210

    (57) conditional -> IF ( expression ) { block . } possibleElif possibleElse

    }               shift and go to state 215


state 211

    (19) moreArray -> , ID [ . constant ] = { expression moreExp } moreArray
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING

    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41

    constant                       shift and go to state 216

state 212

    (68) doWhile -> DO { loopBlock } WHILE ( expression . ) ;

    )               shift and go to state 217


state 213

    (67) while -> WHILE ( expression ) { loopBlock } .

    ID              reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    IF              reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    CONSOLE         reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    INPUT           reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    FOR             reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    WHILE           reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    DO              reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    }               reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    ARRAY           reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    INTTYPE         reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    FLOATTYPE       reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    STRINGTYPE      reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    BOOLTYPE        reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)
    RETURN          reduce using rule 67 (while -> WHILE ( expression ) { loopBlock } .)


state 214

    (66) for -> FOR ( expression ; assign ) { . loopBlock }
    (47) loopBlock -> . assign ; loopBlock
    (48) loopBlock -> . conditional loopBlock
    (49) loopBlock -> . loop loopBlock
    (50) loopBlock -> . funcCall ; loopBlock
    (51) loopBlock -> . output loopBlock
    (52) loopBlock -> . input loopBlock
    (53) loopBlock -> .
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 53 (loopBlock -> .)
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113

    funcCall                       shift and go to state 160
    conditional                    shift and go to state 157
    while                          shift and go to state 125
    for                            shift and go to state 117
    loopBlock                      shift and go to state 218
    doWhile                        shift and go to state 115
    input                          shift and go to state 159
    output                         shift and go to state 162
    assign                         shift and go to state 163
    loop                           shift and go to state 161

state 215

    (57) conditional -> IF ( expression ) { block } . possibleElif possibleElse
    (58) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (59) possibleElif -> .

    ELIF            shift and go to state 219
    ELSE            reduce using rule 59 (possibleElif -> .)
    ARRAY           reduce using rule 59 (possibleElif -> .)
    ID              reduce using rule 59 (possibleElif -> .)
    IF              reduce using rule 59 (possibleElif -> .)
    CONSOLE         reduce using rule 59 (possibleElif -> .)
    INPUT           reduce using rule 59 (possibleElif -> .)
    FOR             reduce using rule 59 (possibleElif -> .)
    WHILE           reduce using rule 59 (possibleElif -> .)
    DO              reduce using rule 59 (possibleElif -> .)
    INTTYPE         reduce using rule 59 (possibleElif -> .)
    FLOATTYPE       reduce using rule 59 (possibleElif -> .)
    STRINGTYPE      reduce using rule 59 (possibleElif -> .)
    BOOLTYPE        reduce using rule 59 (possibleElif -> .)
    }               reduce using rule 59 (possibleElif -> .)
    RETURN          reduce using rule 59 (possibleElif -> .)

    possibleElif                   shift and go to state 220

state 216

    (19) moreArray -> , ID [ constant . ] = { expression moreExp } moreArray

    ]               shift and go to state 221


state 217

    (68) doWhile -> DO { loopBlock } WHILE ( expression ) . ;

    ;               shift and go to state 222


state 218

    (66) for -> FOR ( expression ; assign ) { loopBlock . }

    }               shift and go to state 223


state 219

    (58) possibleElif -> ELIF . ( expression ) { block } possibleElif

    (               shift and go to state 224


state 220

    (57) conditional -> IF ( expression ) { block } possibleElif . possibleElse
    (60) possibleElse -> . ELSE { block }
    (61) possibleElse -> .

    ELSE            shift and go to state 226
    ARRAY           reduce using rule 61 (possibleElse -> .)
    ID              reduce using rule 61 (possibleElse -> .)
    IF              reduce using rule 61 (possibleElse -> .)
    CONSOLE         reduce using rule 61 (possibleElse -> .)
    INPUT           reduce using rule 61 (possibleElse -> .)
    FOR             reduce using rule 61 (possibleElse -> .)
    WHILE           reduce using rule 61 (possibleElse -> .)
    DO              reduce using rule 61 (possibleElse -> .)
    INTTYPE         reduce using rule 61 (possibleElse -> .)
    FLOATTYPE       reduce using rule 61 (possibleElse -> .)
    STRINGTYPE      reduce using rule 61 (possibleElse -> .)
    BOOLTYPE        reduce using rule 61 (possibleElse -> .)
    }               reduce using rule 61 (possibleElse -> .)
    RETURN          reduce using rule 61 (possibleElse -> .)

    possibleElse                   shift and go to state 225

state 221

    (19) moreArray -> , ID [ constant ] . = { expression moreExp } moreArray

    =               shift and go to state 227


state 222

    (68) doWhile -> DO { loopBlock } WHILE ( expression ) ; .

    ARRAY           reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    ID              reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    IF              reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    CONSOLE         reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INPUT           reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FOR             reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    WHILE           reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    DO              reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INTTYPE         reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FLOATTYPE       reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    STRINGTYPE      reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    BOOLTYPE        reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    }               reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    RETURN          reduce using rule 68 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)


state 223

    (66) for -> FOR ( expression ; assign ) { loopBlock } .

    ID              reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    IF              reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    CONSOLE         reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INPUT           reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FOR             reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    WHILE           reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    DO              reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    }               reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    ARRAY           reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INTTYPE         reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FLOATTYPE       reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    STRINGTYPE      reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    BOOLTYPE        reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)
    RETURN          reduce using rule 66 (for -> FOR ( expression ; assign ) { loopBlock } .)


state 224

    (58) possibleElif -> ELIF ( . expression ) { block } possibleElif
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    input                          shift and go to state 40
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    expression                     shift and go to state 228

state 225

    (57) conditional -> IF ( expression ) { block } possibleElif possibleElse .

    ARRAY           reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    ID              reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    IF              reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    CONSOLE         reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INPUT           reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FOR             reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    WHILE           reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    DO              reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INTTYPE         reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FLOATTYPE       reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    STRINGTYPE      reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    BOOLTYPE        reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    }               reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    RETURN          reduce using rule 57 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)


state 226

    (60) possibleElse -> ELSE . { block }

    {               shift and go to state 229


state 227

    (19) moreArray -> , ID [ constant ] = . { expression moreExp } moreArray

    {               shift and go to state 230


state 228

    (58) possibleElif -> ELIF ( expression . ) { block } possibleElif

    )               shift and go to state 231


state 229

    (60) possibleElse -> ELSE { . block }
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 232
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 230

    (19) moreArray -> , ID [ constant ] = { . expression moreExp } moreArray
    (69) expression -> . higherExp possibleHigherExp
    (74) higherExp -> . exp possibleExp
    (83) exp -> . term possibleTerms
    (88) term -> . factor possibleFactors
    (94) factor -> . ( expression )
    (95) factor -> . data
    (96) data -> . ID possibleIdCall
    (97) data -> . constant
    (98) data -> . input
    (102) constant -> . INT
    (103) constant -> . FLOAT
    (104) constant -> . TRUE
    (105) constant -> . FALSE
    (106) constant -> . STRING
    (107) input -> . INPUT ( inputPar )

    (               shift and go to state 49
    ID              shift and go to state 43
    INT             shift and go to state 46
    FLOAT           shift and go to state 47
    TRUE            shift and go to state 37
    FALSE           shift and go to state 45
    STRING          shift and go to state 41
    INPUT           shift and go to state 42

    term                           shift and go to state 44
    constant                       shift and go to state 35
    higherExp                      shift and go to state 39
    data                           shift and go to state 38
    exp                            shift and go to state 48
    factor                         shift and go to state 36
    input                          shift and go to state 40
    expression                     shift and go to state 233

state 231

    (58) possibleElif -> ELIF ( expression ) . { block } possibleElif

    {               shift and go to state 234


state 232

    (60) possibleElse -> ELSE { block . }

    }               shift and go to state 235


state 233

    (19) moreArray -> , ID [ constant ] = { expression . moreExp } moreArray
    (17) moreExp -> . , expression moreExp
    (18) moreExp -> .

    ,               shift and go to state 154
    }               reduce using rule 18 (moreExp -> .)

    moreExp                        shift and go to state 236

state 234

    (58) possibleElif -> ELIF ( expression ) { . block } possibleElif
    (39) block -> . varDeclar block
    (40) block -> . assign ; block
    (41) block -> . conditional block
    (42) block -> . loop block
    (43) block -> . funcCall ; block
    (44) block -> . output block
    (45) block -> . input block
    (46) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (54) assign -> . ID possibleArray = expression
    (57) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (63) loop -> . for
    (64) loop -> . while
    (65) loop -> . doWhile
    (34) funcCall -> . ID ( parIn )
    (62) output -> . CONSOLE ( expression ) ;
    (107) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (66) for -> . FOR ( expression ; assign ) { loopBlock }
    (67) while -> . WHILE ( expression ) { loopBlock }
    (68) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 46 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 122
    IF              shift and go to state 123
    CONSOLE         shift and go to state 120
    INPUT           shift and go to state 42
    FOR             shift and go to state 121
    WHILE           shift and go to state 116
    DO              shift and go to state 113
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 114
    doWhile                        shift and go to state 115
    for                            shift and go to state 117
    input                          shift and go to state 118
    varDeclar                      shift and go to state 119
    type                           shift and go to state 10
    funcCall                       shift and go to state 124
    while                          shift and go to state 125
    block                          shift and go to state 237
    output                         shift and go to state 127
    assign                         shift and go to state 128
    loop                           shift and go to state 129

state 235

    (60) possibleElse -> ELSE { block } .

    ARRAY           reduce using rule 60 (possibleElse -> ELSE { block } .)
    ID              reduce using rule 60 (possibleElse -> ELSE { block } .)
    IF              reduce using rule 60 (possibleElse -> ELSE { block } .)
    CONSOLE         reduce using rule 60 (possibleElse -> ELSE { block } .)
    INPUT           reduce using rule 60 (possibleElse -> ELSE { block } .)
    FOR             reduce using rule 60 (possibleElse -> ELSE { block } .)
    WHILE           reduce using rule 60 (possibleElse -> ELSE { block } .)
    DO              reduce using rule 60 (possibleElse -> ELSE { block } .)
    INTTYPE         reduce using rule 60 (possibleElse -> ELSE { block } .)
    FLOATTYPE       reduce using rule 60 (possibleElse -> ELSE { block } .)
    STRINGTYPE      reduce using rule 60 (possibleElse -> ELSE { block } .)
    BOOLTYPE        reduce using rule 60 (possibleElse -> ELSE { block } .)
    }               reduce using rule 60 (possibleElse -> ELSE { block } .)
    RETURN          reduce using rule 60 (possibleElse -> ELSE { block } .)


state 236

    (19) moreArray -> , ID [ constant ] = { expression moreExp . } moreArray

    }               shift and go to state 238


state 237

    (58) possibleElif -> ELIF ( expression ) { block . } possibleElif

    }               shift and go to state 239


state 238

    (19) moreArray -> , ID [ constant ] = { expression moreExp } . moreArray
    (19) moreArray -> . , ID [ constant ] = { expression moreExp } moreArray
    (20) moreArray -> .

    ,               shift and go to state 195
    ;               reduce using rule 20 (moreArray -> .)

    moreArray                      shift and go to state 240

state 239

    (58) possibleElif -> ELIF ( expression ) { block } . possibleElif
    (58) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (59) possibleElif -> .

    ELIF            shift and go to state 219
    ELSE            reduce using rule 59 (possibleElif -> .)
    ARRAY           reduce using rule 59 (possibleElif -> .)
    ID              reduce using rule 59 (possibleElif -> .)
    IF              reduce using rule 59 (possibleElif -> .)
    CONSOLE         reduce using rule 59 (possibleElif -> .)
    INPUT           reduce using rule 59 (possibleElif -> .)
    FOR             reduce using rule 59 (possibleElif -> .)
    WHILE           reduce using rule 59 (possibleElif -> .)
    DO              reduce using rule 59 (possibleElif -> .)
    INTTYPE         reduce using rule 59 (possibleElif -> .)
    FLOATTYPE       reduce using rule 59 (possibleElif -> .)
    STRINGTYPE      reduce using rule 59 (possibleElif -> .)
    BOOLTYPE        reduce using rule 59 (possibleElif -> .)
    }               reduce using rule 59 (possibleElif -> .)
    RETURN          reduce using rule 59 (possibleElif -> .)

    possibleElif                   shift and go to state 241

state 240

    (19) moreArray -> , ID [ constant ] = { expression moreExp } moreArray .

    ;               reduce using rule 19 (moreArray -> , ID [ constant ] = { expression moreExp } moreArray .)


state 241

    (58) possibleElif -> ELIF ( expression ) { block } possibleElif .

    ELSE            reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ARRAY           reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ID              reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    IF              reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    CONSOLE         reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INPUT           reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FOR             reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    WHILE           reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    DO              reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INTTYPE         reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FLOATTYPE       reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    STRINGTYPE      reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    BOOLTYPE        reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    }               reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    RETURN          reduce using rule 58 (possibleElif -> ELIF ( expression ) { block } possibleElif .)

