Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> initVarDeclar functionDeclar main
Rule 2     initVarDeclar -> varDeclar initVarDeclar
Rule 3     initVarDeclar -> <empty>
Rule 4     functionDeclar -> function functionDeclar
Rule 5     functionDeclar -> <empty>
Rule 6     varDeclar -> vars ;
Rule 7     varDeclar -> ARRAY arrays ;
Rule 8     vars -> type ID = expression moreVar
Rule 9     moreVar -> , ID = expression moreVar
Rule 10    moreVar -> <empty>
Rule 11    type -> INTTYPE
Rule 12    type -> FLOATTYPE
Rule 13    type -> STRINGTYPE
Rule 14    type -> BOOLTYPE
Rule 15    arrays -> type ID [ constant ] = { expression moreExp } moreArray
Rule 16    moreExp -> , expression moreExp
Rule 17    moreExp -> <empty>
Rule 18    moreArray -> , ID [ constant ] = { expression moreExp } moreArray
Rule 19    moreArray -> <empty>
Rule 20    function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; }
Rule 21    funcType -> type
Rule 22    funcType -> VOID
Rule 23    returnType -> expression
Rule 24    returnType -> VOID
Rule 25    main -> MAIN ( par ) { block }
Rule 26    par -> type ID morePar
Rule 27    par -> <empty>
Rule 28    morePar -> , type ID morePar
Rule 29    morePar -> <empty>
Rule 30    funcCall -> ID ( parIn )
Rule 31    parIn -> expression moreParIn
Rule 32    parIn -> <empty>
Rule 33    moreParIn -> , expression moreParIn
Rule 34    moreParIn -> <empty>
Rule 35    block -> varDeclar block
Rule 36    block -> assign block
Rule 37    block -> conditional block
Rule 38    block -> loop block
Rule 39    block -> funcCall ; block
Rule 40    block -> output block
Rule 41    block -> input block
Rule 42    block -> <empty>
Rule 43    loopBlock -> assign loopBlock
Rule 44    loopBlock -> conditional loopBlock
Rule 45    loopBlock -> loop loopBlock
Rule 46    loopBlock -> funcCall ; loopBlock
Rule 47    loopBlock -> output loopBlock
Rule 48    loopBlock -> input loopBlock
Rule 49    loopBlock -> <empty>
Rule 50    assign -> ID possibleArray = expression ;
Rule 51    possibleArray -> [ exp ]
Rule 52    possibleArray -> <empty>
Rule 53    conditional -> IF ( expression ) { block } possibleElif possibleElse
Rule 54    possibleElif -> ELIF ( expression ) { block } possibleElif
Rule 55    possibleElif -> <empty>
Rule 56    possibleElse -> ELSE { block }
Rule 57    possibleElse -> <empty>
Rule 58    output -> CONSOLE ( expression ) ;
Rule 59    loop -> for
Rule 60    loop -> while
Rule 61    loop -> doWhile
Rule 62    for -> FOR ( assign expression ) { loopBlock }
Rule 63    while -> WHILE ( expression ) { loopBlock }
Rule 64    doWhile -> DO { loopBlock } WHILE ( expression ) ;
Rule 65    expression -> higherExp possibleHigherExp
Rule 66    possibleHigherExp -> possibleHigherExpOp higherExp
Rule 67    possibleHigherExp -> <empty>
Rule 68    possibleHigherExpOp -> AND
Rule 69    possibleHigherExpOp -> OR
Rule 70    higherExp -> exp possibleExp
Rule 71    possibleExp -> possibleExpOp exp
Rule 72    possibleExp -> <empty>
Rule 73    possibleExpOp -> LESS
Rule 74    possibleExpOp -> GREATER
Rule 75    possibleExpOp -> LESSEQUAL
Rule 76    possibleExpOp -> GREATEREQUAL
Rule 77    possibleExpOp -> DIFFERENT
Rule 78    possibleExpOp -> EQUALTO
Rule 79    exp -> term possibleTerms
Rule 80    possibleTerms -> possibleTermOp term possibleTerms
Rule 81    possibleTerms -> <empty>
Rule 82    possibleTermOp -> +
Rule 83    possibleTermOp -> -
Rule 84    term -> factor possibleFactors
Rule 85    possibleFactors -> possibleFactorOp factor possibleFactors
Rule 86    possibleFactors -> <empty>
Rule 87    possibleFactorOp -> *
Rule 88    possibleFactorOp -> /
Rule 89    possibleFactorOp -> %
Rule 90    factor -> ( expression )
Rule 91    factor -> data
Rule 92    data -> ID possibleIdCall
Rule 93    data -> constant
Rule 94    data -> input
Rule 95    possibleIdCall -> [ expression ]
Rule 96    possibleIdCall -> ( parIn )
Rule 97    possibleIdCall -> <empty>
Rule 98    constant -> INT
Rule 99    constant -> FLOAT
Rule 100   constant -> bool
Rule 101   constant -> STRING
Rule 102   bool -> TRUE
Rule 103   bool -> FALSE
Rule 104   input -> INPUT ( inputPar )
Rule 105   inputPar -> STRING
Rule 106   inputPar -> <empty>

Terminals, with rules where they appear

%                    : 89
(                    : 20 25 30 53 54 58 62 63 64 90 96 104
)                    : 20 25 30 53 54 58 62 63 64 90 96 104
*                    : 87
+                    : 82
,                    : 9 16 18 28 33
-                    : 83
/                    : 88
;                    : 6 7 20 39 46 50 58 64
=                    : 8 9 15 18 50
AND                  : 68
ARRAY                : 7
BOOLTYPE             : 14
CONSOLE              : 58
DIFFERENT            : 77
DO                   : 64
ELIF                 : 54
ELSE                 : 56
EQUALTO              : 78
FALSE                : 103
FLOAT                : 99
FLOATTYPE            : 12
FOR                  : 62
FUNCTION             : 20
GREATER              : 74
GREATEREQUAL         : 76
ID                   : 8 9 15 18 20 26 28 30 50 92
IF                   : 53
INPUT                : 104
INT                  : 98
INTTYPE              : 11
LESS                 : 73
LESSEQUAL            : 75
MAIN                 : 25
OR                   : 69
RETURN               : 20
STRING               : 101 105
STRINGTYPE           : 13
TRUE                 : 102
VOID                 : 22 24
WHILE                : 63 64
[                    : 15 18 51 95
]                    : 15 18 51 95
error                : 
{                    : 15 18 20 25 53 54 56 62 63 64
}                    : 15 18 20 25 53 54 56 62 63 64

Nonterminals, with rules where they appear

arrays               : 7
assign               : 36 43 62
block                : 20 25 35 36 37 38 39 40 41 53 54 56
bool                 : 100
conditional          : 37 44
constant             : 15 18 93
data                 : 91
doWhile              : 61
exp                  : 51 70 71
expression           : 8 9 15 16 18 23 31 33 50 53 54 58 62 63 64 90 95
factor               : 84 85
for                  : 59
funcCall             : 39 46
funcType             : 20
function             : 4
functionDeclar       : 1 4
higherExp            : 65 66
initVarDeclar        : 1 2
input                : 41 48 94
inputPar             : 104
loop                 : 38 45
loopBlock            : 43 44 45 46 47 48 62 63 64
main                 : 1
moreArray            : 15 18
moreExp              : 15 16 18
morePar              : 26 28
moreParIn            : 31 33
moreVar              : 8 9
output               : 40 47
par                  : 20 25
parIn                : 30 96
possibleArray        : 50
possibleElif         : 53 54
possibleElse         : 53
possibleExp          : 70
possibleExpOp        : 71
possibleFactorOp     : 85
possibleFactors      : 84 85
possibleHigherExp    : 65
possibleHigherExpOp  : 66
possibleIdCall       : 92
possibleTermOp       : 80
possibleTerms        : 79 80
program              : 0
returnType           : 20
term                 : 79 80
type                 : 8 15 21 26 28
varDeclar            : 2 35
vars                 : 6
while                : 60

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . initVarDeclar functionDeclar main
    (2) initVarDeclar -> . varDeclar initVarDeclar
    (3) initVarDeclar -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (8) vars -> . type ID = expression moreVar
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    FUNCTION        reduce using rule 3 (initVarDeclar -> .)
    MAIN            reduce using rule 3 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    program                        shift and go to state 7
    initVarDeclar                  shift and go to state 8
    type                           shift and go to state 9
    varDeclar                      shift and go to state 10

state 1

    (14) type -> BOOLTYPE .

    ID              reduce using rule 14 (type -> BOOLTYPE .)


state 2

    (13) type -> STRINGTYPE .

    ID              reduce using rule 13 (type -> STRINGTYPE .)


state 3

    (11) type -> INTTYPE .

    ID              reduce using rule 11 (type -> INTTYPE .)


state 4

    (6) varDeclar -> vars . ;

    ;               shift and go to state 11


state 5

    (12) type -> FLOATTYPE .

    ID              reduce using rule 12 (type -> FLOATTYPE .)


state 6

    (7) varDeclar -> ARRAY . arrays ;
    (15) arrays -> . type ID [ constant ] = { expression moreExp } moreArray
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    arrays                         shift and go to state 12
    type                           shift and go to state 13

state 7

    (0) S' -> program .



state 8

    (1) program -> initVarDeclar . functionDeclar main
    (4) functionDeclar -> . function functionDeclar
    (5) functionDeclar -> .
    (20) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 5 (functionDeclar -> .)
    FUNCTION        shift and go to state 15

    function                       shift and go to state 14
    functionDeclar                 shift and go to state 16

state 9

    (8) vars -> type . ID = expression moreVar

    ID              shift and go to state 17


state 10

    (2) initVarDeclar -> varDeclar . initVarDeclar
    (2) initVarDeclar -> . varDeclar initVarDeclar
    (3) initVarDeclar -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (8) vars -> . type ID = expression moreVar
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    FUNCTION        reduce using rule 3 (initVarDeclar -> .)
    MAIN            reduce using rule 3 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    initVarDeclar                  shift and go to state 18
    varDeclar                      shift and go to state 10
    type                           shift and go to state 9

state 11

    (6) varDeclar -> vars ; .

    ARRAY           reduce using rule 6 (varDeclar -> vars ; .)
    ID              reduce using rule 6 (varDeclar -> vars ; .)
    IF              reduce using rule 6 (varDeclar -> vars ; .)
    CONSOLE         reduce using rule 6 (varDeclar -> vars ; .)
    INPUT           reduce using rule 6 (varDeclar -> vars ; .)
    FOR             reduce using rule 6 (varDeclar -> vars ; .)
    WHILE           reduce using rule 6 (varDeclar -> vars ; .)
    DO              reduce using rule 6 (varDeclar -> vars ; .)
    INTTYPE         reduce using rule 6 (varDeclar -> vars ; .)
    FLOATTYPE       reduce using rule 6 (varDeclar -> vars ; .)
    STRINGTYPE      reduce using rule 6 (varDeclar -> vars ; .)
    BOOLTYPE        reduce using rule 6 (varDeclar -> vars ; .)
    }               reduce using rule 6 (varDeclar -> vars ; .)
    RETURN          reduce using rule 6 (varDeclar -> vars ; .)
    FUNCTION        reduce using rule 6 (varDeclar -> vars ; .)
    MAIN            reduce using rule 6 (varDeclar -> vars ; .)


state 12

    (7) varDeclar -> ARRAY arrays . ;

    ;               shift and go to state 19


state 13

    (15) arrays -> type . ID [ constant ] = { expression moreExp } moreArray

    ID              shift and go to state 20


state 14

    (4) functionDeclar -> function . functionDeclar
    (4) functionDeclar -> . function functionDeclar
    (5) functionDeclar -> .
    (20) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 5 (functionDeclar -> .)
    FUNCTION        shift and go to state 15

    function                       shift and go to state 14
    functionDeclar                 shift and go to state 21

state 15

    (20) function -> FUNCTION . funcType ID ( par ) { block RETURN returnType ; }
    (21) funcType -> . type
    (22) funcType -> . VOID
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    VOID            shift and go to state 22
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    funcType                       shift and go to state 23
    type                           shift and go to state 24

state 16

    (1) program -> initVarDeclar functionDeclar . main
    (25) main -> . MAIN ( par ) { block }

    MAIN            shift and go to state 26

    main                           shift and go to state 25

state 17

    (8) vars -> type ID . = expression moreVar

    =               shift and go to state 27


state 18

    (2) initVarDeclar -> varDeclar initVarDeclar .

    FUNCTION        reduce using rule 2 (initVarDeclar -> varDeclar initVarDeclar .)
    MAIN            reduce using rule 2 (initVarDeclar -> varDeclar initVarDeclar .)


state 19

    (7) varDeclar -> ARRAY arrays ; .

    ARRAY           reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    ID              reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    IF              reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    CONSOLE         reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    INPUT           reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    FOR             reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    WHILE           reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    DO              reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    INTTYPE         reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    FLOATTYPE       reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    STRINGTYPE      reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    BOOLTYPE        reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    }               reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    RETURN          reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    FUNCTION        reduce using rule 7 (varDeclar -> ARRAY arrays ; .)
    MAIN            reduce using rule 7 (varDeclar -> ARRAY arrays ; .)


state 20

    (15) arrays -> type ID . [ constant ] = { expression moreExp } moreArray

    [               shift and go to state 28


state 21

    (4) functionDeclar -> function functionDeclar .

    MAIN            reduce using rule 4 (functionDeclar -> function functionDeclar .)


state 22

    (22) funcType -> VOID .

    ID              reduce using rule 22 (funcType -> VOID .)


state 23

    (20) function -> FUNCTION funcType . ID ( par ) { block RETURN returnType ; }

    ID              shift and go to state 29


state 24

    (21) funcType -> type .

    ID              reduce using rule 21 (funcType -> type .)


state 25

    (1) program -> initVarDeclar functionDeclar main .

    $end            reduce using rule 1 (program -> initVarDeclar functionDeclar main .)


state 26

    (25) main -> MAIN . ( par ) { block }

    (               shift and go to state 30


state 27

    (8) vars -> type ID = . expression moreVar
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    input                          shift and go to state 37
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    bool                           shift and go to state 36
    expression                     shift and go to state 47

state 28

    (15) arrays -> type ID [ . constant ] = { expression moreExp } moreArray
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    constant                       shift and go to state 48
    bool                           shift and go to state 36

state 29

    (20) function -> FUNCTION funcType ID . ( par ) { block RETURN returnType ; }

    (               shift and go to state 49


state 30

    (25) main -> MAIN ( . par ) { block }
    (26) par -> . type ID morePar
    (27) par -> .
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    )               reduce using rule 27 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 50
    type                           shift and go to state 51

state 31

    (93) data -> constant .

    *               reduce using rule 93 (data -> constant .)
    /               reduce using rule 93 (data -> constant .)
    %               reduce using rule 93 (data -> constant .)
    +               reduce using rule 93 (data -> constant .)
    -               reduce using rule 93 (data -> constant .)
    LESS            reduce using rule 93 (data -> constant .)
    GREATER         reduce using rule 93 (data -> constant .)
    LESSEQUAL       reduce using rule 93 (data -> constant .)
    GREATEREQUAL    reduce using rule 93 (data -> constant .)
    DIFFERENT       reduce using rule 93 (data -> constant .)
    EQUALTO         reduce using rule 93 (data -> constant .)
    AND             reduce using rule 93 (data -> constant .)
    OR              reduce using rule 93 (data -> constant .)
    ,               reduce using rule 93 (data -> constant .)
    ;               reduce using rule 93 (data -> constant .)
    )               reduce using rule 93 (data -> constant .)
    ]               reduce using rule 93 (data -> constant .)
    }               reduce using rule 93 (data -> constant .)


state 32

    (84) term -> factor . possibleFactors
    (85) possibleFactors -> . possibleFactorOp factor possibleFactors
    (86) possibleFactors -> .
    (87) possibleFactorOp -> . *
    (88) possibleFactorOp -> . /
    (89) possibleFactorOp -> . %

    +               reduce using rule 86 (possibleFactors -> .)
    -               reduce using rule 86 (possibleFactors -> .)
    LESS            reduce using rule 86 (possibleFactors -> .)
    GREATER         reduce using rule 86 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 86 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 86 (possibleFactors -> .)
    DIFFERENT       reduce using rule 86 (possibleFactors -> .)
    EQUALTO         reduce using rule 86 (possibleFactors -> .)
    AND             reduce using rule 86 (possibleFactors -> .)
    OR              reduce using rule 86 (possibleFactors -> .)
    ,               reduce using rule 86 (possibleFactors -> .)
    ;               reduce using rule 86 (possibleFactors -> .)
    )               reduce using rule 86 (possibleFactors -> .)
    ]               reduce using rule 86 (possibleFactors -> .)
    }               reduce using rule 86 (possibleFactors -> .)
    *               shift and go to state 53
    /               shift and go to state 55
    %               shift and go to state 52

    possibleFactors                shift and go to state 54
    possibleFactorOp               shift and go to state 56

state 33

    (102) bool -> TRUE .

    *               reduce using rule 102 (bool -> TRUE .)
    /               reduce using rule 102 (bool -> TRUE .)
    %               reduce using rule 102 (bool -> TRUE .)
    +               reduce using rule 102 (bool -> TRUE .)
    -               reduce using rule 102 (bool -> TRUE .)
    LESS            reduce using rule 102 (bool -> TRUE .)
    GREATER         reduce using rule 102 (bool -> TRUE .)
    LESSEQUAL       reduce using rule 102 (bool -> TRUE .)
    GREATEREQUAL    reduce using rule 102 (bool -> TRUE .)
    DIFFERENT       reduce using rule 102 (bool -> TRUE .)
    EQUALTO         reduce using rule 102 (bool -> TRUE .)
    AND             reduce using rule 102 (bool -> TRUE .)
    OR              reduce using rule 102 (bool -> TRUE .)
    ,               reduce using rule 102 (bool -> TRUE .)
    ;               reduce using rule 102 (bool -> TRUE .)
    }               reduce using rule 102 (bool -> TRUE .)
    )               reduce using rule 102 (bool -> TRUE .)
    ]               reduce using rule 102 (bool -> TRUE .)


state 34

    (91) factor -> data .

    *               reduce using rule 91 (factor -> data .)
    /               reduce using rule 91 (factor -> data .)
    %               reduce using rule 91 (factor -> data .)
    +               reduce using rule 91 (factor -> data .)
    -               reduce using rule 91 (factor -> data .)
    LESS            reduce using rule 91 (factor -> data .)
    GREATER         reduce using rule 91 (factor -> data .)
    LESSEQUAL       reduce using rule 91 (factor -> data .)
    GREATEREQUAL    reduce using rule 91 (factor -> data .)
    DIFFERENT       reduce using rule 91 (factor -> data .)
    EQUALTO         reduce using rule 91 (factor -> data .)
    AND             reduce using rule 91 (factor -> data .)
    OR              reduce using rule 91 (factor -> data .)
    )               reduce using rule 91 (factor -> data .)
    ;               reduce using rule 91 (factor -> data .)
    ,               reduce using rule 91 (factor -> data .)
    }               reduce using rule 91 (factor -> data .)
    ]               reduce using rule 91 (factor -> data .)


state 35

    (65) expression -> higherExp . possibleHigherExp
    (66) possibleHigherExp -> . possibleHigherExpOp higherExp
    (67) possibleHigherExp -> .
    (68) possibleHigherExpOp -> . AND
    (69) possibleHigherExpOp -> . OR

    ,               reduce using rule 67 (possibleHigherExp -> .)
    ;               reduce using rule 67 (possibleHigherExp -> .)
    )               reduce using rule 67 (possibleHigherExp -> .)
    ]               reduce using rule 67 (possibleHigherExp -> .)
    }               reduce using rule 67 (possibleHigherExp -> .)
    AND             shift and go to state 57
    OR              shift and go to state 60

    possibleHigherExpOp            shift and go to state 58
    possibleHigherExp              shift and go to state 59

state 36

    (100) constant -> bool .

    *               reduce using rule 100 (constant -> bool .)
    /               reduce using rule 100 (constant -> bool .)
    %               reduce using rule 100 (constant -> bool .)
    +               reduce using rule 100 (constant -> bool .)
    -               reduce using rule 100 (constant -> bool .)
    LESS            reduce using rule 100 (constant -> bool .)
    GREATER         reduce using rule 100 (constant -> bool .)
    LESSEQUAL       reduce using rule 100 (constant -> bool .)
    GREATEREQUAL    reduce using rule 100 (constant -> bool .)
    DIFFERENT       reduce using rule 100 (constant -> bool .)
    EQUALTO         reduce using rule 100 (constant -> bool .)
    AND             reduce using rule 100 (constant -> bool .)
    OR              reduce using rule 100 (constant -> bool .)
    ,               reduce using rule 100 (constant -> bool .)
    )               reduce using rule 100 (constant -> bool .)
    ]               reduce using rule 100 (constant -> bool .)
    ;               reduce using rule 100 (constant -> bool .)
    }               reduce using rule 100 (constant -> bool .)


state 37

    (94) data -> input .

    *               reduce using rule 94 (data -> input .)
    /               reduce using rule 94 (data -> input .)
    %               reduce using rule 94 (data -> input .)
    +               reduce using rule 94 (data -> input .)
    -               reduce using rule 94 (data -> input .)
    LESS            reduce using rule 94 (data -> input .)
    GREATER         reduce using rule 94 (data -> input .)
    LESSEQUAL       reduce using rule 94 (data -> input .)
    GREATEREQUAL    reduce using rule 94 (data -> input .)
    DIFFERENT       reduce using rule 94 (data -> input .)
    EQUALTO         reduce using rule 94 (data -> input .)
    AND             reduce using rule 94 (data -> input .)
    OR              reduce using rule 94 (data -> input .)
    ,               reduce using rule 94 (data -> input .)
    ;               reduce using rule 94 (data -> input .)
    )               reduce using rule 94 (data -> input .)
    ]               reduce using rule 94 (data -> input .)
    }               reduce using rule 94 (data -> input .)


state 38

    (101) constant -> STRING .

    *               reduce using rule 101 (constant -> STRING .)
    /               reduce using rule 101 (constant -> STRING .)
    %               reduce using rule 101 (constant -> STRING .)
    +               reduce using rule 101 (constant -> STRING .)
    -               reduce using rule 101 (constant -> STRING .)
    LESS            reduce using rule 101 (constant -> STRING .)
    GREATER         reduce using rule 101 (constant -> STRING .)
    LESSEQUAL       reduce using rule 101 (constant -> STRING .)
    GREATEREQUAL    reduce using rule 101 (constant -> STRING .)
    DIFFERENT       reduce using rule 101 (constant -> STRING .)
    EQUALTO         reduce using rule 101 (constant -> STRING .)
    AND             reduce using rule 101 (constant -> STRING .)
    OR              reduce using rule 101 (constant -> STRING .)
    ,               reduce using rule 101 (constant -> STRING .)
    )               reduce using rule 101 (constant -> STRING .)
    ]               reduce using rule 101 (constant -> STRING .)
    ;               reduce using rule 101 (constant -> STRING .)
    }               reduce using rule 101 (constant -> STRING .)


state 39

    (104) input -> INPUT . ( inputPar )

    (               shift and go to state 61


state 40

    (92) data -> ID . possibleIdCall
    (95) possibleIdCall -> . [ expression ]
    (96) possibleIdCall -> . ( parIn )
    (97) possibleIdCall -> .

    [               shift and go to state 64
    (               shift and go to state 63
    *               reduce using rule 97 (possibleIdCall -> .)
    /               reduce using rule 97 (possibleIdCall -> .)
    %               reduce using rule 97 (possibleIdCall -> .)
    +               reduce using rule 97 (possibleIdCall -> .)
    -               reduce using rule 97 (possibleIdCall -> .)
    LESS            reduce using rule 97 (possibleIdCall -> .)
    GREATER         reduce using rule 97 (possibleIdCall -> .)
    LESSEQUAL       reduce using rule 97 (possibleIdCall -> .)
    GREATEREQUAL    reduce using rule 97 (possibleIdCall -> .)
    DIFFERENT       reduce using rule 97 (possibleIdCall -> .)
    EQUALTO         reduce using rule 97 (possibleIdCall -> .)
    AND             reduce using rule 97 (possibleIdCall -> .)
    OR              reduce using rule 97 (possibleIdCall -> .)
    ,               reduce using rule 97 (possibleIdCall -> .)
    ;               reduce using rule 97 (possibleIdCall -> .)
    )               reduce using rule 97 (possibleIdCall -> .)
    ]               reduce using rule 97 (possibleIdCall -> .)
    }               reduce using rule 97 (possibleIdCall -> .)

    possibleIdCall                 shift and go to state 62

state 41

    (79) exp -> term . possibleTerms
    (80) possibleTerms -> . possibleTermOp term possibleTerms
    (81) possibleTerms -> .
    (82) possibleTermOp -> . +
    (83) possibleTermOp -> . -

    LESS            reduce using rule 81 (possibleTerms -> .)
    GREATER         reduce using rule 81 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 81 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 81 (possibleTerms -> .)
    DIFFERENT       reduce using rule 81 (possibleTerms -> .)
    EQUALTO         reduce using rule 81 (possibleTerms -> .)
    AND             reduce using rule 81 (possibleTerms -> .)
    OR              reduce using rule 81 (possibleTerms -> .)
    ,               reduce using rule 81 (possibleTerms -> .)
    ;               reduce using rule 81 (possibleTerms -> .)
    )               reduce using rule 81 (possibleTerms -> .)
    ]               reduce using rule 81 (possibleTerms -> .)
    }               reduce using rule 81 (possibleTerms -> .)
    +               shift and go to state 68
    -               shift and go to state 67

    possibleTermOp                 shift and go to state 65
    possibleTerms                  shift and go to state 66

state 42

    (103) bool -> FALSE .

    *               reduce using rule 103 (bool -> FALSE .)
    /               reduce using rule 103 (bool -> FALSE .)
    %               reduce using rule 103 (bool -> FALSE .)
    +               reduce using rule 103 (bool -> FALSE .)
    -               reduce using rule 103 (bool -> FALSE .)
    LESS            reduce using rule 103 (bool -> FALSE .)
    GREATER         reduce using rule 103 (bool -> FALSE .)
    LESSEQUAL       reduce using rule 103 (bool -> FALSE .)
    GREATEREQUAL    reduce using rule 103 (bool -> FALSE .)
    DIFFERENT       reduce using rule 103 (bool -> FALSE .)
    EQUALTO         reduce using rule 103 (bool -> FALSE .)
    AND             reduce using rule 103 (bool -> FALSE .)
    OR              reduce using rule 103 (bool -> FALSE .)
    ,               reduce using rule 103 (bool -> FALSE .)
    ;               reduce using rule 103 (bool -> FALSE .)
    }               reduce using rule 103 (bool -> FALSE .)
    )               reduce using rule 103 (bool -> FALSE .)
    ]               reduce using rule 103 (bool -> FALSE .)


state 43

    (98) constant -> INT .

    *               reduce using rule 98 (constant -> INT .)
    /               reduce using rule 98 (constant -> INT .)
    %               reduce using rule 98 (constant -> INT .)
    +               reduce using rule 98 (constant -> INT .)
    -               reduce using rule 98 (constant -> INT .)
    LESS            reduce using rule 98 (constant -> INT .)
    GREATER         reduce using rule 98 (constant -> INT .)
    LESSEQUAL       reduce using rule 98 (constant -> INT .)
    GREATEREQUAL    reduce using rule 98 (constant -> INT .)
    DIFFERENT       reduce using rule 98 (constant -> INT .)
    EQUALTO         reduce using rule 98 (constant -> INT .)
    AND             reduce using rule 98 (constant -> INT .)
    OR              reduce using rule 98 (constant -> INT .)
    ,               reduce using rule 98 (constant -> INT .)
    )               reduce using rule 98 (constant -> INT .)
    ]               reduce using rule 98 (constant -> INT .)
    ;               reduce using rule 98 (constant -> INT .)
    }               reduce using rule 98 (constant -> INT .)


state 44

    (99) constant -> FLOAT .

    *               reduce using rule 99 (constant -> FLOAT .)
    /               reduce using rule 99 (constant -> FLOAT .)
    %               reduce using rule 99 (constant -> FLOAT .)
    +               reduce using rule 99 (constant -> FLOAT .)
    -               reduce using rule 99 (constant -> FLOAT .)
    LESS            reduce using rule 99 (constant -> FLOAT .)
    GREATER         reduce using rule 99 (constant -> FLOAT .)
    LESSEQUAL       reduce using rule 99 (constant -> FLOAT .)
    GREATEREQUAL    reduce using rule 99 (constant -> FLOAT .)
    DIFFERENT       reduce using rule 99 (constant -> FLOAT .)
    EQUALTO         reduce using rule 99 (constant -> FLOAT .)
    AND             reduce using rule 99 (constant -> FLOAT .)
    OR              reduce using rule 99 (constant -> FLOAT .)
    ,               reduce using rule 99 (constant -> FLOAT .)
    )               reduce using rule 99 (constant -> FLOAT .)
    ]               reduce using rule 99 (constant -> FLOAT .)
    ;               reduce using rule 99 (constant -> FLOAT .)
    }               reduce using rule 99 (constant -> FLOAT .)


state 45

    (70) higherExp -> exp . possibleExp
    (71) possibleExp -> . possibleExpOp exp
    (72) possibleExp -> .
    (73) possibleExpOp -> . LESS
    (74) possibleExpOp -> . GREATER
    (75) possibleExpOp -> . LESSEQUAL
    (76) possibleExpOp -> . GREATEREQUAL
    (77) possibleExpOp -> . DIFFERENT
    (78) possibleExpOp -> . EQUALTO

    AND             reduce using rule 72 (possibleExp -> .)
    OR              reduce using rule 72 (possibleExp -> .)
    ,               reduce using rule 72 (possibleExp -> .)
    ;               reduce using rule 72 (possibleExp -> .)
    )               reduce using rule 72 (possibleExp -> .)
    ]               reduce using rule 72 (possibleExp -> .)
    }               reduce using rule 72 (possibleExp -> .)
    LESS            shift and go to state 72
    GREATER         shift and go to state 70
    LESSEQUAL       shift and go to state 76
    GREATEREQUAL    shift and go to state 69
    DIFFERENT       shift and go to state 75
    EQUALTO         shift and go to state 74

    possibleExp                    shift and go to state 73
    possibleExpOp                  shift and go to state 71

state 46

    (90) factor -> ( . expression )
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 77

state 47

    (8) vars -> type ID = expression . moreVar
    (9) moreVar -> . , ID = expression moreVar
    (10) moreVar -> .

    ,               shift and go to state 79
    ;               reduce using rule 10 (moreVar -> .)

    moreVar                        shift and go to state 78

state 48

    (15) arrays -> type ID [ constant . ] = { expression moreExp } moreArray

    ]               shift and go to state 80


state 49

    (20) function -> FUNCTION funcType ID ( . par ) { block RETURN returnType ; }
    (26) par -> . type ID morePar
    (27) par -> .
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    )               reduce using rule 27 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 81
    type                           shift and go to state 51

state 50

    (25) main -> MAIN ( par . ) { block }

    )               shift and go to state 82


state 51

    (26) par -> type . ID morePar

    ID              shift and go to state 83


state 52

    (89) possibleFactorOp -> % .

    (               reduce using rule 89 (possibleFactorOp -> % .)
    ID              reduce using rule 89 (possibleFactorOp -> % .)
    INT             reduce using rule 89 (possibleFactorOp -> % .)
    FLOAT           reduce using rule 89 (possibleFactorOp -> % .)
    STRING          reduce using rule 89 (possibleFactorOp -> % .)
    INPUT           reduce using rule 89 (possibleFactorOp -> % .)
    TRUE            reduce using rule 89 (possibleFactorOp -> % .)
    FALSE           reduce using rule 89 (possibleFactorOp -> % .)


state 53

    (87) possibleFactorOp -> * .

    (               reduce using rule 87 (possibleFactorOp -> * .)
    ID              reduce using rule 87 (possibleFactorOp -> * .)
    INT             reduce using rule 87 (possibleFactorOp -> * .)
    FLOAT           reduce using rule 87 (possibleFactorOp -> * .)
    STRING          reduce using rule 87 (possibleFactorOp -> * .)
    INPUT           reduce using rule 87 (possibleFactorOp -> * .)
    TRUE            reduce using rule 87 (possibleFactorOp -> * .)
    FALSE           reduce using rule 87 (possibleFactorOp -> * .)


state 54

    (84) term -> factor possibleFactors .

    +               reduce using rule 84 (term -> factor possibleFactors .)
    -               reduce using rule 84 (term -> factor possibleFactors .)
    LESS            reduce using rule 84 (term -> factor possibleFactors .)
    GREATER         reduce using rule 84 (term -> factor possibleFactors .)
    LESSEQUAL       reduce using rule 84 (term -> factor possibleFactors .)
    GREATEREQUAL    reduce using rule 84 (term -> factor possibleFactors .)
    DIFFERENT       reduce using rule 84 (term -> factor possibleFactors .)
    EQUALTO         reduce using rule 84 (term -> factor possibleFactors .)
    AND             reduce using rule 84 (term -> factor possibleFactors .)
    OR              reduce using rule 84 (term -> factor possibleFactors .)
    ,               reduce using rule 84 (term -> factor possibleFactors .)
    )               reduce using rule 84 (term -> factor possibleFactors .)
    ]               reduce using rule 84 (term -> factor possibleFactors .)
    ;               reduce using rule 84 (term -> factor possibleFactors .)
    }               reduce using rule 84 (term -> factor possibleFactors .)


state 55

    (88) possibleFactorOp -> / .

    (               reduce using rule 88 (possibleFactorOp -> / .)
    ID              reduce using rule 88 (possibleFactorOp -> / .)
    INT             reduce using rule 88 (possibleFactorOp -> / .)
    FLOAT           reduce using rule 88 (possibleFactorOp -> / .)
    STRING          reduce using rule 88 (possibleFactorOp -> / .)
    INPUT           reduce using rule 88 (possibleFactorOp -> / .)
    TRUE            reduce using rule 88 (possibleFactorOp -> / .)
    FALSE           reduce using rule 88 (possibleFactorOp -> / .)


state 56

    (85) possibleFactors -> possibleFactorOp . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    constant                       shift and go to state 31
    data                           shift and go to state 34
    bool                           shift and go to state 36
    factor                         shift and go to state 84
    input                          shift and go to state 37

state 57

    (68) possibleHigherExpOp -> AND .

    (               reduce using rule 68 (possibleHigherExpOp -> AND .)
    ID              reduce using rule 68 (possibleHigherExpOp -> AND .)
    INT             reduce using rule 68 (possibleHigherExpOp -> AND .)
    FLOAT           reduce using rule 68 (possibleHigherExpOp -> AND .)
    STRING          reduce using rule 68 (possibleHigherExpOp -> AND .)
    INPUT           reduce using rule 68 (possibleHigherExpOp -> AND .)
    TRUE            reduce using rule 68 (possibleHigherExpOp -> AND .)
    FALSE           reduce using rule 68 (possibleHigherExpOp -> AND .)


state 58

    (66) possibleHigherExp -> possibleHigherExpOp . higherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 85
    bool                           shift and go to state 36
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37

state 59

    (65) expression -> higherExp possibleHigherExp .

    ,               reduce using rule 65 (expression -> higherExp possibleHigherExp .)
    }               reduce using rule 65 (expression -> higherExp possibleHigherExp .)
    ;               reduce using rule 65 (expression -> higherExp possibleHigherExp .)
    )               reduce using rule 65 (expression -> higherExp possibleHigherExp .)
    ]               reduce using rule 65 (expression -> higherExp possibleHigherExp .)


state 60

    (69) possibleHigherExpOp -> OR .

    (               reduce using rule 69 (possibleHigherExpOp -> OR .)
    ID              reduce using rule 69 (possibleHigherExpOp -> OR .)
    INT             reduce using rule 69 (possibleHigherExpOp -> OR .)
    FLOAT           reduce using rule 69 (possibleHigherExpOp -> OR .)
    STRING          reduce using rule 69 (possibleHigherExpOp -> OR .)
    INPUT           reduce using rule 69 (possibleHigherExpOp -> OR .)
    TRUE            reduce using rule 69 (possibleHigherExpOp -> OR .)
    FALSE           reduce using rule 69 (possibleHigherExpOp -> OR .)


state 61

    (104) input -> INPUT ( . inputPar )
    (105) inputPar -> . STRING
    (106) inputPar -> .

    STRING          shift and go to state 86
    )               reduce using rule 106 (inputPar -> .)

    inputPar                       shift and go to state 87

state 62

    (92) data -> ID possibleIdCall .

    *               reduce using rule 92 (data -> ID possibleIdCall .)
    /               reduce using rule 92 (data -> ID possibleIdCall .)
    %               reduce using rule 92 (data -> ID possibleIdCall .)
    +               reduce using rule 92 (data -> ID possibleIdCall .)
    -               reduce using rule 92 (data -> ID possibleIdCall .)
    LESS            reduce using rule 92 (data -> ID possibleIdCall .)
    GREATER         reduce using rule 92 (data -> ID possibleIdCall .)
    LESSEQUAL       reduce using rule 92 (data -> ID possibleIdCall .)
    GREATEREQUAL    reduce using rule 92 (data -> ID possibleIdCall .)
    DIFFERENT       reduce using rule 92 (data -> ID possibleIdCall .)
    EQUALTO         reduce using rule 92 (data -> ID possibleIdCall .)
    AND             reduce using rule 92 (data -> ID possibleIdCall .)
    OR              reduce using rule 92 (data -> ID possibleIdCall .)
    ,               reduce using rule 92 (data -> ID possibleIdCall .)
    ;               reduce using rule 92 (data -> ID possibleIdCall .)
    )               reduce using rule 92 (data -> ID possibleIdCall .)
    ]               reduce using rule 92 (data -> ID possibleIdCall .)
    }               reduce using rule 92 (data -> ID possibleIdCall .)


state 63

    (96) possibleIdCall -> ( . parIn )
    (31) parIn -> . expression moreParIn
    (32) parIn -> .
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    )               reduce using rule 32 (parIn -> .)
    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    data                           shift and go to state 34
    higherExp                      shift and go to state 35
    parIn                          shift and go to state 88
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 89

state 64

    (95) possibleIdCall -> [ . expression ]
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 90

state 65

    (80) possibleTerms -> possibleTermOp . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 91
    constant                       shift and go to state 31
    data                           shift and go to state 34
    bool                           shift and go to state 36
    factor                         shift and go to state 32
    input                          shift and go to state 37

state 66

    (79) exp -> term possibleTerms .

    LESS            reduce using rule 79 (exp -> term possibleTerms .)
    GREATER         reduce using rule 79 (exp -> term possibleTerms .)
    LESSEQUAL       reduce using rule 79 (exp -> term possibleTerms .)
    GREATEREQUAL    reduce using rule 79 (exp -> term possibleTerms .)
    DIFFERENT       reduce using rule 79 (exp -> term possibleTerms .)
    EQUALTO         reduce using rule 79 (exp -> term possibleTerms .)
    AND             reduce using rule 79 (exp -> term possibleTerms .)
    OR              reduce using rule 79 (exp -> term possibleTerms .)
    )               reduce using rule 79 (exp -> term possibleTerms .)
    ]               reduce using rule 79 (exp -> term possibleTerms .)
    ,               reduce using rule 79 (exp -> term possibleTerms .)
    ;               reduce using rule 79 (exp -> term possibleTerms .)
    }               reduce using rule 79 (exp -> term possibleTerms .)


state 67

    (83) possibleTermOp -> - .

    (               reduce using rule 83 (possibleTermOp -> - .)
    ID              reduce using rule 83 (possibleTermOp -> - .)
    INT             reduce using rule 83 (possibleTermOp -> - .)
    FLOAT           reduce using rule 83 (possibleTermOp -> - .)
    STRING          reduce using rule 83 (possibleTermOp -> - .)
    INPUT           reduce using rule 83 (possibleTermOp -> - .)
    TRUE            reduce using rule 83 (possibleTermOp -> - .)
    FALSE           reduce using rule 83 (possibleTermOp -> - .)


state 68

    (82) possibleTermOp -> + .

    (               reduce using rule 82 (possibleTermOp -> + .)
    ID              reduce using rule 82 (possibleTermOp -> + .)
    INT             reduce using rule 82 (possibleTermOp -> + .)
    FLOAT           reduce using rule 82 (possibleTermOp -> + .)
    STRING          reduce using rule 82 (possibleTermOp -> + .)
    INPUT           reduce using rule 82 (possibleTermOp -> + .)
    TRUE            reduce using rule 82 (possibleTermOp -> + .)
    FALSE           reduce using rule 82 (possibleTermOp -> + .)


state 69

    (76) possibleExpOp -> GREATEREQUAL .

    (               reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    ID              reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    INT             reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    FLOAT           reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    STRING          reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    INPUT           reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    TRUE            reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)
    FALSE           reduce using rule 76 (possibleExpOp -> GREATEREQUAL .)


state 70

    (74) possibleExpOp -> GREATER .

    (               reduce using rule 74 (possibleExpOp -> GREATER .)
    ID              reduce using rule 74 (possibleExpOp -> GREATER .)
    INT             reduce using rule 74 (possibleExpOp -> GREATER .)
    FLOAT           reduce using rule 74 (possibleExpOp -> GREATER .)
    STRING          reduce using rule 74 (possibleExpOp -> GREATER .)
    INPUT           reduce using rule 74 (possibleExpOp -> GREATER .)
    TRUE            reduce using rule 74 (possibleExpOp -> GREATER .)
    FALSE           reduce using rule 74 (possibleExpOp -> GREATER .)


state 71

    (71) possibleExp -> possibleExpOp . exp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    data                           shift and go to state 34
    bool                           shift and go to state 36
    exp                            shift and go to state 92
    factor                         shift and go to state 32
    input                          shift and go to state 37

state 72

    (73) possibleExpOp -> LESS .

    (               reduce using rule 73 (possibleExpOp -> LESS .)
    ID              reduce using rule 73 (possibleExpOp -> LESS .)
    INT             reduce using rule 73 (possibleExpOp -> LESS .)
    FLOAT           reduce using rule 73 (possibleExpOp -> LESS .)
    STRING          reduce using rule 73 (possibleExpOp -> LESS .)
    INPUT           reduce using rule 73 (possibleExpOp -> LESS .)
    TRUE            reduce using rule 73 (possibleExpOp -> LESS .)
    FALSE           reduce using rule 73 (possibleExpOp -> LESS .)


state 73

    (70) higherExp -> exp possibleExp .

    AND             reduce using rule 70 (higherExp -> exp possibleExp .)
    OR              reduce using rule 70 (higherExp -> exp possibleExp .)
    ,               reduce using rule 70 (higherExp -> exp possibleExp .)
    )               reduce using rule 70 (higherExp -> exp possibleExp .)
    ;               reduce using rule 70 (higherExp -> exp possibleExp .)
    ]               reduce using rule 70 (higherExp -> exp possibleExp .)
    }               reduce using rule 70 (higherExp -> exp possibleExp .)


state 74

    (78) possibleExpOp -> EQUALTO .

    (               reduce using rule 78 (possibleExpOp -> EQUALTO .)
    ID              reduce using rule 78 (possibleExpOp -> EQUALTO .)
    INT             reduce using rule 78 (possibleExpOp -> EQUALTO .)
    FLOAT           reduce using rule 78 (possibleExpOp -> EQUALTO .)
    STRING          reduce using rule 78 (possibleExpOp -> EQUALTO .)
    INPUT           reduce using rule 78 (possibleExpOp -> EQUALTO .)
    TRUE            reduce using rule 78 (possibleExpOp -> EQUALTO .)
    FALSE           reduce using rule 78 (possibleExpOp -> EQUALTO .)


state 75

    (77) possibleExpOp -> DIFFERENT .

    (               reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    ID              reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    INT             reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    FLOAT           reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    STRING          reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    INPUT           reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    TRUE            reduce using rule 77 (possibleExpOp -> DIFFERENT .)
    FALSE           reduce using rule 77 (possibleExpOp -> DIFFERENT .)


state 76

    (75) possibleExpOp -> LESSEQUAL .

    (               reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    ID              reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    INT             reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    FLOAT           reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    STRING          reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    INPUT           reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    TRUE            reduce using rule 75 (possibleExpOp -> LESSEQUAL .)
    FALSE           reduce using rule 75 (possibleExpOp -> LESSEQUAL .)


state 77

    (90) factor -> ( expression . )

    )               shift and go to state 93


state 78

    (8) vars -> type ID = expression moreVar .

    ;               reduce using rule 8 (vars -> type ID = expression moreVar .)


state 79

    (9) moreVar -> , . ID = expression moreVar

    ID              shift and go to state 94


state 80

    (15) arrays -> type ID [ constant ] . = { expression moreExp } moreArray

    =               shift and go to state 95


state 81

    (20) function -> FUNCTION funcType ID ( par . ) { block RETURN returnType ; }

    )               shift and go to state 96


state 82

    (25) main -> MAIN ( par ) . { block }

    {               shift and go to state 97


state 83

    (26) par -> type ID . morePar
    (28) morePar -> . , type ID morePar
    (29) morePar -> .

    ,               shift and go to state 99
    )               reduce using rule 29 (morePar -> .)

    morePar                        shift and go to state 98

state 84

    (85) possibleFactors -> possibleFactorOp factor . possibleFactors
    (85) possibleFactors -> . possibleFactorOp factor possibleFactors
    (86) possibleFactors -> .
    (87) possibleFactorOp -> . *
    (88) possibleFactorOp -> . /
    (89) possibleFactorOp -> . %

    +               reduce using rule 86 (possibleFactors -> .)
    -               reduce using rule 86 (possibleFactors -> .)
    LESS            reduce using rule 86 (possibleFactors -> .)
    GREATER         reduce using rule 86 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 86 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 86 (possibleFactors -> .)
    DIFFERENT       reduce using rule 86 (possibleFactors -> .)
    EQUALTO         reduce using rule 86 (possibleFactors -> .)
    AND             reduce using rule 86 (possibleFactors -> .)
    OR              reduce using rule 86 (possibleFactors -> .)
    ,               reduce using rule 86 (possibleFactors -> .)
    ;               reduce using rule 86 (possibleFactors -> .)
    )               reduce using rule 86 (possibleFactors -> .)
    ]               reduce using rule 86 (possibleFactors -> .)
    }               reduce using rule 86 (possibleFactors -> .)
    *               shift and go to state 53
    /               shift and go to state 55
    %               shift and go to state 52

    possibleFactors                shift and go to state 100
    possibleFactorOp               shift and go to state 56

state 85

    (66) possibleHigherExp -> possibleHigherExpOp higherExp .

    ,               reduce using rule 66 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ;               reduce using rule 66 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    )               reduce using rule 66 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ]               reduce using rule 66 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    }               reduce using rule 66 (possibleHigherExp -> possibleHigherExpOp higherExp .)


state 86

    (105) inputPar -> STRING .

    )               reduce using rule 105 (inputPar -> STRING .)


state 87

    (104) input -> INPUT ( inputPar . )

    )               shift and go to state 101


state 88

    (96) possibleIdCall -> ( parIn . )

    )               shift and go to state 102


state 89

    (31) parIn -> expression . moreParIn
    (33) moreParIn -> . , expression moreParIn
    (34) moreParIn -> .

    ,               shift and go to state 104
    )               reduce using rule 34 (moreParIn -> .)

    moreParIn                      shift and go to state 103

state 90

    (95) possibleIdCall -> [ expression . ]

    ]               shift and go to state 105


state 91

    (80) possibleTerms -> possibleTermOp term . possibleTerms
    (80) possibleTerms -> . possibleTermOp term possibleTerms
    (81) possibleTerms -> .
    (82) possibleTermOp -> . +
    (83) possibleTermOp -> . -

    LESS            reduce using rule 81 (possibleTerms -> .)
    GREATER         reduce using rule 81 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 81 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 81 (possibleTerms -> .)
    DIFFERENT       reduce using rule 81 (possibleTerms -> .)
    EQUALTO         reduce using rule 81 (possibleTerms -> .)
    AND             reduce using rule 81 (possibleTerms -> .)
    OR              reduce using rule 81 (possibleTerms -> .)
    ,               reduce using rule 81 (possibleTerms -> .)
    ;               reduce using rule 81 (possibleTerms -> .)
    )               reduce using rule 81 (possibleTerms -> .)
    ]               reduce using rule 81 (possibleTerms -> .)
    }               reduce using rule 81 (possibleTerms -> .)
    +               shift and go to state 68
    -               shift and go to state 67

    possibleTermOp                 shift and go to state 65
    possibleTerms                  shift and go to state 106

state 92

    (71) possibleExp -> possibleExpOp exp .

    AND             reduce using rule 71 (possibleExp -> possibleExpOp exp .)
    OR              reduce using rule 71 (possibleExp -> possibleExpOp exp .)
    ,               reduce using rule 71 (possibleExp -> possibleExpOp exp .)
    ;               reduce using rule 71 (possibleExp -> possibleExpOp exp .)
    )               reduce using rule 71 (possibleExp -> possibleExpOp exp .)
    ]               reduce using rule 71 (possibleExp -> possibleExpOp exp .)
    }               reduce using rule 71 (possibleExp -> possibleExpOp exp .)


state 93

    (90) factor -> ( expression ) .

    *               reduce using rule 90 (factor -> ( expression ) .)
    /               reduce using rule 90 (factor -> ( expression ) .)
    %               reduce using rule 90 (factor -> ( expression ) .)
    +               reduce using rule 90 (factor -> ( expression ) .)
    -               reduce using rule 90 (factor -> ( expression ) .)
    LESS            reduce using rule 90 (factor -> ( expression ) .)
    GREATER         reduce using rule 90 (factor -> ( expression ) .)
    LESSEQUAL       reduce using rule 90 (factor -> ( expression ) .)
    GREATEREQUAL    reduce using rule 90 (factor -> ( expression ) .)
    DIFFERENT       reduce using rule 90 (factor -> ( expression ) .)
    EQUALTO         reduce using rule 90 (factor -> ( expression ) .)
    AND             reduce using rule 90 (factor -> ( expression ) .)
    OR              reduce using rule 90 (factor -> ( expression ) .)
    )               reduce using rule 90 (factor -> ( expression ) .)
    ;               reduce using rule 90 (factor -> ( expression ) .)
    ,               reduce using rule 90 (factor -> ( expression ) .)
    }               reduce using rule 90 (factor -> ( expression ) .)
    ]               reduce using rule 90 (factor -> ( expression ) .)


state 94

    (9) moreVar -> , ID . = expression moreVar

    =               shift and go to state 107


state 95

    (15) arrays -> type ID [ constant ] = . { expression moreExp } moreArray

    {               shift and go to state 108


state 96

    (20) function -> FUNCTION funcType ID ( par ) . { block RETURN returnType ; }

    {               shift and go to state 109


state 97

    (25) main -> MAIN ( par ) { . block }
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 123
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 98

    (26) par -> type ID morePar .

    )               reduce using rule 26 (par -> type ID morePar .)


state 99

    (28) morePar -> , . type ID morePar
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    type                           shift and go to state 127

state 100

    (85) possibleFactors -> possibleFactorOp factor possibleFactors .

    +               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    -               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESS            reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATER         reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESSEQUAL       reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATEREQUAL    reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    DIFFERENT       reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    EQUALTO         reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    AND             reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    OR              reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ,               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ;               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    )               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ]               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    }               reduce using rule 85 (possibleFactors -> possibleFactorOp factor possibleFactors .)


state 101

    (104) input -> INPUT ( inputPar ) .

    *               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    /               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    %               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    +               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    -               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    LESS            reduce using rule 104 (input -> INPUT ( inputPar ) .)
    GREATER         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    LESSEQUAL       reduce using rule 104 (input -> INPUT ( inputPar ) .)
    GREATEREQUAL    reduce using rule 104 (input -> INPUT ( inputPar ) .)
    DIFFERENT       reduce using rule 104 (input -> INPUT ( inputPar ) .)
    EQUALTO         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    AND             reduce using rule 104 (input -> INPUT ( inputPar ) .)
    OR              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    )               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ARRAY           reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ID              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    IF              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    CONSOLE         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    INPUT           reduce using rule 104 (input -> INPUT ( inputPar ) .)
    FOR             reduce using rule 104 (input -> INPUT ( inputPar ) .)
    WHILE           reduce using rule 104 (input -> INPUT ( inputPar ) .)
    DO              reduce using rule 104 (input -> INPUT ( inputPar ) .)
    INTTYPE         reduce using rule 104 (input -> INPUT ( inputPar ) .)
    FLOATTYPE       reduce using rule 104 (input -> INPUT ( inputPar ) .)
    STRINGTYPE      reduce using rule 104 (input -> INPUT ( inputPar ) .)
    BOOLTYPE        reduce using rule 104 (input -> INPUT ( inputPar ) .)
    }               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ]               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ,               reduce using rule 104 (input -> INPUT ( inputPar ) .)
    RETURN          reduce using rule 104 (input -> INPUT ( inputPar ) .)
    ;               reduce using rule 104 (input -> INPUT ( inputPar ) .)


state 102

    (96) possibleIdCall -> ( parIn ) .

    *               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    /               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    %               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    +               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    -               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    LESS            reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    GREATER         reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    LESSEQUAL       reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    GREATEREQUAL    reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    DIFFERENT       reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    EQUALTO         reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    AND             reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    OR              reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    ,               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    ;               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    )               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    ]               reduce using rule 96 (possibleIdCall -> ( parIn ) .)
    }               reduce using rule 96 (possibleIdCall -> ( parIn ) .)


state 103

    (31) parIn -> expression moreParIn .

    )               reduce using rule 31 (parIn -> expression moreParIn .)


state 104

    (33) moreParIn -> , . expression moreParIn
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 128

state 105

    (95) possibleIdCall -> [ expression ] .

    *               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    /               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    %               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    +               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    -               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    LESS            reduce using rule 95 (possibleIdCall -> [ expression ] .)
    GREATER         reduce using rule 95 (possibleIdCall -> [ expression ] .)
    LESSEQUAL       reduce using rule 95 (possibleIdCall -> [ expression ] .)
    GREATEREQUAL    reduce using rule 95 (possibleIdCall -> [ expression ] .)
    DIFFERENT       reduce using rule 95 (possibleIdCall -> [ expression ] .)
    EQUALTO         reduce using rule 95 (possibleIdCall -> [ expression ] .)
    AND             reduce using rule 95 (possibleIdCall -> [ expression ] .)
    OR              reduce using rule 95 (possibleIdCall -> [ expression ] .)
    ,               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    ;               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    )               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    ]               reduce using rule 95 (possibleIdCall -> [ expression ] .)
    }               reduce using rule 95 (possibleIdCall -> [ expression ] .)


state 106

    (80) possibleTerms -> possibleTermOp term possibleTerms .

    LESS            reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATER         reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    LESSEQUAL       reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    GREATEREQUAL    reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    DIFFERENT       reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    EQUALTO         reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    AND             reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    OR              reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    ,               reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    ;               reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    )               reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    ]               reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)
    }               reduce using rule 80 (possibleTerms -> possibleTermOp term possibleTerms .)


state 107

    (9) moreVar -> , ID = . expression moreVar
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    input                          shift and go to state 37
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    bool                           shift and go to state 36
    expression                     shift and go to state 129

state 108

    (15) arrays -> type ID [ constant ] = { . expression moreExp } moreArray
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    input                          shift and go to state 37
    expression                     shift and go to state 130
    higherExp                      shift and go to state 35
    bool                           shift and go to state 36
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32

state 109

    (20) function -> FUNCTION funcType ID ( par ) { . block RETURN returnType ; }
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 131
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 110

    (64) doWhile -> DO . { loopBlock } WHILE ( expression ) ;

    {               shift and go to state 132


state 111

    (37) block -> conditional . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    loop                           shift and go to state 126
    output                         shift and go to state 124
    assign                         shift and go to state 125
    block                          shift and go to state 133

state 112

    (61) loop -> doWhile .

    ARRAY           reduce using rule 61 (loop -> doWhile .)
    ID              reduce using rule 61 (loop -> doWhile .)
    IF              reduce using rule 61 (loop -> doWhile .)
    CONSOLE         reduce using rule 61 (loop -> doWhile .)
    INPUT           reduce using rule 61 (loop -> doWhile .)
    FOR             reduce using rule 61 (loop -> doWhile .)
    WHILE           reduce using rule 61 (loop -> doWhile .)
    DO              reduce using rule 61 (loop -> doWhile .)
    INTTYPE         reduce using rule 61 (loop -> doWhile .)
    FLOATTYPE       reduce using rule 61 (loop -> doWhile .)
    STRINGTYPE      reduce using rule 61 (loop -> doWhile .)
    BOOLTYPE        reduce using rule 61 (loop -> doWhile .)
    }               reduce using rule 61 (loop -> doWhile .)
    RETURN          reduce using rule 61 (loop -> doWhile .)


state 113

    (63) while -> WHILE . ( expression ) { loopBlock }

    (               shift and go to state 134


state 114

    (59) loop -> for .

    ARRAY           reduce using rule 59 (loop -> for .)
    ID              reduce using rule 59 (loop -> for .)
    IF              reduce using rule 59 (loop -> for .)
    CONSOLE         reduce using rule 59 (loop -> for .)
    INPUT           reduce using rule 59 (loop -> for .)
    FOR             reduce using rule 59 (loop -> for .)
    WHILE           reduce using rule 59 (loop -> for .)
    DO              reduce using rule 59 (loop -> for .)
    INTTYPE         reduce using rule 59 (loop -> for .)
    FLOATTYPE       reduce using rule 59 (loop -> for .)
    STRINGTYPE      reduce using rule 59 (loop -> for .)
    BOOLTYPE        reduce using rule 59 (loop -> for .)
    }               reduce using rule 59 (loop -> for .)
    RETURN          reduce using rule 59 (loop -> for .)


state 115

    (41) block -> input . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 135
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 116

    (35) block -> varDeclar . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 136
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 117

    (58) output -> CONSOLE . ( expression ) ;

    (               shift and go to state 137


state 118

    (62) for -> FOR . ( assign expression ) { loopBlock }

    (               shift and go to state 138


state 119

    (50) assign -> ID . possibleArray = expression ;
    (30) funcCall -> ID . ( parIn )
    (51) possibleArray -> . [ exp ]
    (52) possibleArray -> .

    (               shift and go to state 139
    [               shift and go to state 140
    =               reduce using rule 52 (possibleArray -> .)

    possibleArray                  shift and go to state 141

state 120

    (53) conditional -> IF . ( expression ) { block } possibleElif possibleElse

    (               shift and go to state 142


state 121

    (39) block -> funcCall . ; block

    ;               shift and go to state 143


state 122

    (60) loop -> while .

    ARRAY           reduce using rule 60 (loop -> while .)
    ID              reduce using rule 60 (loop -> while .)
    IF              reduce using rule 60 (loop -> while .)
    CONSOLE         reduce using rule 60 (loop -> while .)
    INPUT           reduce using rule 60 (loop -> while .)
    FOR             reduce using rule 60 (loop -> while .)
    WHILE           reduce using rule 60 (loop -> while .)
    DO              reduce using rule 60 (loop -> while .)
    INTTYPE         reduce using rule 60 (loop -> while .)
    FLOATTYPE       reduce using rule 60 (loop -> while .)
    STRINGTYPE      reduce using rule 60 (loop -> while .)
    BOOLTYPE        reduce using rule 60 (loop -> while .)
    }               reduce using rule 60 (loop -> while .)
    RETURN          reduce using rule 60 (loop -> while .)


state 123

    (25) main -> MAIN ( par ) { block . }

    }               shift and go to state 144


state 124

    (40) block -> output . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 145
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 125

    (36) block -> assign . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 146
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 126

    (38) block -> loop . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 147
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 127

    (28) morePar -> , type . ID morePar

    ID              shift and go to state 148


state 128

    (33) moreParIn -> , expression . moreParIn
    (33) moreParIn -> . , expression moreParIn
    (34) moreParIn -> .

    ,               shift and go to state 104
    )               reduce using rule 34 (moreParIn -> .)

    moreParIn                      shift and go to state 149

state 129

    (9) moreVar -> , ID = expression . moreVar
    (9) moreVar -> . , ID = expression moreVar
    (10) moreVar -> .

    ,               shift and go to state 79
    ;               reduce using rule 10 (moreVar -> .)

    moreVar                        shift and go to state 150

state 130

    (15) arrays -> type ID [ constant ] = { expression . moreExp } moreArray
    (16) moreExp -> . , expression moreExp
    (17) moreExp -> .

    ,               shift and go to state 151
    }               reduce using rule 17 (moreExp -> .)

    moreExp                        shift and go to state 152

state 131

    (20) function -> FUNCTION funcType ID ( par ) { block . RETURN returnType ; }

    RETURN          shift and go to state 153


state 132

    (64) doWhile -> DO { . loopBlock } WHILE ( expression ) ;
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 155
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 133

    (37) block -> conditional block .

    }               reduce using rule 37 (block -> conditional block .)
    RETURN          reduce using rule 37 (block -> conditional block .)


state 134

    (63) while -> WHILE ( . expression ) { loopBlock }
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 161

state 135

    (41) block -> input block .

    }               reduce using rule 41 (block -> input block .)
    RETURN          reduce using rule 41 (block -> input block .)


state 136

    (35) block -> varDeclar block .

    }               reduce using rule 35 (block -> varDeclar block .)
    RETURN          reduce using rule 35 (block -> varDeclar block .)


state 137

    (58) output -> CONSOLE ( . expression ) ;
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 162

state 138

    (62) for -> FOR ( . assign expression ) { loopBlock }
    (50) assign -> . ID possibleArray = expression ;

    ID              shift and go to state 163

    assign                         shift and go to state 164

state 139

    (30) funcCall -> ID ( . parIn )
    (31) parIn -> . expression moreParIn
    (32) parIn -> .
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    )               reduce using rule 32 (parIn -> .)
    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    data                           shift and go to state 34
    higherExp                      shift and go to state 35
    parIn                          shift and go to state 165
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 89

state 140

    (51) possibleArray -> [ . exp ]
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    data                           shift and go to state 34
    bool                           shift and go to state 36
    exp                            shift and go to state 166
    factor                         shift and go to state 32
    input                          shift and go to state 37

state 141

    (50) assign -> ID possibleArray . = expression ;

    =               shift and go to state 167


state 142

    (53) conditional -> IF ( . expression ) { block } possibleElif possibleElse
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    input                          shift and go to state 37
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    bool                           shift and go to state 36
    expression                     shift and go to state 168

state 143

    (39) block -> funcCall ; . block
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    RETURN          reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    loop                           shift and go to state 126
    output                         shift and go to state 124
    assign                         shift and go to state 125
    block                          shift and go to state 169

state 144

    (25) main -> MAIN ( par ) { block } .

    $end            reduce using rule 25 (main -> MAIN ( par ) { block } .)


state 145

    (40) block -> output block .

    }               reduce using rule 40 (block -> output block .)
    RETURN          reduce using rule 40 (block -> output block .)


state 146

    (36) block -> assign block .

    }               reduce using rule 36 (block -> assign block .)
    RETURN          reduce using rule 36 (block -> assign block .)


state 147

    (38) block -> loop block .

    }               reduce using rule 38 (block -> loop block .)
    RETURN          reduce using rule 38 (block -> loop block .)


state 148

    (28) morePar -> , type ID . morePar
    (28) morePar -> . , type ID morePar
    (29) morePar -> .

    ,               shift and go to state 99
    )               reduce using rule 29 (morePar -> .)

    morePar                        shift and go to state 170

state 149

    (33) moreParIn -> , expression moreParIn .

    )               reduce using rule 33 (moreParIn -> , expression moreParIn .)


state 150

    (9) moreVar -> , ID = expression moreVar .

    ;               reduce using rule 9 (moreVar -> , ID = expression moreVar .)


state 151

    (16) moreExp -> , . expression moreExp
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    bool                           shift and go to state 36
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    expression                     shift and go to state 171

state 152

    (15) arrays -> type ID [ constant ] = { expression moreExp . } moreArray

    }               shift and go to state 172


state 153

    (20) function -> FUNCTION funcType ID ( par ) { block RETURN . returnType ; }
    (23) returnType -> . expression
    (24) returnType -> . VOID
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    VOID            shift and go to state 173
    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    constant                       shift and go to state 31
    term                           shift and go to state 41
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    returnType                     shift and go to state 174
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 175

state 154

    (44) loopBlock -> conditional . loopBlock
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 176
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 155

    (64) doWhile -> DO { loopBlock . } WHILE ( expression ) ;

    }               shift and go to state 177


state 156

    (48) loopBlock -> input . loopBlock
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 178
    doWhile                        shift and go to state 112
    output                         shift and go to state 159
    input                          shift and go to state 156
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 157

    (46) loopBlock -> funcCall . ; loopBlock

    ;               shift and go to state 179


state 158

    (45) loopBlock -> loop . loopBlock
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 180
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 159

    (47) loopBlock -> output . loopBlock
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 181
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 160

    (43) loopBlock -> assign . loopBlock
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 182
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 161

    (63) while -> WHILE ( expression . ) { loopBlock }

    )               shift and go to state 183


state 162

    (58) output -> CONSOLE ( expression . ) ;

    )               shift and go to state 184


state 163

    (50) assign -> ID . possibleArray = expression ;
    (51) possibleArray -> . [ exp ]
    (52) possibleArray -> .

    [               shift and go to state 140
    =               reduce using rule 52 (possibleArray -> .)

    possibleArray                  shift and go to state 141

state 164

    (62) for -> FOR ( assign . expression ) { loopBlock }
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 185

state 165

    (30) funcCall -> ID ( parIn . )

    )               shift and go to state 186


state 166

    (51) possibleArray -> [ exp . ]

    ]               shift and go to state 187


state 167

    (50) assign -> ID possibleArray = . expression ;
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    input                          shift and go to state 37
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    bool                           shift and go to state 36
    expression                     shift and go to state 188

state 168

    (53) conditional -> IF ( expression . ) { block } possibleElif possibleElse

    )               shift and go to state 189


state 169

    (39) block -> funcCall ; block .

    }               reduce using rule 39 (block -> funcCall ; block .)
    RETURN          reduce using rule 39 (block -> funcCall ; block .)


state 170

    (28) morePar -> , type ID morePar .

    )               reduce using rule 28 (morePar -> , type ID morePar .)


state 171

    (16) moreExp -> , expression . moreExp
    (16) moreExp -> . , expression moreExp
    (17) moreExp -> .

    ,               shift and go to state 151
    }               reduce using rule 17 (moreExp -> .)

    moreExp                        shift and go to state 190

state 172

    (15) arrays -> type ID [ constant ] = { expression moreExp } . moreArray
    (18) moreArray -> . , ID [ constant ] = { expression moreExp } moreArray
    (19) moreArray -> .

    ,               shift and go to state 192
    ;               reduce using rule 19 (moreArray -> .)

    moreArray                      shift and go to state 191

state 173

    (24) returnType -> VOID .

    ;               reduce using rule 24 (returnType -> VOID .)


state 174

    (20) function -> FUNCTION funcType ID ( par ) { block RETURN returnType . ; }

    ;               shift and go to state 193


state 175

    (23) returnType -> expression .

    ;               reduce using rule 23 (returnType -> expression .)


state 176

    (44) loopBlock -> conditional loopBlock .

    }               reduce using rule 44 (loopBlock -> conditional loopBlock .)


state 177

    (64) doWhile -> DO { loopBlock } . WHILE ( expression ) ;

    WHILE           shift and go to state 194


state 178

    (48) loopBlock -> input loopBlock .

    }               reduce using rule 48 (loopBlock -> input loopBlock .)


state 179

    (46) loopBlock -> funcCall ; . loopBlock
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 195
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 180

    (45) loopBlock -> loop loopBlock .

    }               reduce using rule 45 (loopBlock -> loop loopBlock .)


state 181

    (47) loopBlock -> output loopBlock .

    }               reduce using rule 47 (loopBlock -> output loopBlock .)


state 182

    (43) loopBlock -> assign loopBlock .

    }               reduce using rule 43 (loopBlock -> assign loopBlock .)


state 183

    (63) while -> WHILE ( expression ) . { loopBlock }

    {               shift and go to state 196


state 184

    (58) output -> CONSOLE ( expression ) . ;

    ;               shift and go to state 197


state 185

    (62) for -> FOR ( assign expression . ) { loopBlock }

    )               shift and go to state 198


state 186

    (30) funcCall -> ID ( parIn ) .

    ;               reduce using rule 30 (funcCall -> ID ( parIn ) .)


state 187

    (51) possibleArray -> [ exp ] .

    =               reduce using rule 51 (possibleArray -> [ exp ] .)


state 188

    (50) assign -> ID possibleArray = expression . ;

    ;               shift and go to state 199


state 189

    (53) conditional -> IF ( expression ) . { block } possibleElif possibleElse

    {               shift and go to state 200


state 190

    (16) moreExp -> , expression moreExp .

    }               reduce using rule 16 (moreExp -> , expression moreExp .)


state 191

    (15) arrays -> type ID [ constant ] = { expression moreExp } moreArray .

    ;               reduce using rule 15 (arrays -> type ID [ constant ] = { expression moreExp } moreArray .)


state 192

    (18) moreArray -> , . ID [ constant ] = { expression moreExp } moreArray

    ID              shift and go to state 201


state 193

    (20) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; . }

    }               shift and go to state 202


state 194

    (64) doWhile -> DO { loopBlock } WHILE . ( expression ) ;

    (               shift and go to state 203


state 195

    (46) loopBlock -> funcCall ; loopBlock .

    }               reduce using rule 46 (loopBlock -> funcCall ; loopBlock .)


state 196

    (63) while -> WHILE ( expression ) { . loopBlock }
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 204
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 197

    (58) output -> CONSOLE ( expression ) ; .

    ID              reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    IF              reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    CONSOLE         reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    INPUT           reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    FOR             reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    WHILE           reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    DO              reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    }               reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    ARRAY           reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    INTTYPE         reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    FLOATTYPE       reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    STRINGTYPE      reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    BOOLTYPE        reduce using rule 58 (output -> CONSOLE ( expression ) ; .)
    RETURN          reduce using rule 58 (output -> CONSOLE ( expression ) ; .)


state 198

    (62) for -> FOR ( assign expression ) . { loopBlock }

    {               shift and go to state 205


state 199

    (50) assign -> ID possibleArray = expression ; .

    ARRAY           reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    ID              reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    IF              reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    CONSOLE         reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    INPUT           reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    FOR             reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    WHILE           reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    DO              reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    INTTYPE         reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    FLOATTYPE       reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    STRINGTYPE      reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    BOOLTYPE        reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    }               reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    RETURN          reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    (               reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    INT             reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    FLOAT           reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    STRING          reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    TRUE            reduce using rule 50 (assign -> ID possibleArray = expression ; .)
    FALSE           reduce using rule 50 (assign -> ID possibleArray = expression ; .)


state 200

    (53) conditional -> IF ( expression ) { . block } possibleElif possibleElse
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    vars                           shift and go to state 4
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 206
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 201

    (18) moreArray -> , ID . [ constant ] = { expression moreExp } moreArray

    [               shift and go to state 207


state 202

    (20) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .

    FUNCTION        reduce using rule 20 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)
    MAIN            reduce using rule 20 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)


state 203

    (64) doWhile -> DO { loopBlock } WHILE ( . expression ) ;
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    bool                           shift and go to state 36
    expression                     shift and go to state 208

state 204

    (63) while -> WHILE ( expression ) { loopBlock . }

    }               shift and go to state 209


state 205

    (62) for -> FOR ( assign expression ) { . loopBlock }
    (43) loopBlock -> . assign loopBlock
    (44) loopBlock -> . conditional loopBlock
    (45) loopBlock -> . loop loopBlock
    (46) loopBlock -> . funcCall ; loopBlock
    (47) loopBlock -> . output loopBlock
    (48) loopBlock -> . input loopBlock
    (49) loopBlock -> .
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 49 (loopBlock -> .)
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110

    funcCall                       shift and go to state 157
    conditional                    shift and go to state 154
    while                          shift and go to state 122
    for                            shift and go to state 114
    loopBlock                      shift and go to state 210
    doWhile                        shift and go to state 112
    input                          shift and go to state 156
    output                         shift and go to state 159
    assign                         shift and go to state 160
    loop                           shift and go to state 158

state 206

    (53) conditional -> IF ( expression ) { block . } possibleElif possibleElse

    }               shift and go to state 211


state 207

    (18) moreArray -> , ID [ . constant ] = { expression moreExp } moreArray
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    bool                           shift and go to state 36
    constant                       shift and go to state 212

state 208

    (64) doWhile -> DO { loopBlock } WHILE ( expression . ) ;

    )               shift and go to state 213


state 209

    (63) while -> WHILE ( expression ) { loopBlock } .

    ARRAY           reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    ID              reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    IF              reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    CONSOLE         reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    INPUT           reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    FOR             reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    WHILE           reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    DO              reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    INTTYPE         reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    FLOATTYPE       reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    STRINGTYPE      reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    BOOLTYPE        reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    }               reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)
    RETURN          reduce using rule 63 (while -> WHILE ( expression ) { loopBlock } .)


state 210

    (62) for -> FOR ( assign expression ) { loopBlock . }

    }               shift and go to state 214


state 211

    (53) conditional -> IF ( expression ) { block } . possibleElif possibleElse
    (54) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (55) possibleElif -> .

    ELIF            shift and go to state 215
    ELSE            reduce using rule 55 (possibleElif -> .)
    ARRAY           reduce using rule 55 (possibleElif -> .)
    ID              reduce using rule 55 (possibleElif -> .)
    IF              reduce using rule 55 (possibleElif -> .)
    CONSOLE         reduce using rule 55 (possibleElif -> .)
    INPUT           reduce using rule 55 (possibleElif -> .)
    FOR             reduce using rule 55 (possibleElif -> .)
    WHILE           reduce using rule 55 (possibleElif -> .)
    DO              reduce using rule 55 (possibleElif -> .)
    INTTYPE         reduce using rule 55 (possibleElif -> .)
    FLOATTYPE       reduce using rule 55 (possibleElif -> .)
    STRINGTYPE      reduce using rule 55 (possibleElif -> .)
    BOOLTYPE        reduce using rule 55 (possibleElif -> .)
    }               reduce using rule 55 (possibleElif -> .)
    RETURN          reduce using rule 55 (possibleElif -> .)

    possibleElif                   shift and go to state 216

state 212

    (18) moreArray -> , ID [ constant . ] = { expression moreExp } moreArray

    ]               shift and go to state 217


state 213

    (64) doWhile -> DO { loopBlock } WHILE ( expression ) . ;

    ;               shift and go to state 218


state 214

    (62) for -> FOR ( assign expression ) { loopBlock } .

    ID              reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    IF              reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    CONSOLE         reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    INPUT           reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    FOR             reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    WHILE           reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    DO              reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    }               reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    ARRAY           reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    INTTYPE         reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    FLOATTYPE       reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    STRINGTYPE      reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    BOOLTYPE        reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)
    RETURN          reduce using rule 62 (for -> FOR ( assign expression ) { loopBlock } .)


state 215

    (54) possibleElif -> ELIF . ( expression ) { block } possibleElif

    (               shift and go to state 219


state 216

    (53) conditional -> IF ( expression ) { block } possibleElif . possibleElse
    (56) possibleElse -> . ELSE { block }
    (57) possibleElse -> .

    ELSE            shift and go to state 221
    ARRAY           reduce using rule 57 (possibleElse -> .)
    ID              reduce using rule 57 (possibleElse -> .)
    IF              reduce using rule 57 (possibleElse -> .)
    CONSOLE         reduce using rule 57 (possibleElse -> .)
    INPUT           reduce using rule 57 (possibleElse -> .)
    FOR             reduce using rule 57 (possibleElse -> .)
    WHILE           reduce using rule 57 (possibleElse -> .)
    DO              reduce using rule 57 (possibleElse -> .)
    INTTYPE         reduce using rule 57 (possibleElse -> .)
    FLOATTYPE       reduce using rule 57 (possibleElse -> .)
    STRINGTYPE      reduce using rule 57 (possibleElse -> .)
    BOOLTYPE        reduce using rule 57 (possibleElse -> .)
    }               reduce using rule 57 (possibleElse -> .)
    RETURN          reduce using rule 57 (possibleElse -> .)

    possibleElse                   shift and go to state 220

state 217

    (18) moreArray -> , ID [ constant ] . = { expression moreExp } moreArray

    =               shift and go to state 222


state 218

    (64) doWhile -> DO { loopBlock } WHILE ( expression ) ; .

    ARRAY           reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    ID              reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    IF              reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    CONSOLE         reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INPUT           reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FOR             reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    WHILE           reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    DO              reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INTTYPE         reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FLOATTYPE       reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    STRINGTYPE      reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    BOOLTYPE        reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    }               reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    RETURN          reduce using rule 64 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)


state 219

    (54) possibleElif -> ELIF ( . expression ) { block } possibleElif
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    input                          shift and go to state 37
    higherExp                      shift and go to state 35
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    bool                           shift and go to state 36
    expression                     shift and go to state 223

state 220

    (53) conditional -> IF ( expression ) { block } possibleElif possibleElse .

    ID              reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    IF              reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    CONSOLE         reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INPUT           reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FOR             reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    WHILE           reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    DO              reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    }               reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    ARRAY           reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INTTYPE         reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FLOATTYPE       reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    STRINGTYPE      reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    BOOLTYPE        reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    RETURN          reduce using rule 53 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)


state 221

    (56) possibleElse -> ELSE . { block }

    {               shift and go to state 224


state 222

    (18) moreArray -> , ID [ constant ] = . { expression moreExp } moreArray

    {               shift and go to state 225


state 223

    (54) possibleElif -> ELIF ( expression . ) { block } possibleElif

    )               shift and go to state 226


state 224

    (56) possibleElse -> ELSE { . block }
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 227
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 225

    (18) moreArray -> , ID [ constant ] = { . expression moreExp } moreArray
    (65) expression -> . higherExp possibleHigherExp
    (70) higherExp -> . exp possibleExp
    (79) exp -> . term possibleTerms
    (84) term -> . factor possibleFactors
    (90) factor -> . ( expression )
    (91) factor -> . data
    (92) data -> . ID possibleIdCall
    (93) data -> . constant
    (94) data -> . input
    (98) constant -> . INT
    (99) constant -> . FLOAT
    (100) constant -> . bool
    (101) constant -> . STRING
    (104) input -> . INPUT ( inputPar )
    (102) bool -> . TRUE
    (103) bool -> . FALSE

    (               shift and go to state 46
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 38
    INPUT           shift and go to state 39
    TRUE            shift and go to state 33
    FALSE           shift and go to state 42

    term                           shift and go to state 41
    constant                       shift and go to state 31
    higherExp                      shift and go to state 35
    bool                           shift and go to state 36
    data                           shift and go to state 34
    exp                            shift and go to state 45
    factor                         shift and go to state 32
    input                          shift and go to state 37
    expression                     shift and go to state 228

state 226

    (54) possibleElif -> ELIF ( expression ) . { block } possibleElif

    {               shift and go to state 229


state 227

    (56) possibleElse -> ELSE { block . }

    }               shift and go to state 230


state 228

    (18) moreArray -> , ID [ constant ] = { expression . moreExp } moreArray
    (16) moreExp -> . , expression moreExp
    (17) moreExp -> .

    ,               shift and go to state 151
    }               reduce using rule 17 (moreExp -> .)

    moreExp                        shift and go to state 231

state 229

    (54) possibleElif -> ELIF ( expression ) { . block } possibleElif
    (35) block -> . varDeclar block
    (36) block -> . assign block
    (37) block -> . conditional block
    (38) block -> . loop block
    (39) block -> . funcCall ; block
    (40) block -> . output block
    (41) block -> . input block
    (42) block -> .
    (6) varDeclar -> . vars ;
    (7) varDeclar -> . ARRAY arrays ;
    (50) assign -> . ID possibleArray = expression ;
    (53) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (59) loop -> . for
    (60) loop -> . while
    (61) loop -> . doWhile
    (30) funcCall -> . ID ( parIn )
    (58) output -> . CONSOLE ( expression ) ;
    (104) input -> . INPUT ( inputPar )
    (8) vars -> . type ID = expression moreVar
    (62) for -> . FOR ( assign expression ) { loopBlock }
    (63) while -> . WHILE ( expression ) { loopBlock }
    (64) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (11) type -> . INTTYPE
    (12) type -> . FLOATTYPE
    (13) type -> . STRINGTYPE
    (14) type -> . BOOLTYPE

    }               reduce using rule 42 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 119
    IF              shift and go to state 120
    CONSOLE         shift and go to state 117
    INPUT           shift and go to state 39
    FOR             shift and go to state 118
    WHILE           shift and go to state 113
    DO              shift and go to state 110
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 111
    doWhile                        shift and go to state 112
    for                            shift and go to state 114
    input                          shift and go to state 115
    varDeclar                      shift and go to state 116
    type                           shift and go to state 9
    funcCall                       shift and go to state 121
    while                          shift and go to state 122
    block                          shift and go to state 232
    output                         shift and go to state 124
    assign                         shift and go to state 125
    loop                           shift and go to state 126

state 230

    (56) possibleElse -> ELSE { block } .

    ARRAY           reduce using rule 56 (possibleElse -> ELSE { block } .)
    ID              reduce using rule 56 (possibleElse -> ELSE { block } .)
    IF              reduce using rule 56 (possibleElse -> ELSE { block } .)
    CONSOLE         reduce using rule 56 (possibleElse -> ELSE { block } .)
    INPUT           reduce using rule 56 (possibleElse -> ELSE { block } .)
    FOR             reduce using rule 56 (possibleElse -> ELSE { block } .)
    WHILE           reduce using rule 56 (possibleElse -> ELSE { block } .)
    DO              reduce using rule 56 (possibleElse -> ELSE { block } .)
    INTTYPE         reduce using rule 56 (possibleElse -> ELSE { block } .)
    FLOATTYPE       reduce using rule 56 (possibleElse -> ELSE { block } .)
    STRINGTYPE      reduce using rule 56 (possibleElse -> ELSE { block } .)
    BOOLTYPE        reduce using rule 56 (possibleElse -> ELSE { block } .)
    }               reduce using rule 56 (possibleElse -> ELSE { block } .)
    RETURN          reduce using rule 56 (possibleElse -> ELSE { block } .)


state 231

    (18) moreArray -> , ID [ constant ] = { expression moreExp . } moreArray

    }               shift and go to state 233


state 232

    (54) possibleElif -> ELIF ( expression ) { block . } possibleElif

    }               shift and go to state 234


state 233

    (18) moreArray -> , ID [ constant ] = { expression moreExp } . moreArray
    (18) moreArray -> . , ID [ constant ] = { expression moreExp } moreArray
    (19) moreArray -> .

    ,               shift and go to state 192
    ;               reduce using rule 19 (moreArray -> .)

    moreArray                      shift and go to state 235

state 234

    (54) possibleElif -> ELIF ( expression ) { block } . possibleElif
    (54) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (55) possibleElif -> .

    ELIF            shift and go to state 215
    ELSE            reduce using rule 55 (possibleElif -> .)
    ARRAY           reduce using rule 55 (possibleElif -> .)
    ID              reduce using rule 55 (possibleElif -> .)
    IF              reduce using rule 55 (possibleElif -> .)
    CONSOLE         reduce using rule 55 (possibleElif -> .)
    INPUT           reduce using rule 55 (possibleElif -> .)
    FOR             reduce using rule 55 (possibleElif -> .)
    WHILE           reduce using rule 55 (possibleElif -> .)
    DO              reduce using rule 55 (possibleElif -> .)
    INTTYPE         reduce using rule 55 (possibleElif -> .)
    FLOATTYPE       reduce using rule 55 (possibleElif -> .)
    STRINGTYPE      reduce using rule 55 (possibleElif -> .)
    BOOLTYPE        reduce using rule 55 (possibleElif -> .)
    }               reduce using rule 55 (possibleElif -> .)
    RETURN          reduce using rule 55 (possibleElif -> .)

    possibleElif                   shift and go to state 236

state 235

    (18) moreArray -> , ID [ constant ] = { expression moreExp } moreArray .

    ;               reduce using rule 18 (moreArray -> , ID [ constant ] = { expression moreExp } moreArray .)


state 236

    (54) possibleElif -> ELIF ( expression ) { block } possibleElif .

    ELSE            reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ARRAY           reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ID              reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    IF              reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    CONSOLE         reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INPUT           reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FOR             reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    WHILE           reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    DO              reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INTTYPE         reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FLOATTYPE       reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    STRINGTYPE      reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    BOOLTYPE        reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    }               reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    RETURN          reduce using rule 54 (possibleElif -> ELIF ( expression ) { block } possibleElif .)

