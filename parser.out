Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    GLOBAL

Grammar

Rule 0     S' -> program
Rule 1     program -> globalVarDeclar functionDeclar main
Rule 2     globalVarDeclar -> initVarDeclar
Rule 3     initVarDeclar -> varDeclar initVarDeclar
Rule 4     initVarDeclar -> <empty>
Rule 5     functionDeclar -> function functionDeclar
Rule 6     functionDeclar -> <empty>
Rule 7     varDeclar -> vars ;
Rule 8     varDeclar -> ARRAY arrays ;
Rule 9     vars -> type ID = expression moreVar
Rule 10    moreVar -> , ID = expression moreVar
Rule 11    moreVar -> <empty>
Rule 12    type -> INTTYPE
Rule 13    type -> FLOATTYPE
Rule 14    type -> STRINGTYPE
Rule 15    type -> BOOLTYPE
Rule 16    arrays -> array moreArray
Rule 17    array -> type ID [ INT ] = { expression sumExpCount moreExp }
Rule 18    moreExp -> , expression sumExpCount moreExp
Rule 19    moreExp -> <empty>
Rule 20    sumExpCount -> <empty>
Rule 21    moreArray -> nextArray moreArray
Rule 22    moreArray -> <empty>
Rule 23    nextArray -> , ID [ INT ] = { expression sumExpCount moreExp }
Rule 24    function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; }
Rule 25    funcType -> INTTYPE
Rule 26    funcType -> FLOATTYPE
Rule 27    funcType -> STRINGTYPE
Rule 28    funcType -> BOOLTYPE
Rule 29    funcType -> VOID
Rule 30    returnType -> expression
Rule 31    returnType -> VOID
Rule 32    main -> MAIN ( par ) { block }
Rule 33    par -> type ID morePar
Rule 34    par -> <empty>
Rule 35    morePar -> , type ID morePar
Rule 36    morePar -> <empty>
Rule 37    funcCall -> ID ( parIn )
Rule 38    parIn -> expression moreParIn
Rule 39    parIn -> <empty>
Rule 40    moreParIn -> , expression moreParIn
Rule 41    moreParIn -> <empty>
Rule 42    block -> varDeclar block
Rule 43    block -> assign ; block
Rule 44    block -> conditional block
Rule 45    block -> loop block
Rule 46    block -> funcCall ; block
Rule 47    block -> output block
Rule 48    block -> input block
Rule 49    block -> <empty>
Rule 50    loopBlock -> assign ; loopBlock
Rule 51    loopBlock -> conditional loopBlock
Rule 52    loopBlock -> loop loopBlock
Rule 53    loopBlock -> funcCall ; loopBlock
Rule 54    loopBlock -> output loopBlock
Rule 55    loopBlock -> input loopBlock
Rule 56    loopBlock -> <empty>
Rule 57    assign -> ID possibleArray = expression
Rule 58    possibleArray -> [ exp ]
Rule 59    possibleArray -> <empty>
Rule 60    conditional -> IF ( expression ) { block } possibleElif possibleElse
Rule 61    possibleElif -> ELIF ( expression ) { block } possibleElif
Rule 62    possibleElif -> <empty>
Rule 63    possibleElse -> ELSE { block }
Rule 64    possibleElse -> <empty>
Rule 65    output -> CONSOLE ( expression ) ;
Rule 66    loop -> for
Rule 67    loop -> while
Rule 68    loop -> doWhile
Rule 69    for -> FOR ( expression ; assign ) { loopBlock }
Rule 70    while -> WHILE ( expression ) { loopBlock }
Rule 71    doWhile -> DO { loopBlock } WHILE ( expression ) ;
Rule 72    expression -> higherExp possibleHigherExp
Rule 73    possibleHigherExp -> possibleHigherExpOp higherExp
Rule 74    possibleHigherExp -> <empty>
Rule 75    possibleHigherExpOp -> AND
Rule 76    possibleHigherExpOp -> OR
Rule 77    higherExp -> exp possibleExp
Rule 78    possibleExp -> possibleExpOp exp
Rule 79    possibleExp -> <empty>
Rule 80    possibleExpOp -> LESS
Rule 81    possibleExpOp -> GREATER
Rule 82    possibleExpOp -> LESSEQUAL
Rule 83    possibleExpOp -> GREATEREQUAL
Rule 84    possibleExpOp -> DIFFERENT
Rule 85    possibleExpOp -> EQUALTO
Rule 86    exp -> possibleSign term possibleTerms
Rule 87    possibleTerms -> possibleTermOp possibleSign term possibleTerms
Rule 88    possibleTerms -> <empty>
Rule 89    possibleSign -> +
Rule 90    possibleSign -> -
Rule 91    possibleSign -> <empty>
Rule 92    possibleTermOp -> +
Rule 93    possibleTermOp -> -
Rule 94    term -> factor possibleFactors
Rule 95    possibleFactors -> possibleFactorOp factor possibleFactors
Rule 96    possibleFactors -> <empty>
Rule 97    possibleFactorOp -> *
Rule 98    possibleFactorOp -> /
Rule 99    possibleFactorOp -> %
Rule 100   factor -> lPar expression rPar
Rule 101   factor -> data
Rule 102   lPar -> (
Rule 103   rPar -> )
Rule 104   data -> ID possibleIdCall
Rule 105   data -> constant
Rule 106   data -> input
Rule 107   possibleIdCall -> [ expression ]
Rule 108   possibleIdCall -> ( parIn )
Rule 109   possibleIdCall -> <empty>
Rule 110   constant -> INT
Rule 111   constant -> FLOAT
Rule 112   constant -> TRUE
Rule 113   constant -> FALSE
Rule 114   constant -> STRING
Rule 115   input -> INPUT ( inputPar )
Rule 116   inputPar -> STRING
Rule 117   inputPar -> <empty>

Terminals, with rules where they appear

%                    : 99
(                    : 24 32 37 60 61 65 69 70 71 102 108 115
)                    : 24 32 37 60 61 65 69 70 71 103 108 115
*                    : 97
+                    : 89 92
,                    : 10 18 23 35 40
-                    : 90 93
/                    : 98
;                    : 7 8 24 43 46 50 53 65 69 71
=                    : 9 10 17 23 57
AND                  : 75
ARRAY                : 8
BOOLTYPE             : 15 28
CONSOLE              : 65
DIFFERENT            : 84
DO                   : 71
ELIF                 : 61
ELSE                 : 63
EQUALTO              : 85
FALSE                : 113
FLOAT                : 111
FLOATTYPE            : 13 26
FOR                  : 69
FUNCTION             : 24
GLOBAL               : 
GREATER              : 81
GREATEREQUAL         : 83
ID                   : 9 10 17 23 24 33 35 37 57 104
IF                   : 60
INPUT                : 115
INT                  : 17 23 110
INTTYPE              : 12 25
LESS                 : 80
LESSEQUAL            : 82
MAIN                 : 32
OR                   : 76
RETURN               : 24
STRING               : 114 116
STRINGTYPE           : 14 27
TRUE                 : 112
VOID                 : 29 31
WHILE                : 70 71
[                    : 17 23 58 107
]                    : 17 23 58 107
error                : 
{                    : 17 23 24 32 60 61 63 69 70 71
}                    : 17 23 24 32 60 61 63 69 70 71

Nonterminals, with rules where they appear

array                : 16
arrays               : 8
assign               : 43 50 69
block                : 24 32 42 43 44 45 46 47 48 60 61 63
conditional          : 44 51
constant             : 105
data                 : 101
doWhile              : 68
exp                  : 58 77 78
expression           : 9 10 17 18 23 30 38 40 57 60 61 65 69 70 71 100 107
factor               : 94 95
for                  : 66
funcCall             : 46 53
funcType             : 24
function             : 5
functionDeclar       : 1 5
globalVarDeclar      : 1
higherExp            : 72 73
initVarDeclar        : 2 3
input                : 48 55 106
inputPar             : 115
lPar                 : 100
loop                 : 45 52
loopBlock            : 50 51 52 53 54 55 69 70 71
main                 : 1
moreArray            : 16 21
moreExp              : 17 18 23
morePar              : 33 35
moreParIn            : 38 40
moreVar              : 9 10
nextArray            : 21
output               : 47 54
par                  : 24 32
parIn                : 37 108
possibleArray        : 57
possibleElif         : 60 61
possibleElse         : 60
possibleExp          : 77
possibleExpOp        : 78
possibleFactorOp     : 95
possibleFactors      : 94 95
possibleHigherExp    : 72
possibleHigherExpOp  : 73
possibleIdCall       : 104
possibleSign         : 86 87
possibleTermOp       : 87
possibleTerms        : 86 87
program              : 0
rPar                 : 100
returnType           : 24
sumExpCount          : 17 18 23
term                 : 86 87
type                 : 9 17 33 35
varDeclar            : 3 42
vars                 : 7
while                : 67

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . globalVarDeclar functionDeclar main
    (2) globalVarDeclar -> . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    FUNCTION        reduce using rule 4 (initVarDeclar -> .)
    MAIN            reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    globalVarDeclar                shift and go to state 7
    program                        shift and go to state 8
    initVarDeclar                  shift and go to state 9
    type                           shift and go to state 10
    varDeclar                      shift and go to state 11

state 1

    (15) type -> BOOLTYPE .

    ID              reduce using rule 15 (type -> BOOLTYPE .)


state 2

    (14) type -> STRINGTYPE .

    ID              reduce using rule 14 (type -> STRINGTYPE .)


state 3

    (12) type -> INTTYPE .

    ID              reduce using rule 12 (type -> INTTYPE .)


state 4

    (7) varDeclar -> vars . ;

    ;               shift and go to state 12


state 5

    (13) type -> FLOATTYPE .

    ID              reduce using rule 13 (type -> FLOATTYPE .)


state 6

    (8) varDeclar -> ARRAY . arrays ;
    (16) arrays -> . array moreArray
    (17) array -> . type ID [ INT ] = { expression sumExpCount moreExp }
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    arrays                         shift and go to state 13
    type                           shift and go to state 14
    array                          shift and go to state 15

state 7

    (1) program -> globalVarDeclar . functionDeclar main
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (24) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 17

    function                       shift and go to state 16
    functionDeclar                 shift and go to state 18

state 8

    (0) S' -> program .



state 9

    (2) globalVarDeclar -> initVarDeclar .

    FUNCTION        reduce using rule 2 (globalVarDeclar -> initVarDeclar .)
    MAIN            reduce using rule 2 (globalVarDeclar -> initVarDeclar .)


state 10

    (9) vars -> type . ID = expression moreVar

    ID              shift and go to state 19


state 11

    (3) initVarDeclar -> varDeclar . initVarDeclar
    (3) initVarDeclar -> . varDeclar initVarDeclar
    (4) initVarDeclar -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (9) vars -> . type ID = expression moreVar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    FUNCTION        reduce using rule 4 (initVarDeclar -> .)
    MAIN            reduce using rule 4 (initVarDeclar -> .)
    ARRAY           shift and go to state 6
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    initVarDeclar                  shift and go to state 20
    varDeclar                      shift and go to state 11
    type                           shift and go to state 10

state 12

    (7) varDeclar -> vars ; .

    ARRAY           reduce using rule 7 (varDeclar -> vars ; .)
    ID              reduce using rule 7 (varDeclar -> vars ; .)
    IF              reduce using rule 7 (varDeclar -> vars ; .)
    CONSOLE         reduce using rule 7 (varDeclar -> vars ; .)
    INPUT           reduce using rule 7 (varDeclar -> vars ; .)
    FOR             reduce using rule 7 (varDeclar -> vars ; .)
    WHILE           reduce using rule 7 (varDeclar -> vars ; .)
    DO              reduce using rule 7 (varDeclar -> vars ; .)
    INTTYPE         reduce using rule 7 (varDeclar -> vars ; .)
    FLOATTYPE       reduce using rule 7 (varDeclar -> vars ; .)
    STRINGTYPE      reduce using rule 7 (varDeclar -> vars ; .)
    BOOLTYPE        reduce using rule 7 (varDeclar -> vars ; .)
    }               reduce using rule 7 (varDeclar -> vars ; .)
    RETURN          reduce using rule 7 (varDeclar -> vars ; .)
    FUNCTION        reduce using rule 7 (varDeclar -> vars ; .)
    MAIN            reduce using rule 7 (varDeclar -> vars ; .)


state 13

    (8) varDeclar -> ARRAY arrays . ;

    ;               shift and go to state 21


state 14

    (17) array -> type . ID [ INT ] = { expression sumExpCount moreExp }

    ID              shift and go to state 22


state 15

    (16) arrays -> array . moreArray
    (21) moreArray -> . nextArray moreArray
    (22) moreArray -> .
    (23) nextArray -> . , ID [ INT ] = { expression sumExpCount moreExp }

    ;               reduce using rule 22 (moreArray -> .)
    ,               shift and go to state 24

    moreArray                      shift and go to state 23
    nextArray                      shift and go to state 25

state 16

    (5) functionDeclar -> function . functionDeclar
    (5) functionDeclar -> . function functionDeclar
    (6) functionDeclar -> .
    (24) function -> . FUNCTION funcType ID ( par ) { block RETURN returnType ; }

    MAIN            reduce using rule 6 (functionDeclar -> .)
    FUNCTION        shift and go to state 17

    function                       shift and go to state 16
    functionDeclar                 shift and go to state 26

state 17

    (24) function -> FUNCTION . funcType ID ( par ) { block RETURN returnType ; }
    (25) funcType -> . INTTYPE
    (26) funcType -> . FLOATTYPE
    (27) funcType -> . STRINGTYPE
    (28) funcType -> . BOOLTYPE
    (29) funcType -> . VOID

    INTTYPE         shift and go to state 32
    FLOATTYPE       shift and go to state 28
    STRINGTYPE      shift and go to state 27
    BOOLTYPE        shift and go to state 31
    VOID            shift and go to state 30

    funcType                       shift and go to state 29

state 18

    (1) program -> globalVarDeclar functionDeclar . main
    (32) main -> . MAIN ( par ) { block }

    MAIN            shift and go to state 34

    main                           shift and go to state 33

state 19

    (9) vars -> type ID . = expression moreVar

    =               shift and go to state 35


state 20

    (3) initVarDeclar -> varDeclar initVarDeclar .

    FUNCTION        reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)
    MAIN            reduce using rule 3 (initVarDeclar -> varDeclar initVarDeclar .)


state 21

    (8) varDeclar -> ARRAY arrays ; .

    ARRAY           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    ID              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    IF              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    CONSOLE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INPUT           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FOR             reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    WHILE           reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    DO              reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    INTTYPE         reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FLOATTYPE       reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    STRINGTYPE      reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    BOOLTYPE        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    }               reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    RETURN          reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    FUNCTION        reduce using rule 8 (varDeclar -> ARRAY arrays ; .)
    MAIN            reduce using rule 8 (varDeclar -> ARRAY arrays ; .)


state 22

    (17) array -> type ID . [ INT ] = { expression sumExpCount moreExp }

    [               shift and go to state 36


state 23

    (16) arrays -> array moreArray .

    ;               reduce using rule 16 (arrays -> array moreArray .)


state 24

    (23) nextArray -> , . ID [ INT ] = { expression sumExpCount moreExp }

    ID              shift and go to state 37


state 25

    (21) moreArray -> nextArray . moreArray
    (21) moreArray -> . nextArray moreArray
    (22) moreArray -> .
    (23) nextArray -> . , ID [ INT ] = { expression sumExpCount moreExp }

    ;               reduce using rule 22 (moreArray -> .)
    ,               shift and go to state 24

    moreArray                      shift and go to state 38
    nextArray                      shift and go to state 25

state 26

    (5) functionDeclar -> function functionDeclar .

    MAIN            reduce using rule 5 (functionDeclar -> function functionDeclar .)


state 27

    (27) funcType -> STRINGTYPE .

    ID              reduce using rule 27 (funcType -> STRINGTYPE .)


state 28

    (26) funcType -> FLOATTYPE .

    ID              reduce using rule 26 (funcType -> FLOATTYPE .)


state 29

    (24) function -> FUNCTION funcType . ID ( par ) { block RETURN returnType ; }

    ID              shift and go to state 39


state 30

    (29) funcType -> VOID .

    ID              reduce using rule 29 (funcType -> VOID .)


state 31

    (28) funcType -> BOOLTYPE .

    ID              reduce using rule 28 (funcType -> BOOLTYPE .)


state 32

    (25) funcType -> INTTYPE .

    ID              reduce using rule 25 (funcType -> INTTYPE .)


state 33

    (1) program -> globalVarDeclar functionDeclar main .

    $end            reduce using rule 1 (program -> globalVarDeclar functionDeclar main .)


state 34

    (32) main -> MAIN . ( par ) { block }

    (               shift and go to state 40


state 35

    (9) vars -> type ID = . expression moreVar
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 41

state 36

    (17) array -> type ID [ . INT ] = { expression sumExpCount moreExp }

    INT             shift and go to state 47


state 37

    (23) nextArray -> , ID . [ INT ] = { expression sumExpCount moreExp }

    [               shift and go to state 48


state 38

    (21) moreArray -> nextArray moreArray .

    ;               reduce using rule 21 (moreArray -> nextArray moreArray .)


state 39

    (24) function -> FUNCTION funcType ID . ( par ) { block RETURN returnType ; }

    (               shift and go to state 49


state 40

    (32) main -> MAIN ( . par ) { block }
    (33) par -> . type ID morePar
    (34) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 34 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 50
    type                           shift and go to state 51

state 41

    (9) vars -> type ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 53
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 52

state 42

    (89) possibleSign -> + .

    (               reduce using rule 89 (possibleSign -> + .)
    ID              reduce using rule 89 (possibleSign -> + .)
    INT             reduce using rule 89 (possibleSign -> + .)
    FLOAT           reduce using rule 89 (possibleSign -> + .)
    TRUE            reduce using rule 89 (possibleSign -> + .)
    FALSE           reduce using rule 89 (possibleSign -> + .)
    STRING          reduce using rule 89 (possibleSign -> + .)
    INPUT           reduce using rule 89 (possibleSign -> + .)


state 43

    (90) possibleSign -> - .

    (               reduce using rule 90 (possibleSign -> - .)
    ID              reduce using rule 90 (possibleSign -> - .)
    INT             reduce using rule 90 (possibleSign -> - .)
    FLOAT           reduce using rule 90 (possibleSign -> - .)
    TRUE            reduce using rule 90 (possibleSign -> - .)
    FALSE           reduce using rule 90 (possibleSign -> - .)
    STRING          reduce using rule 90 (possibleSign -> - .)
    INPUT           reduce using rule 90 (possibleSign -> - .)


state 44

    (72) expression -> higherExp . possibleHigherExp
    (73) possibleHigherExp -> . possibleHigherExpOp higherExp
    (74) possibleHigherExp -> .
    (75) possibleHigherExpOp -> . AND
    (76) possibleHigherExpOp -> . OR

    ,               reduce using rule 74 (possibleHigherExp -> .)
    ;               reduce using rule 74 (possibleHigherExp -> .)
    )               reduce using rule 74 (possibleHigherExp -> .)
    ]               reduce using rule 74 (possibleHigherExp -> .)
    }               reduce using rule 74 (possibleHigherExp -> .)
    AND             shift and go to state 54
    OR              shift and go to state 57

    possibleHigherExpOp            shift and go to state 55
    possibleHigherExp              shift and go to state 56

state 45

    (86) exp -> possibleSign . term possibleTerms
    (94) term -> . factor possibleFactors
    (100) factor -> . lPar expression rPar
    (101) factor -> . data
    (102) lPar -> . (
    (104) data -> . ID possibleIdCall
    (105) data -> . constant
    (106) data -> . input
    (110) constant -> . INT
    (111) constant -> . FLOAT
    (112) constant -> . TRUE
    (113) constant -> . FALSE
    (114) constant -> . STRING
    (115) input -> . INPUT ( inputPar )

    (               shift and go to state 71
    ID              shift and go to state 62
    INT             shift and go to state 69
    FLOAT           shift and go to state 70
    TRUE            shift and go to state 59
    FALSE           shift and go to state 68
    STRING          shift and go to state 65
    INPUT           shift and go to state 66

    lPar                           shift and go to state 60
    term                           shift and go to state 67
    constant                       shift and go to state 58
    data                           shift and go to state 61
    factor                         shift and go to state 63
    input                          shift and go to state 64

state 46

    (77) higherExp -> exp . possibleExp
    (78) possibleExp -> . possibleExpOp exp
    (79) possibleExp -> .
    (80) possibleExpOp -> . LESS
    (81) possibleExpOp -> . GREATER
    (82) possibleExpOp -> . LESSEQUAL
    (83) possibleExpOp -> . GREATEREQUAL
    (84) possibleExpOp -> . DIFFERENT
    (85) possibleExpOp -> . EQUALTO

    AND             reduce using rule 79 (possibleExp -> .)
    OR              reduce using rule 79 (possibleExp -> .)
    ,               reduce using rule 79 (possibleExp -> .)
    ;               reduce using rule 79 (possibleExp -> .)
    )               reduce using rule 79 (possibleExp -> .)
    ]               reduce using rule 79 (possibleExp -> .)
    }               reduce using rule 79 (possibleExp -> .)
    LESS            shift and go to state 75
    GREATER         shift and go to state 73
    LESSEQUAL       shift and go to state 79
    GREATEREQUAL    shift and go to state 72
    DIFFERENT       shift and go to state 78
    EQUALTO         shift and go to state 77

    possibleExp                    shift and go to state 76
    possibleExpOp                  shift and go to state 74

state 47

    (17) array -> type ID [ INT . ] = { expression sumExpCount moreExp }

    ]               shift and go to state 80


state 48

    (23) nextArray -> , ID [ . INT ] = { expression sumExpCount moreExp }

    INT             shift and go to state 81


state 49

    (24) function -> FUNCTION funcType ID ( . par ) { block RETURN returnType ; }
    (33) par -> . type ID morePar
    (34) par -> .
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    )               reduce using rule 34 (par -> .)
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    par                            shift and go to state 82
    type                           shift and go to state 51

state 50

    (32) main -> MAIN ( par . ) { block }

    )               shift and go to state 83


state 51

    (33) par -> type . ID morePar

    ID              shift and go to state 84


state 52

    (9) vars -> type ID = expression moreVar .

    ;               reduce using rule 9 (vars -> type ID = expression moreVar .)


state 53

    (10) moreVar -> , . ID = expression moreVar

    ID              shift and go to state 85


state 54

    (75) possibleHigherExpOp -> AND .

    +               reduce using rule 75 (possibleHigherExpOp -> AND .)
    -               reduce using rule 75 (possibleHigherExpOp -> AND .)
    (               reduce using rule 75 (possibleHigherExpOp -> AND .)
    ID              reduce using rule 75 (possibleHigherExpOp -> AND .)
    INT             reduce using rule 75 (possibleHigherExpOp -> AND .)
    FLOAT           reduce using rule 75 (possibleHigherExpOp -> AND .)
    TRUE            reduce using rule 75 (possibleHigherExpOp -> AND .)
    FALSE           reduce using rule 75 (possibleHigherExpOp -> AND .)
    STRING          reduce using rule 75 (possibleHigherExpOp -> AND .)
    INPUT           reduce using rule 75 (possibleHigherExpOp -> AND .)


state 55

    (73) possibleHigherExp -> possibleHigherExpOp . higherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 86
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46

state 56

    (72) expression -> higherExp possibleHigherExp .

    )               reduce using rule 72 (expression -> higherExp possibleHigherExp .)
    ;               reduce using rule 72 (expression -> higherExp possibleHigherExp .)
    ,               reduce using rule 72 (expression -> higherExp possibleHigherExp .)
    }               reduce using rule 72 (expression -> higherExp possibleHigherExp .)
    ]               reduce using rule 72 (expression -> higherExp possibleHigherExp .)


state 57

    (76) possibleHigherExpOp -> OR .

    +               reduce using rule 76 (possibleHigherExpOp -> OR .)
    -               reduce using rule 76 (possibleHigherExpOp -> OR .)
    (               reduce using rule 76 (possibleHigherExpOp -> OR .)
    ID              reduce using rule 76 (possibleHigherExpOp -> OR .)
    INT             reduce using rule 76 (possibleHigherExpOp -> OR .)
    FLOAT           reduce using rule 76 (possibleHigherExpOp -> OR .)
    TRUE            reduce using rule 76 (possibleHigherExpOp -> OR .)
    FALSE           reduce using rule 76 (possibleHigherExpOp -> OR .)
    STRING          reduce using rule 76 (possibleHigherExpOp -> OR .)
    INPUT           reduce using rule 76 (possibleHigherExpOp -> OR .)


state 58

    (105) data -> constant .

    *               reduce using rule 105 (data -> constant .)
    /               reduce using rule 105 (data -> constant .)
    %               reduce using rule 105 (data -> constant .)
    +               reduce using rule 105 (data -> constant .)
    -               reduce using rule 105 (data -> constant .)
    LESS            reduce using rule 105 (data -> constant .)
    GREATER         reduce using rule 105 (data -> constant .)
    LESSEQUAL       reduce using rule 105 (data -> constant .)
    GREATEREQUAL    reduce using rule 105 (data -> constant .)
    DIFFERENT       reduce using rule 105 (data -> constant .)
    EQUALTO         reduce using rule 105 (data -> constant .)
    AND             reduce using rule 105 (data -> constant .)
    OR              reduce using rule 105 (data -> constant .)
    ,               reduce using rule 105 (data -> constant .)
    ;               reduce using rule 105 (data -> constant .)
    )               reduce using rule 105 (data -> constant .)
    ]               reduce using rule 105 (data -> constant .)
    }               reduce using rule 105 (data -> constant .)


state 59

    (112) constant -> TRUE .

    *               reduce using rule 112 (constant -> TRUE .)
    /               reduce using rule 112 (constant -> TRUE .)
    %               reduce using rule 112 (constant -> TRUE .)
    +               reduce using rule 112 (constant -> TRUE .)
    -               reduce using rule 112 (constant -> TRUE .)
    LESS            reduce using rule 112 (constant -> TRUE .)
    GREATER         reduce using rule 112 (constant -> TRUE .)
    LESSEQUAL       reduce using rule 112 (constant -> TRUE .)
    GREATEREQUAL    reduce using rule 112 (constant -> TRUE .)
    DIFFERENT       reduce using rule 112 (constant -> TRUE .)
    EQUALTO         reduce using rule 112 (constant -> TRUE .)
    AND             reduce using rule 112 (constant -> TRUE .)
    OR              reduce using rule 112 (constant -> TRUE .)
    ,               reduce using rule 112 (constant -> TRUE .)
    ;               reduce using rule 112 (constant -> TRUE .)
    )               reduce using rule 112 (constant -> TRUE .)
    ]               reduce using rule 112 (constant -> TRUE .)
    }               reduce using rule 112 (constant -> TRUE .)


state 60

    (100) factor -> lPar . expression rPar
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 87

state 61

    (101) factor -> data .

    *               reduce using rule 101 (factor -> data .)
    /               reduce using rule 101 (factor -> data .)
    %               reduce using rule 101 (factor -> data .)
    +               reduce using rule 101 (factor -> data .)
    -               reduce using rule 101 (factor -> data .)
    LESS            reduce using rule 101 (factor -> data .)
    GREATER         reduce using rule 101 (factor -> data .)
    LESSEQUAL       reduce using rule 101 (factor -> data .)
    GREATEREQUAL    reduce using rule 101 (factor -> data .)
    DIFFERENT       reduce using rule 101 (factor -> data .)
    EQUALTO         reduce using rule 101 (factor -> data .)
    AND             reduce using rule 101 (factor -> data .)
    OR              reduce using rule 101 (factor -> data .)
    ,               reduce using rule 101 (factor -> data .)
    ;               reduce using rule 101 (factor -> data .)
    )               reduce using rule 101 (factor -> data .)
    ]               reduce using rule 101 (factor -> data .)
    }               reduce using rule 101 (factor -> data .)


state 62

    (104) data -> ID . possibleIdCall
    (107) possibleIdCall -> . [ expression ]
    (108) possibleIdCall -> . ( parIn )
    (109) possibleIdCall -> .

    [               shift and go to state 90
    (               shift and go to state 89
    *               reduce using rule 109 (possibleIdCall -> .)
    /               reduce using rule 109 (possibleIdCall -> .)
    %               reduce using rule 109 (possibleIdCall -> .)
    +               reduce using rule 109 (possibleIdCall -> .)
    -               reduce using rule 109 (possibleIdCall -> .)
    LESS            reduce using rule 109 (possibleIdCall -> .)
    GREATER         reduce using rule 109 (possibleIdCall -> .)
    LESSEQUAL       reduce using rule 109 (possibleIdCall -> .)
    GREATEREQUAL    reduce using rule 109 (possibleIdCall -> .)
    DIFFERENT       reduce using rule 109 (possibleIdCall -> .)
    EQUALTO         reduce using rule 109 (possibleIdCall -> .)
    AND             reduce using rule 109 (possibleIdCall -> .)
    OR              reduce using rule 109 (possibleIdCall -> .)
    ,               reduce using rule 109 (possibleIdCall -> .)
    ;               reduce using rule 109 (possibleIdCall -> .)
    )               reduce using rule 109 (possibleIdCall -> .)
    ]               reduce using rule 109 (possibleIdCall -> .)
    }               reduce using rule 109 (possibleIdCall -> .)

    possibleIdCall                 shift and go to state 88

state 63

    (94) term -> factor . possibleFactors
    (95) possibleFactors -> . possibleFactorOp factor possibleFactors
    (96) possibleFactors -> .
    (97) possibleFactorOp -> . *
    (98) possibleFactorOp -> . /
    (99) possibleFactorOp -> . %

    +               reduce using rule 96 (possibleFactors -> .)
    -               reduce using rule 96 (possibleFactors -> .)
    LESS            reduce using rule 96 (possibleFactors -> .)
    GREATER         reduce using rule 96 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 96 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 96 (possibleFactors -> .)
    DIFFERENT       reduce using rule 96 (possibleFactors -> .)
    EQUALTO         reduce using rule 96 (possibleFactors -> .)
    AND             reduce using rule 96 (possibleFactors -> .)
    OR              reduce using rule 96 (possibleFactors -> .)
    ,               reduce using rule 96 (possibleFactors -> .)
    ;               reduce using rule 96 (possibleFactors -> .)
    )               reduce using rule 96 (possibleFactors -> .)
    ]               reduce using rule 96 (possibleFactors -> .)
    }               reduce using rule 96 (possibleFactors -> .)
    *               shift and go to state 92
    /               shift and go to state 94
    %               shift and go to state 91

    possibleFactors                shift and go to state 93
    possibleFactorOp               shift and go to state 95

state 64

    (106) data -> input .

    *               reduce using rule 106 (data -> input .)
    /               reduce using rule 106 (data -> input .)
    %               reduce using rule 106 (data -> input .)
    +               reduce using rule 106 (data -> input .)
    -               reduce using rule 106 (data -> input .)
    LESS            reduce using rule 106 (data -> input .)
    GREATER         reduce using rule 106 (data -> input .)
    LESSEQUAL       reduce using rule 106 (data -> input .)
    GREATEREQUAL    reduce using rule 106 (data -> input .)
    DIFFERENT       reduce using rule 106 (data -> input .)
    EQUALTO         reduce using rule 106 (data -> input .)
    AND             reduce using rule 106 (data -> input .)
    OR              reduce using rule 106 (data -> input .)
    ,               reduce using rule 106 (data -> input .)
    ;               reduce using rule 106 (data -> input .)
    )               reduce using rule 106 (data -> input .)
    ]               reduce using rule 106 (data -> input .)
    }               reduce using rule 106 (data -> input .)


state 65

    (114) constant -> STRING .

    *               reduce using rule 114 (constant -> STRING .)
    /               reduce using rule 114 (constant -> STRING .)
    %               reduce using rule 114 (constant -> STRING .)
    +               reduce using rule 114 (constant -> STRING .)
    -               reduce using rule 114 (constant -> STRING .)
    LESS            reduce using rule 114 (constant -> STRING .)
    GREATER         reduce using rule 114 (constant -> STRING .)
    LESSEQUAL       reduce using rule 114 (constant -> STRING .)
    GREATEREQUAL    reduce using rule 114 (constant -> STRING .)
    DIFFERENT       reduce using rule 114 (constant -> STRING .)
    EQUALTO         reduce using rule 114 (constant -> STRING .)
    AND             reduce using rule 114 (constant -> STRING .)
    OR              reduce using rule 114 (constant -> STRING .)
    ,               reduce using rule 114 (constant -> STRING .)
    ;               reduce using rule 114 (constant -> STRING .)
    )               reduce using rule 114 (constant -> STRING .)
    ]               reduce using rule 114 (constant -> STRING .)
    }               reduce using rule 114 (constant -> STRING .)


state 66

    (115) input -> INPUT . ( inputPar )

    (               shift and go to state 96


state 67

    (86) exp -> possibleSign term . possibleTerms
    (87) possibleTerms -> . possibleTermOp possibleSign term possibleTerms
    (88) possibleTerms -> .
    (92) possibleTermOp -> . +
    (93) possibleTermOp -> . -

    LESS            reduce using rule 88 (possibleTerms -> .)
    GREATER         reduce using rule 88 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 88 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 88 (possibleTerms -> .)
    DIFFERENT       reduce using rule 88 (possibleTerms -> .)
    EQUALTO         reduce using rule 88 (possibleTerms -> .)
    AND             reduce using rule 88 (possibleTerms -> .)
    OR              reduce using rule 88 (possibleTerms -> .)
    ,               reduce using rule 88 (possibleTerms -> .)
    ;               reduce using rule 88 (possibleTerms -> .)
    )               reduce using rule 88 (possibleTerms -> .)
    ]               reduce using rule 88 (possibleTerms -> .)
    }               reduce using rule 88 (possibleTerms -> .)
    +               shift and go to state 97
    -               shift and go to state 99

    possibleTermOp                 shift and go to state 100
    possibleTerms                  shift and go to state 98

state 68

    (113) constant -> FALSE .

    *               reduce using rule 113 (constant -> FALSE .)
    /               reduce using rule 113 (constant -> FALSE .)
    %               reduce using rule 113 (constant -> FALSE .)
    +               reduce using rule 113 (constant -> FALSE .)
    -               reduce using rule 113 (constant -> FALSE .)
    LESS            reduce using rule 113 (constant -> FALSE .)
    GREATER         reduce using rule 113 (constant -> FALSE .)
    LESSEQUAL       reduce using rule 113 (constant -> FALSE .)
    GREATEREQUAL    reduce using rule 113 (constant -> FALSE .)
    DIFFERENT       reduce using rule 113 (constant -> FALSE .)
    EQUALTO         reduce using rule 113 (constant -> FALSE .)
    AND             reduce using rule 113 (constant -> FALSE .)
    OR              reduce using rule 113 (constant -> FALSE .)
    ,               reduce using rule 113 (constant -> FALSE .)
    ;               reduce using rule 113 (constant -> FALSE .)
    )               reduce using rule 113 (constant -> FALSE .)
    ]               reduce using rule 113 (constant -> FALSE .)
    }               reduce using rule 113 (constant -> FALSE .)


state 69

    (110) constant -> INT .

    *               reduce using rule 110 (constant -> INT .)
    /               reduce using rule 110 (constant -> INT .)
    %               reduce using rule 110 (constant -> INT .)
    +               reduce using rule 110 (constant -> INT .)
    -               reduce using rule 110 (constant -> INT .)
    LESS            reduce using rule 110 (constant -> INT .)
    GREATER         reduce using rule 110 (constant -> INT .)
    LESSEQUAL       reduce using rule 110 (constant -> INT .)
    GREATEREQUAL    reduce using rule 110 (constant -> INT .)
    DIFFERENT       reduce using rule 110 (constant -> INT .)
    EQUALTO         reduce using rule 110 (constant -> INT .)
    AND             reduce using rule 110 (constant -> INT .)
    OR              reduce using rule 110 (constant -> INT .)
    ,               reduce using rule 110 (constant -> INT .)
    ;               reduce using rule 110 (constant -> INT .)
    )               reduce using rule 110 (constant -> INT .)
    ]               reduce using rule 110 (constant -> INT .)
    }               reduce using rule 110 (constant -> INT .)


state 70

    (111) constant -> FLOAT .

    *               reduce using rule 111 (constant -> FLOAT .)
    /               reduce using rule 111 (constant -> FLOAT .)
    %               reduce using rule 111 (constant -> FLOAT .)
    +               reduce using rule 111 (constant -> FLOAT .)
    -               reduce using rule 111 (constant -> FLOAT .)
    LESS            reduce using rule 111 (constant -> FLOAT .)
    GREATER         reduce using rule 111 (constant -> FLOAT .)
    LESSEQUAL       reduce using rule 111 (constant -> FLOAT .)
    GREATEREQUAL    reduce using rule 111 (constant -> FLOAT .)
    DIFFERENT       reduce using rule 111 (constant -> FLOAT .)
    EQUALTO         reduce using rule 111 (constant -> FLOAT .)
    AND             reduce using rule 111 (constant -> FLOAT .)
    OR              reduce using rule 111 (constant -> FLOAT .)
    ,               reduce using rule 111 (constant -> FLOAT .)
    ;               reduce using rule 111 (constant -> FLOAT .)
    )               reduce using rule 111 (constant -> FLOAT .)
    ]               reduce using rule 111 (constant -> FLOAT .)
    }               reduce using rule 111 (constant -> FLOAT .)


state 71

    (102) lPar -> ( .

    +               reduce using rule 102 (lPar -> ( .)
    -               reduce using rule 102 (lPar -> ( .)
    (               reduce using rule 102 (lPar -> ( .)
    ID              reduce using rule 102 (lPar -> ( .)
    INT             reduce using rule 102 (lPar -> ( .)
    FLOAT           reduce using rule 102 (lPar -> ( .)
    TRUE            reduce using rule 102 (lPar -> ( .)
    FALSE           reduce using rule 102 (lPar -> ( .)
    STRING          reduce using rule 102 (lPar -> ( .)
    INPUT           reduce using rule 102 (lPar -> ( .)


state 72

    (83) possibleExpOp -> GREATEREQUAL .

    +               reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    -               reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    (               reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    ID              reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    INT             reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    FLOAT           reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    TRUE            reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    FALSE           reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    STRING          reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)
    INPUT           reduce using rule 83 (possibleExpOp -> GREATEREQUAL .)


state 73

    (81) possibleExpOp -> GREATER .

    +               reduce using rule 81 (possibleExpOp -> GREATER .)
    -               reduce using rule 81 (possibleExpOp -> GREATER .)
    (               reduce using rule 81 (possibleExpOp -> GREATER .)
    ID              reduce using rule 81 (possibleExpOp -> GREATER .)
    INT             reduce using rule 81 (possibleExpOp -> GREATER .)
    FLOAT           reduce using rule 81 (possibleExpOp -> GREATER .)
    TRUE            reduce using rule 81 (possibleExpOp -> GREATER .)
    FALSE           reduce using rule 81 (possibleExpOp -> GREATER .)
    STRING          reduce using rule 81 (possibleExpOp -> GREATER .)
    INPUT           reduce using rule 81 (possibleExpOp -> GREATER .)


state 74

    (78) possibleExp -> possibleExpOp . exp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    possibleSign                   shift and go to state 45
    exp                            shift and go to state 101

state 75

    (80) possibleExpOp -> LESS .

    +               reduce using rule 80 (possibleExpOp -> LESS .)
    -               reduce using rule 80 (possibleExpOp -> LESS .)
    (               reduce using rule 80 (possibleExpOp -> LESS .)
    ID              reduce using rule 80 (possibleExpOp -> LESS .)
    INT             reduce using rule 80 (possibleExpOp -> LESS .)
    FLOAT           reduce using rule 80 (possibleExpOp -> LESS .)
    TRUE            reduce using rule 80 (possibleExpOp -> LESS .)
    FALSE           reduce using rule 80 (possibleExpOp -> LESS .)
    STRING          reduce using rule 80 (possibleExpOp -> LESS .)
    INPUT           reduce using rule 80 (possibleExpOp -> LESS .)


state 76

    (77) higherExp -> exp possibleExp .

    AND             reduce using rule 77 (higherExp -> exp possibleExp .)
    OR              reduce using rule 77 (higherExp -> exp possibleExp .)
    )               reduce using rule 77 (higherExp -> exp possibleExp .)
    ;               reduce using rule 77 (higherExp -> exp possibleExp .)
    ]               reduce using rule 77 (higherExp -> exp possibleExp .)
    ,               reduce using rule 77 (higherExp -> exp possibleExp .)
    }               reduce using rule 77 (higherExp -> exp possibleExp .)


state 77

    (85) possibleExpOp -> EQUALTO .

    +               reduce using rule 85 (possibleExpOp -> EQUALTO .)
    -               reduce using rule 85 (possibleExpOp -> EQUALTO .)
    (               reduce using rule 85 (possibleExpOp -> EQUALTO .)
    ID              reduce using rule 85 (possibleExpOp -> EQUALTO .)
    INT             reduce using rule 85 (possibleExpOp -> EQUALTO .)
    FLOAT           reduce using rule 85 (possibleExpOp -> EQUALTO .)
    TRUE            reduce using rule 85 (possibleExpOp -> EQUALTO .)
    FALSE           reduce using rule 85 (possibleExpOp -> EQUALTO .)
    STRING          reduce using rule 85 (possibleExpOp -> EQUALTO .)
    INPUT           reduce using rule 85 (possibleExpOp -> EQUALTO .)


state 78

    (84) possibleExpOp -> DIFFERENT .

    +               reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    -               reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    (               reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    ID              reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    INT             reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    FLOAT           reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    TRUE            reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    FALSE           reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    STRING          reduce using rule 84 (possibleExpOp -> DIFFERENT .)
    INPUT           reduce using rule 84 (possibleExpOp -> DIFFERENT .)


state 79

    (82) possibleExpOp -> LESSEQUAL .

    +               reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    -               reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    (               reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    ID              reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    INT             reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    FLOAT           reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    TRUE            reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    FALSE           reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    STRING          reduce using rule 82 (possibleExpOp -> LESSEQUAL .)
    INPUT           reduce using rule 82 (possibleExpOp -> LESSEQUAL .)


state 80

    (17) array -> type ID [ INT ] . = { expression sumExpCount moreExp }

    =               shift and go to state 102


state 81

    (23) nextArray -> , ID [ INT . ] = { expression sumExpCount moreExp }

    ]               shift and go to state 103


state 82

    (24) function -> FUNCTION funcType ID ( par . ) { block RETURN returnType ; }

    )               shift and go to state 104


state 83

    (32) main -> MAIN ( par ) . { block }

    {               shift and go to state 105


state 84

    (33) par -> type ID . morePar
    (35) morePar -> . , type ID morePar
    (36) morePar -> .

    ,               shift and go to state 107
    )               reduce using rule 36 (morePar -> .)

    morePar                        shift and go to state 106

state 85

    (10) moreVar -> , ID . = expression moreVar

    =               shift and go to state 108


state 86

    (73) possibleHigherExp -> possibleHigherExpOp higherExp .

    ,               reduce using rule 73 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ;               reduce using rule 73 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    )               reduce using rule 73 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    ]               reduce using rule 73 (possibleHigherExp -> possibleHigherExpOp higherExp .)
    }               reduce using rule 73 (possibleHigherExp -> possibleHigherExpOp higherExp .)


state 87

    (100) factor -> lPar expression . rPar
    (103) rPar -> . )

    )               shift and go to state 109

    rPar                           shift and go to state 110

state 88

    (104) data -> ID possibleIdCall .

    *               reduce using rule 104 (data -> ID possibleIdCall .)
    /               reduce using rule 104 (data -> ID possibleIdCall .)
    %               reduce using rule 104 (data -> ID possibleIdCall .)
    +               reduce using rule 104 (data -> ID possibleIdCall .)
    -               reduce using rule 104 (data -> ID possibleIdCall .)
    LESS            reduce using rule 104 (data -> ID possibleIdCall .)
    GREATER         reduce using rule 104 (data -> ID possibleIdCall .)
    LESSEQUAL       reduce using rule 104 (data -> ID possibleIdCall .)
    GREATEREQUAL    reduce using rule 104 (data -> ID possibleIdCall .)
    DIFFERENT       reduce using rule 104 (data -> ID possibleIdCall .)
    EQUALTO         reduce using rule 104 (data -> ID possibleIdCall .)
    AND             reduce using rule 104 (data -> ID possibleIdCall .)
    OR              reduce using rule 104 (data -> ID possibleIdCall .)
    ,               reduce using rule 104 (data -> ID possibleIdCall .)
    ;               reduce using rule 104 (data -> ID possibleIdCall .)
    )               reduce using rule 104 (data -> ID possibleIdCall .)
    ]               reduce using rule 104 (data -> ID possibleIdCall .)
    }               reduce using rule 104 (data -> ID possibleIdCall .)


state 89

    (108) possibleIdCall -> ( . parIn )
    (38) parIn -> . expression moreParIn
    (39) parIn -> .
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    )               reduce using rule 39 (parIn -> .)
    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    parIn                          shift and go to state 111
    exp                            shift and go to state 46
    expression                     shift and go to state 112

state 90

    (107) possibleIdCall -> [ . expression ]
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 113

state 91

    (99) possibleFactorOp -> % .

    (               reduce using rule 99 (possibleFactorOp -> % .)
    ID              reduce using rule 99 (possibleFactorOp -> % .)
    INT             reduce using rule 99 (possibleFactorOp -> % .)
    FLOAT           reduce using rule 99 (possibleFactorOp -> % .)
    TRUE            reduce using rule 99 (possibleFactorOp -> % .)
    FALSE           reduce using rule 99 (possibleFactorOp -> % .)
    STRING          reduce using rule 99 (possibleFactorOp -> % .)
    INPUT           reduce using rule 99 (possibleFactorOp -> % .)


state 92

    (97) possibleFactorOp -> * .

    (               reduce using rule 97 (possibleFactorOp -> * .)
    ID              reduce using rule 97 (possibleFactorOp -> * .)
    INT             reduce using rule 97 (possibleFactorOp -> * .)
    FLOAT           reduce using rule 97 (possibleFactorOp -> * .)
    TRUE            reduce using rule 97 (possibleFactorOp -> * .)
    FALSE           reduce using rule 97 (possibleFactorOp -> * .)
    STRING          reduce using rule 97 (possibleFactorOp -> * .)
    INPUT           reduce using rule 97 (possibleFactorOp -> * .)


state 93

    (94) term -> factor possibleFactors .

    +               reduce using rule 94 (term -> factor possibleFactors .)
    -               reduce using rule 94 (term -> factor possibleFactors .)
    LESS            reduce using rule 94 (term -> factor possibleFactors .)
    GREATER         reduce using rule 94 (term -> factor possibleFactors .)
    LESSEQUAL       reduce using rule 94 (term -> factor possibleFactors .)
    GREATEREQUAL    reduce using rule 94 (term -> factor possibleFactors .)
    DIFFERENT       reduce using rule 94 (term -> factor possibleFactors .)
    EQUALTO         reduce using rule 94 (term -> factor possibleFactors .)
    AND             reduce using rule 94 (term -> factor possibleFactors .)
    OR              reduce using rule 94 (term -> factor possibleFactors .)
    ,               reduce using rule 94 (term -> factor possibleFactors .)
    ;               reduce using rule 94 (term -> factor possibleFactors .)
    )               reduce using rule 94 (term -> factor possibleFactors .)
    ]               reduce using rule 94 (term -> factor possibleFactors .)
    }               reduce using rule 94 (term -> factor possibleFactors .)


state 94

    (98) possibleFactorOp -> / .

    (               reduce using rule 98 (possibleFactorOp -> / .)
    ID              reduce using rule 98 (possibleFactorOp -> / .)
    INT             reduce using rule 98 (possibleFactorOp -> / .)
    FLOAT           reduce using rule 98 (possibleFactorOp -> / .)
    TRUE            reduce using rule 98 (possibleFactorOp -> / .)
    FALSE           reduce using rule 98 (possibleFactorOp -> / .)
    STRING          reduce using rule 98 (possibleFactorOp -> / .)
    INPUT           reduce using rule 98 (possibleFactorOp -> / .)


state 95

    (95) possibleFactors -> possibleFactorOp . factor possibleFactors
    (100) factor -> . lPar expression rPar
    (101) factor -> . data
    (102) lPar -> . (
    (104) data -> . ID possibleIdCall
    (105) data -> . constant
    (106) data -> . input
    (110) constant -> . INT
    (111) constant -> . FLOAT
    (112) constant -> . TRUE
    (113) constant -> . FALSE
    (114) constant -> . STRING
    (115) input -> . INPUT ( inputPar )

    (               shift and go to state 71
    ID              shift and go to state 62
    INT             shift and go to state 69
    FLOAT           shift and go to state 70
    TRUE            shift and go to state 59
    FALSE           shift and go to state 68
    STRING          shift and go to state 65
    INPUT           shift and go to state 66

    lPar                           shift and go to state 60
    constant                       shift and go to state 58
    data                           shift and go to state 61
    factor                         shift and go to state 114
    input                          shift and go to state 64

state 96

    (115) input -> INPUT ( . inputPar )
    (116) inputPar -> . STRING
    (117) inputPar -> .

    STRING          shift and go to state 115
    )               reduce using rule 117 (inputPar -> .)

    inputPar                       shift and go to state 116

state 97

    (92) possibleTermOp -> + .

    +               reduce using rule 92 (possibleTermOp -> + .)
    -               reduce using rule 92 (possibleTermOp -> + .)
    (               reduce using rule 92 (possibleTermOp -> + .)
    ID              reduce using rule 92 (possibleTermOp -> + .)
    INT             reduce using rule 92 (possibleTermOp -> + .)
    FLOAT           reduce using rule 92 (possibleTermOp -> + .)
    TRUE            reduce using rule 92 (possibleTermOp -> + .)
    FALSE           reduce using rule 92 (possibleTermOp -> + .)
    STRING          reduce using rule 92 (possibleTermOp -> + .)
    INPUT           reduce using rule 92 (possibleTermOp -> + .)


state 98

    (86) exp -> possibleSign term possibleTerms .

    LESS            reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    GREATER         reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    LESSEQUAL       reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    GREATEREQUAL    reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    DIFFERENT       reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    EQUALTO         reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    AND             reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    OR              reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    ,               reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    )               reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    ;               reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    ]               reduce using rule 86 (exp -> possibleSign term possibleTerms .)
    }               reduce using rule 86 (exp -> possibleSign term possibleTerms .)


state 99

    (93) possibleTermOp -> - .

    +               reduce using rule 93 (possibleTermOp -> - .)
    -               reduce using rule 93 (possibleTermOp -> - .)
    (               reduce using rule 93 (possibleTermOp -> - .)
    ID              reduce using rule 93 (possibleTermOp -> - .)
    INT             reduce using rule 93 (possibleTermOp -> - .)
    FLOAT           reduce using rule 93 (possibleTermOp -> - .)
    TRUE            reduce using rule 93 (possibleTermOp -> - .)
    FALSE           reduce using rule 93 (possibleTermOp -> - .)
    STRING          reduce using rule 93 (possibleTermOp -> - .)
    INPUT           reduce using rule 93 (possibleTermOp -> - .)


state 100

    (87) possibleTerms -> possibleTermOp . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    possibleSign                   shift and go to state 117

state 101

    (78) possibleExp -> possibleExpOp exp .

    AND             reduce using rule 78 (possibleExp -> possibleExpOp exp .)
    OR              reduce using rule 78 (possibleExp -> possibleExpOp exp .)
    ,               reduce using rule 78 (possibleExp -> possibleExpOp exp .)
    ;               reduce using rule 78 (possibleExp -> possibleExpOp exp .)
    )               reduce using rule 78 (possibleExp -> possibleExpOp exp .)
    ]               reduce using rule 78 (possibleExp -> possibleExpOp exp .)
    }               reduce using rule 78 (possibleExp -> possibleExpOp exp .)


state 102

    (17) array -> type ID [ INT ] = . { expression sumExpCount moreExp }

    {               shift and go to state 118


state 103

    (23) nextArray -> , ID [ INT ] . = { expression sumExpCount moreExp }

    =               shift and go to state 119


state 104

    (24) function -> FUNCTION funcType ID ( par ) . { block RETURN returnType ; }

    {               shift and go to state 120


state 105

    (32) main -> MAIN ( par ) { . block }
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 134
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 106

    (33) par -> type ID morePar .

    )               reduce using rule 33 (par -> type ID morePar .)


state 107

    (35) morePar -> , . type ID morePar
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    type                           shift and go to state 138

state 108

    (10) moreVar -> , ID = . expression moreVar
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 139

state 109

    (103) rPar -> ) .

    *               reduce using rule 103 (rPar -> ) .)
    /               reduce using rule 103 (rPar -> ) .)
    %               reduce using rule 103 (rPar -> ) .)
    +               reduce using rule 103 (rPar -> ) .)
    -               reduce using rule 103 (rPar -> ) .)
    LESS            reduce using rule 103 (rPar -> ) .)
    GREATER         reduce using rule 103 (rPar -> ) .)
    LESSEQUAL       reduce using rule 103 (rPar -> ) .)
    GREATEREQUAL    reduce using rule 103 (rPar -> ) .)
    DIFFERENT       reduce using rule 103 (rPar -> ) .)
    EQUALTO         reduce using rule 103 (rPar -> ) .)
    AND             reduce using rule 103 (rPar -> ) .)
    OR              reduce using rule 103 (rPar -> ) .)
    ,               reduce using rule 103 (rPar -> ) .)
    ;               reduce using rule 103 (rPar -> ) .)
    )               reduce using rule 103 (rPar -> ) .)
    ]               reduce using rule 103 (rPar -> ) .)
    }               reduce using rule 103 (rPar -> ) .)


state 110

    (100) factor -> lPar expression rPar .

    *               reduce using rule 100 (factor -> lPar expression rPar .)
    /               reduce using rule 100 (factor -> lPar expression rPar .)
    %               reduce using rule 100 (factor -> lPar expression rPar .)
    +               reduce using rule 100 (factor -> lPar expression rPar .)
    -               reduce using rule 100 (factor -> lPar expression rPar .)
    LESS            reduce using rule 100 (factor -> lPar expression rPar .)
    GREATER         reduce using rule 100 (factor -> lPar expression rPar .)
    LESSEQUAL       reduce using rule 100 (factor -> lPar expression rPar .)
    GREATEREQUAL    reduce using rule 100 (factor -> lPar expression rPar .)
    DIFFERENT       reduce using rule 100 (factor -> lPar expression rPar .)
    EQUALTO         reduce using rule 100 (factor -> lPar expression rPar .)
    AND             reduce using rule 100 (factor -> lPar expression rPar .)
    OR              reduce using rule 100 (factor -> lPar expression rPar .)
    ,               reduce using rule 100 (factor -> lPar expression rPar .)
    ;               reduce using rule 100 (factor -> lPar expression rPar .)
    )               reduce using rule 100 (factor -> lPar expression rPar .)
    ]               reduce using rule 100 (factor -> lPar expression rPar .)
    }               reduce using rule 100 (factor -> lPar expression rPar .)


state 111

    (108) possibleIdCall -> ( parIn . )

    )               shift and go to state 140


state 112

    (38) parIn -> expression . moreParIn
    (40) moreParIn -> . , expression moreParIn
    (41) moreParIn -> .

    ,               shift and go to state 142
    )               reduce using rule 41 (moreParIn -> .)

    moreParIn                      shift and go to state 141

state 113

    (107) possibleIdCall -> [ expression . ]

    ]               shift and go to state 143


state 114

    (95) possibleFactors -> possibleFactorOp factor . possibleFactors
    (95) possibleFactors -> . possibleFactorOp factor possibleFactors
    (96) possibleFactors -> .
    (97) possibleFactorOp -> . *
    (98) possibleFactorOp -> . /
    (99) possibleFactorOp -> . %

    +               reduce using rule 96 (possibleFactors -> .)
    -               reduce using rule 96 (possibleFactors -> .)
    LESS            reduce using rule 96 (possibleFactors -> .)
    GREATER         reduce using rule 96 (possibleFactors -> .)
    LESSEQUAL       reduce using rule 96 (possibleFactors -> .)
    GREATEREQUAL    reduce using rule 96 (possibleFactors -> .)
    DIFFERENT       reduce using rule 96 (possibleFactors -> .)
    EQUALTO         reduce using rule 96 (possibleFactors -> .)
    AND             reduce using rule 96 (possibleFactors -> .)
    OR              reduce using rule 96 (possibleFactors -> .)
    ,               reduce using rule 96 (possibleFactors -> .)
    ;               reduce using rule 96 (possibleFactors -> .)
    )               reduce using rule 96 (possibleFactors -> .)
    ]               reduce using rule 96 (possibleFactors -> .)
    }               reduce using rule 96 (possibleFactors -> .)
    *               shift and go to state 92
    /               shift and go to state 94
    %               shift and go to state 91

    possibleFactors                shift and go to state 144
    possibleFactorOp               shift and go to state 95

state 115

    (116) inputPar -> STRING .

    )               reduce using rule 116 (inputPar -> STRING .)


state 116

    (115) input -> INPUT ( inputPar . )

    )               shift and go to state 145


state 117

    (87) possibleTerms -> possibleTermOp possibleSign . term possibleTerms
    (94) term -> . factor possibleFactors
    (100) factor -> . lPar expression rPar
    (101) factor -> . data
    (102) lPar -> . (
    (104) data -> . ID possibleIdCall
    (105) data -> . constant
    (106) data -> . input
    (110) constant -> . INT
    (111) constant -> . FLOAT
    (112) constant -> . TRUE
    (113) constant -> . FALSE
    (114) constant -> . STRING
    (115) input -> . INPUT ( inputPar )

    (               shift and go to state 71
    ID              shift and go to state 62
    INT             shift and go to state 69
    FLOAT           shift and go to state 70
    TRUE            shift and go to state 59
    FALSE           shift and go to state 68
    STRING          shift and go to state 65
    INPUT           shift and go to state 66

    lPar                           shift and go to state 60
    term                           shift and go to state 146
    constant                       shift and go to state 58
    data                           shift and go to state 61
    factor                         shift and go to state 63
    input                          shift and go to state 64

state 118

    (17) array -> type ID [ INT ] = { . expression sumExpCount moreExp }
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 147

state 119

    (23) nextArray -> , ID [ INT ] = . { expression sumExpCount moreExp }

    {               shift and go to state 148


state 120

    (24) function -> FUNCTION funcType ID ( par ) { . block RETURN returnType ; }
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 149
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 121

    (71) doWhile -> DO . { loopBlock } WHILE ( expression ) ;

    {               shift and go to state 150


state 122

    (44) block -> conditional . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    loop                           shift and go to state 137
    output                         shift and go to state 135
    assign                         shift and go to state 136
    block                          shift and go to state 151

state 123

    (68) loop -> doWhile .

    ID              reduce using rule 68 (loop -> doWhile .)
    IF              reduce using rule 68 (loop -> doWhile .)
    CONSOLE         reduce using rule 68 (loop -> doWhile .)
    INPUT           reduce using rule 68 (loop -> doWhile .)
    FOR             reduce using rule 68 (loop -> doWhile .)
    WHILE           reduce using rule 68 (loop -> doWhile .)
    DO              reduce using rule 68 (loop -> doWhile .)
    }               reduce using rule 68 (loop -> doWhile .)
    ARRAY           reduce using rule 68 (loop -> doWhile .)
    INTTYPE         reduce using rule 68 (loop -> doWhile .)
    FLOATTYPE       reduce using rule 68 (loop -> doWhile .)
    STRINGTYPE      reduce using rule 68 (loop -> doWhile .)
    BOOLTYPE        reduce using rule 68 (loop -> doWhile .)
    RETURN          reduce using rule 68 (loop -> doWhile .)


state 124

    (70) while -> WHILE . ( expression ) { loopBlock }

    (               shift and go to state 152


state 125

    (66) loop -> for .

    ID              reduce using rule 66 (loop -> for .)
    IF              reduce using rule 66 (loop -> for .)
    CONSOLE         reduce using rule 66 (loop -> for .)
    INPUT           reduce using rule 66 (loop -> for .)
    FOR             reduce using rule 66 (loop -> for .)
    WHILE           reduce using rule 66 (loop -> for .)
    DO              reduce using rule 66 (loop -> for .)
    }               reduce using rule 66 (loop -> for .)
    ARRAY           reduce using rule 66 (loop -> for .)
    INTTYPE         reduce using rule 66 (loop -> for .)
    FLOATTYPE       reduce using rule 66 (loop -> for .)
    STRINGTYPE      reduce using rule 66 (loop -> for .)
    BOOLTYPE        reduce using rule 66 (loop -> for .)
    RETURN          reduce using rule 66 (loop -> for .)


state 126

    (48) block -> input . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 153
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 127

    (42) block -> varDeclar . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 154
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 128

    (65) output -> CONSOLE . ( expression ) ;

    (               shift and go to state 155


state 129

    (69) for -> FOR . ( expression ; assign ) { loopBlock }

    (               shift and go to state 156


state 130

    (57) assign -> ID . possibleArray = expression
    (37) funcCall -> ID . ( parIn )
    (58) possibleArray -> . [ exp ]
    (59) possibleArray -> .

    (               shift and go to state 157
    [               shift and go to state 159
    =               reduce using rule 59 (possibleArray -> .)

    possibleArray                  shift and go to state 158

state 131

    (60) conditional -> IF . ( expression ) { block } possibleElif possibleElse

    (               shift and go to state 160


state 132

    (46) block -> funcCall . ; block

    ;               shift and go to state 161


state 133

    (67) loop -> while .

    ID              reduce using rule 67 (loop -> while .)
    IF              reduce using rule 67 (loop -> while .)
    CONSOLE         reduce using rule 67 (loop -> while .)
    INPUT           reduce using rule 67 (loop -> while .)
    FOR             reduce using rule 67 (loop -> while .)
    WHILE           reduce using rule 67 (loop -> while .)
    DO              reduce using rule 67 (loop -> while .)
    }               reduce using rule 67 (loop -> while .)
    ARRAY           reduce using rule 67 (loop -> while .)
    INTTYPE         reduce using rule 67 (loop -> while .)
    FLOATTYPE       reduce using rule 67 (loop -> while .)
    STRINGTYPE      reduce using rule 67 (loop -> while .)
    BOOLTYPE        reduce using rule 67 (loop -> while .)
    RETURN          reduce using rule 67 (loop -> while .)


state 134

    (32) main -> MAIN ( par ) { block . }

    }               shift and go to state 162


state 135

    (47) block -> output . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 163
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 136

    (43) block -> assign . ; block

    ;               shift and go to state 164


state 137

    (45) block -> loop . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 165
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 138

    (35) morePar -> , type . ID morePar

    ID              shift and go to state 166


state 139

    (10) moreVar -> , ID = expression . moreVar
    (10) moreVar -> . , ID = expression moreVar
    (11) moreVar -> .

    ,               shift and go to state 53
    ;               reduce using rule 11 (moreVar -> .)

    moreVar                        shift and go to state 167

state 140

    (108) possibleIdCall -> ( parIn ) .

    *               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    /               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    %               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    +               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    -               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    LESS            reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    GREATER         reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    LESSEQUAL       reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    GREATEREQUAL    reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    DIFFERENT       reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    EQUALTO         reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    AND             reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    OR              reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    ,               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    ;               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    )               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    ]               reduce using rule 108 (possibleIdCall -> ( parIn ) .)
    }               reduce using rule 108 (possibleIdCall -> ( parIn ) .)


state 141

    (38) parIn -> expression moreParIn .

    )               reduce using rule 38 (parIn -> expression moreParIn .)


state 142

    (40) moreParIn -> , . expression moreParIn
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 168

state 143

    (107) possibleIdCall -> [ expression ] .

    *               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    /               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    %               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    +               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    -               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    LESS            reduce using rule 107 (possibleIdCall -> [ expression ] .)
    GREATER         reduce using rule 107 (possibleIdCall -> [ expression ] .)
    LESSEQUAL       reduce using rule 107 (possibleIdCall -> [ expression ] .)
    GREATEREQUAL    reduce using rule 107 (possibleIdCall -> [ expression ] .)
    DIFFERENT       reduce using rule 107 (possibleIdCall -> [ expression ] .)
    EQUALTO         reduce using rule 107 (possibleIdCall -> [ expression ] .)
    AND             reduce using rule 107 (possibleIdCall -> [ expression ] .)
    OR              reduce using rule 107 (possibleIdCall -> [ expression ] .)
    ,               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    ;               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    )               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    ]               reduce using rule 107 (possibleIdCall -> [ expression ] .)
    }               reduce using rule 107 (possibleIdCall -> [ expression ] .)


state 144

    (95) possibleFactors -> possibleFactorOp factor possibleFactors .

    +               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    -               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESS            reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATER         reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    LESSEQUAL       reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    GREATEREQUAL    reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    DIFFERENT       reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    EQUALTO         reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    AND             reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    OR              reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ,               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ;               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    )               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    ]               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)
    }               reduce using rule 95 (possibleFactors -> possibleFactorOp factor possibleFactors .)


state 145

    (115) input -> INPUT ( inputPar ) .

    ID              reduce using rule 115 (input -> INPUT ( inputPar ) .)
    IF              reduce using rule 115 (input -> INPUT ( inputPar ) .)
    CONSOLE         reduce using rule 115 (input -> INPUT ( inputPar ) .)
    INPUT           reduce using rule 115 (input -> INPUT ( inputPar ) .)
    FOR             reduce using rule 115 (input -> INPUT ( inputPar ) .)
    WHILE           reduce using rule 115 (input -> INPUT ( inputPar ) .)
    DO              reduce using rule 115 (input -> INPUT ( inputPar ) .)
    }               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    *               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    /               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    %               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    +               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    -               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    LESS            reduce using rule 115 (input -> INPUT ( inputPar ) .)
    GREATER         reduce using rule 115 (input -> INPUT ( inputPar ) .)
    LESSEQUAL       reduce using rule 115 (input -> INPUT ( inputPar ) .)
    GREATEREQUAL    reduce using rule 115 (input -> INPUT ( inputPar ) .)
    DIFFERENT       reduce using rule 115 (input -> INPUT ( inputPar ) .)
    EQUALTO         reduce using rule 115 (input -> INPUT ( inputPar ) .)
    AND             reduce using rule 115 (input -> INPUT ( inputPar ) .)
    OR              reduce using rule 115 (input -> INPUT ( inputPar ) .)
    ,               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    ;               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    )               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    ]               reduce using rule 115 (input -> INPUT ( inputPar ) .)
    ARRAY           reduce using rule 115 (input -> INPUT ( inputPar ) .)
    INTTYPE         reduce using rule 115 (input -> INPUT ( inputPar ) .)
    FLOATTYPE       reduce using rule 115 (input -> INPUT ( inputPar ) .)
    STRINGTYPE      reduce using rule 115 (input -> INPUT ( inputPar ) .)
    BOOLTYPE        reduce using rule 115 (input -> INPUT ( inputPar ) .)
    RETURN          reduce using rule 115 (input -> INPUT ( inputPar ) .)


state 146

    (87) possibleTerms -> possibleTermOp possibleSign term . possibleTerms
    (87) possibleTerms -> . possibleTermOp possibleSign term possibleTerms
    (88) possibleTerms -> .
    (92) possibleTermOp -> . +
    (93) possibleTermOp -> . -

    LESS            reduce using rule 88 (possibleTerms -> .)
    GREATER         reduce using rule 88 (possibleTerms -> .)
    LESSEQUAL       reduce using rule 88 (possibleTerms -> .)
    GREATEREQUAL    reduce using rule 88 (possibleTerms -> .)
    DIFFERENT       reduce using rule 88 (possibleTerms -> .)
    EQUALTO         reduce using rule 88 (possibleTerms -> .)
    AND             reduce using rule 88 (possibleTerms -> .)
    OR              reduce using rule 88 (possibleTerms -> .)
    ,               reduce using rule 88 (possibleTerms -> .)
    ;               reduce using rule 88 (possibleTerms -> .)
    )               reduce using rule 88 (possibleTerms -> .)
    ]               reduce using rule 88 (possibleTerms -> .)
    }               reduce using rule 88 (possibleTerms -> .)
    +               shift and go to state 97
    -               shift and go to state 99

    possibleTermOp                 shift and go to state 100
    possibleTerms                  shift and go to state 169

state 147

    (17) array -> type ID [ INT ] = { expression . sumExpCount moreExp }
    (20) sumExpCount -> .

    ,               reduce using rule 20 (sumExpCount -> .)
    }               reduce using rule 20 (sumExpCount -> .)

    sumExpCount                    shift and go to state 170

state 148

    (23) nextArray -> , ID [ INT ] = { . expression sumExpCount moreExp }
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 171

state 149

    (24) function -> FUNCTION funcType ID ( par ) { block . RETURN returnType ; }

    RETURN          shift and go to state 172


state 150

    (71) doWhile -> DO { . loopBlock } WHILE ( expression ) ;
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 174
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 151

    (44) block -> conditional block .

    }               reduce using rule 44 (block -> conditional block .)
    RETURN          reduce using rule 44 (block -> conditional block .)


state 152

    (70) while -> WHILE ( . expression ) { loopBlock }
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 180

state 153

    (48) block -> input block .

    }               reduce using rule 48 (block -> input block .)
    RETURN          reduce using rule 48 (block -> input block .)


state 154

    (42) block -> varDeclar block .

    }               reduce using rule 42 (block -> varDeclar block .)
    RETURN          reduce using rule 42 (block -> varDeclar block .)


state 155

    (65) output -> CONSOLE ( . expression ) ;
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 181

state 156

    (69) for -> FOR ( . expression ; assign ) { loopBlock }
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 182

state 157

    (37) funcCall -> ID ( . parIn )
    (38) parIn -> . expression moreParIn
    (39) parIn -> .
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    )               reduce using rule 39 (parIn -> .)
    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    parIn                          shift and go to state 183
    exp                            shift and go to state 46
    expression                     shift and go to state 112

state 158

    (57) assign -> ID possibleArray . = expression

    =               shift and go to state 184


state 159

    (58) possibleArray -> [ . exp ]
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    possibleSign                   shift and go to state 45
    exp                            shift and go to state 185

state 160

    (60) conditional -> IF ( . expression ) { block } possibleElif possibleElse
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 186

state 161

    (46) block -> funcCall ; . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    loop                           shift and go to state 137
    output                         shift and go to state 135
    assign                         shift and go to state 136
    block                          shift and go to state 187

state 162

    (32) main -> MAIN ( par ) { block } .

    $end            reduce using rule 32 (main -> MAIN ( par ) { block } .)


state 163

    (47) block -> output block .

    }               reduce using rule 47 (block -> output block .)
    RETURN          reduce using rule 47 (block -> output block .)


state 164

    (43) block -> assign ; . block
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    RETURN          reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 188
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 165

    (45) block -> loop block .

    }               reduce using rule 45 (block -> loop block .)
    RETURN          reduce using rule 45 (block -> loop block .)


state 166

    (35) morePar -> , type ID . morePar
    (35) morePar -> . , type ID morePar
    (36) morePar -> .

    ,               shift and go to state 107
    )               reduce using rule 36 (morePar -> .)

    morePar                        shift and go to state 189

state 167

    (10) moreVar -> , ID = expression moreVar .

    ;               reduce using rule 10 (moreVar -> , ID = expression moreVar .)


state 168

    (40) moreParIn -> , expression . moreParIn
    (40) moreParIn -> . , expression moreParIn
    (41) moreParIn -> .

    ,               shift and go to state 142
    )               reduce using rule 41 (moreParIn -> .)

    moreParIn                      shift and go to state 190

state 169

    (87) possibleTerms -> possibleTermOp possibleSign term possibleTerms .

    LESS            reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    GREATER         reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    LESSEQUAL       reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    GREATEREQUAL    reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    DIFFERENT       reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    EQUALTO         reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    AND             reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    OR              reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    ,               reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    ;               reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    )               reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    ]               reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)
    }               reduce using rule 87 (possibleTerms -> possibleTermOp possibleSign term possibleTerms .)


state 170

    (17) array -> type ID [ INT ] = { expression sumExpCount . moreExp }
    (18) moreExp -> . , expression sumExpCount moreExp
    (19) moreExp -> .

    ,               shift and go to state 191
    }               reduce using rule 19 (moreExp -> .)

    moreExp                        shift and go to state 192

state 171

    (23) nextArray -> , ID [ INT ] = { expression . sumExpCount moreExp }
    (20) sumExpCount -> .

    ,               reduce using rule 20 (sumExpCount -> .)
    }               reduce using rule 20 (sumExpCount -> .)

    sumExpCount                    shift and go to state 193

state 172

    (24) function -> FUNCTION funcType ID ( par ) { block RETURN . returnType ; }
    (30) returnType -> . expression
    (31) returnType -> . VOID
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    VOID            shift and go to state 194
    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    returnType                     shift and go to state 195
    expression                     shift and go to state 196

state 173

    (51) loopBlock -> conditional . loopBlock
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 197
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 174

    (71) doWhile -> DO { loopBlock . } WHILE ( expression ) ;

    }               shift and go to state 198


state 175

    (55) loopBlock -> input . loopBlock
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 199
    doWhile                        shift and go to state 123
    output                         shift and go to state 178
    input                          shift and go to state 175
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 176

    (53) loopBlock -> funcCall . ; loopBlock

    ;               shift and go to state 200


state 177

    (52) loopBlock -> loop . loopBlock
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 201
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 178

    (54) loopBlock -> output . loopBlock
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 202
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 179

    (50) loopBlock -> assign . ; loopBlock

    ;               shift and go to state 203


state 180

    (70) while -> WHILE ( expression . ) { loopBlock }

    )               shift and go to state 204


state 181

    (65) output -> CONSOLE ( expression . ) ;

    )               shift and go to state 205


state 182

    (69) for -> FOR ( expression . ; assign ) { loopBlock }

    ;               shift and go to state 206


state 183

    (37) funcCall -> ID ( parIn . )

    )               shift and go to state 207


state 184

    (57) assign -> ID possibleArray = . expression
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 208

state 185

    (58) possibleArray -> [ exp . ]

    ]               shift and go to state 209


state 186

    (60) conditional -> IF ( expression . ) { block } possibleElif possibleElse

    )               shift and go to state 210


state 187

    (46) block -> funcCall ; block .

    }               reduce using rule 46 (block -> funcCall ; block .)
    RETURN          reduce using rule 46 (block -> funcCall ; block .)


state 188

    (43) block -> assign ; block .

    }               reduce using rule 43 (block -> assign ; block .)
    RETURN          reduce using rule 43 (block -> assign ; block .)


state 189

    (35) morePar -> , type ID morePar .

    )               reduce using rule 35 (morePar -> , type ID morePar .)


state 190

    (40) moreParIn -> , expression moreParIn .

    )               reduce using rule 40 (moreParIn -> , expression moreParIn .)


state 191

    (18) moreExp -> , . expression sumExpCount moreExp
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 211

state 192

    (17) array -> type ID [ INT ] = { expression sumExpCount moreExp . }

    }               shift and go to state 212


state 193

    (23) nextArray -> , ID [ INT ] = { expression sumExpCount . moreExp }
    (18) moreExp -> . , expression sumExpCount moreExp
    (19) moreExp -> .

    ,               shift and go to state 191
    }               reduce using rule 19 (moreExp -> .)

    moreExp                        shift and go to state 213

state 194

    (31) returnType -> VOID .

    ;               reduce using rule 31 (returnType -> VOID .)


state 195

    (24) function -> FUNCTION funcType ID ( par ) { block RETURN returnType . ; }

    ;               shift and go to state 214


state 196

    (30) returnType -> expression .

    ;               reduce using rule 30 (returnType -> expression .)


state 197

    (51) loopBlock -> conditional loopBlock .

    }               reduce using rule 51 (loopBlock -> conditional loopBlock .)


state 198

    (71) doWhile -> DO { loopBlock } . WHILE ( expression ) ;

    WHILE           shift and go to state 215


state 199

    (55) loopBlock -> input loopBlock .

    }               reduce using rule 55 (loopBlock -> input loopBlock .)


state 200

    (53) loopBlock -> funcCall ; . loopBlock
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 216
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 201

    (52) loopBlock -> loop loopBlock .

    }               reduce using rule 52 (loopBlock -> loop loopBlock .)


state 202

    (54) loopBlock -> output loopBlock .

    }               reduce using rule 54 (loopBlock -> output loopBlock .)


state 203

    (50) loopBlock -> assign ; . loopBlock
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 217
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 204

    (70) while -> WHILE ( expression ) . { loopBlock }

    {               shift and go to state 218


state 205

    (65) output -> CONSOLE ( expression ) . ;

    ;               shift and go to state 219


state 206

    (69) for -> FOR ( expression ; . assign ) { loopBlock }
    (57) assign -> . ID possibleArray = expression

    ID              shift and go to state 220

    assign                         shift and go to state 221

state 207

    (37) funcCall -> ID ( parIn ) .

    ;               reduce using rule 37 (funcCall -> ID ( parIn ) .)


state 208

    (57) assign -> ID possibleArray = expression .

    ;               reduce using rule 57 (assign -> ID possibleArray = expression .)
    )               reduce using rule 57 (assign -> ID possibleArray = expression .)


state 209

    (58) possibleArray -> [ exp ] .

    =               reduce using rule 58 (possibleArray -> [ exp ] .)


state 210

    (60) conditional -> IF ( expression ) . { block } possibleElif possibleElse

    {               shift and go to state 222


state 211

    (18) moreExp -> , expression . sumExpCount moreExp
    (20) sumExpCount -> .

    ,               reduce using rule 20 (sumExpCount -> .)
    }               reduce using rule 20 (sumExpCount -> .)

    sumExpCount                    shift and go to state 223

state 212

    (17) array -> type ID [ INT ] = { expression sumExpCount moreExp } .

    ,               reduce using rule 17 (array -> type ID [ INT ] = { expression sumExpCount moreExp } .)
    ;               reduce using rule 17 (array -> type ID [ INT ] = { expression sumExpCount moreExp } .)


state 213

    (23) nextArray -> , ID [ INT ] = { expression sumExpCount moreExp . }

    }               shift and go to state 224


state 214

    (24) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; . }

    }               shift and go to state 225


state 215

    (71) doWhile -> DO { loopBlock } WHILE . ( expression ) ;

    (               shift and go to state 226


state 216

    (53) loopBlock -> funcCall ; loopBlock .

    }               reduce using rule 53 (loopBlock -> funcCall ; loopBlock .)


state 217

    (50) loopBlock -> assign ; loopBlock .

    }               reduce using rule 50 (loopBlock -> assign ; loopBlock .)


state 218

    (70) while -> WHILE ( expression ) { . loopBlock }
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 227
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 219

    (65) output -> CONSOLE ( expression ) ; .

    ARRAY           reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    ID              reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    IF              reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    CONSOLE         reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    INPUT           reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    FOR             reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    WHILE           reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    DO              reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    INTTYPE         reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    FLOATTYPE       reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    STRINGTYPE      reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    BOOLTYPE        reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    }               reduce using rule 65 (output -> CONSOLE ( expression ) ; .)
    RETURN          reduce using rule 65 (output -> CONSOLE ( expression ) ; .)


state 220

    (57) assign -> ID . possibleArray = expression
    (58) possibleArray -> . [ exp ]
    (59) possibleArray -> .

    [               shift and go to state 159
    =               reduce using rule 59 (possibleArray -> .)

    possibleArray                  shift and go to state 158

state 221

    (69) for -> FOR ( expression ; assign . ) { loopBlock }

    )               shift and go to state 228


state 222

    (60) conditional -> IF ( expression ) { . block } possibleElif possibleElse
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    vars                           shift and go to state 4
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 229
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 223

    (18) moreExp -> , expression sumExpCount . moreExp
    (18) moreExp -> . , expression sumExpCount moreExp
    (19) moreExp -> .

    ,               shift and go to state 191
    }               reduce using rule 19 (moreExp -> .)

    moreExp                        shift and go to state 230

state 224

    (23) nextArray -> , ID [ INT ] = { expression sumExpCount moreExp } .

    ,               reduce using rule 23 (nextArray -> , ID [ INT ] = { expression sumExpCount moreExp } .)
    ;               reduce using rule 23 (nextArray -> , ID [ INT ] = { expression sumExpCount moreExp } .)


state 225

    (24) function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .

    FUNCTION        reduce using rule 24 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)
    MAIN            reduce using rule 24 (function -> FUNCTION funcType ID ( par ) { block RETURN returnType ; } .)


state 226

    (71) doWhile -> DO { loopBlock } WHILE ( . expression ) ;
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 231

state 227

    (70) while -> WHILE ( expression ) { loopBlock . }

    }               shift and go to state 232


state 228

    (69) for -> FOR ( expression ; assign ) . { loopBlock }

    {               shift and go to state 233


state 229

    (60) conditional -> IF ( expression ) { block . } possibleElif possibleElse

    }               shift and go to state 234


state 230

    (18) moreExp -> , expression sumExpCount moreExp .

    }               reduce using rule 18 (moreExp -> , expression sumExpCount moreExp .)


state 231

    (71) doWhile -> DO { loopBlock } WHILE ( expression . ) ;

    )               shift and go to state 235


state 232

    (70) while -> WHILE ( expression ) { loopBlock } .

    ARRAY           reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    ID              reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    IF              reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    CONSOLE         reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    INPUT           reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    FOR             reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    WHILE           reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    DO              reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    INTTYPE         reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    FLOATTYPE       reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    STRINGTYPE      reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    BOOLTYPE        reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    }               reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)
    RETURN          reduce using rule 70 (while -> WHILE ( expression ) { loopBlock } .)


state 233

    (69) for -> FOR ( expression ; assign ) { . loopBlock }
    (50) loopBlock -> . assign ; loopBlock
    (51) loopBlock -> . conditional loopBlock
    (52) loopBlock -> . loop loopBlock
    (53) loopBlock -> . funcCall ; loopBlock
    (54) loopBlock -> . output loopBlock
    (55) loopBlock -> . input loopBlock
    (56) loopBlock -> .
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;

    }               reduce using rule 56 (loopBlock -> .)
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121

    funcCall                       shift and go to state 176
    conditional                    shift and go to state 173
    while                          shift and go to state 133
    for                            shift and go to state 125
    loopBlock                      shift and go to state 236
    doWhile                        shift and go to state 123
    input                          shift and go to state 175
    output                         shift and go to state 178
    assign                         shift and go to state 179
    loop                           shift and go to state 177

state 234

    (60) conditional -> IF ( expression ) { block } . possibleElif possibleElse
    (61) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (62) possibleElif -> .

    ELIF            shift and go to state 237
    ELSE            reduce using rule 62 (possibleElif -> .)
    ARRAY           reduce using rule 62 (possibleElif -> .)
    ID              reduce using rule 62 (possibleElif -> .)
    IF              reduce using rule 62 (possibleElif -> .)
    CONSOLE         reduce using rule 62 (possibleElif -> .)
    INPUT           reduce using rule 62 (possibleElif -> .)
    FOR             reduce using rule 62 (possibleElif -> .)
    WHILE           reduce using rule 62 (possibleElif -> .)
    DO              reduce using rule 62 (possibleElif -> .)
    INTTYPE         reduce using rule 62 (possibleElif -> .)
    FLOATTYPE       reduce using rule 62 (possibleElif -> .)
    STRINGTYPE      reduce using rule 62 (possibleElif -> .)
    BOOLTYPE        reduce using rule 62 (possibleElif -> .)
    }               reduce using rule 62 (possibleElif -> .)
    RETURN          reduce using rule 62 (possibleElif -> .)

    possibleElif                   shift and go to state 238

state 235

    (71) doWhile -> DO { loopBlock } WHILE ( expression ) . ;

    ;               shift and go to state 239


state 236

    (69) for -> FOR ( expression ; assign ) { loopBlock . }

    }               shift and go to state 240


state 237

    (61) possibleElif -> ELIF . ( expression ) { block } possibleElif

    (               shift and go to state 241


state 238

    (60) conditional -> IF ( expression ) { block } possibleElif . possibleElse
    (63) possibleElse -> . ELSE { block }
    (64) possibleElse -> .

    ELSE            shift and go to state 243
    ARRAY           reduce using rule 64 (possibleElse -> .)
    ID              reduce using rule 64 (possibleElse -> .)
    IF              reduce using rule 64 (possibleElse -> .)
    CONSOLE         reduce using rule 64 (possibleElse -> .)
    INPUT           reduce using rule 64 (possibleElse -> .)
    FOR             reduce using rule 64 (possibleElse -> .)
    WHILE           reduce using rule 64 (possibleElse -> .)
    DO              reduce using rule 64 (possibleElse -> .)
    INTTYPE         reduce using rule 64 (possibleElse -> .)
    FLOATTYPE       reduce using rule 64 (possibleElse -> .)
    STRINGTYPE      reduce using rule 64 (possibleElse -> .)
    BOOLTYPE        reduce using rule 64 (possibleElse -> .)
    }               reduce using rule 64 (possibleElse -> .)
    RETURN          reduce using rule 64 (possibleElse -> .)

    possibleElse                   shift and go to state 242

state 239

    (71) doWhile -> DO { loopBlock } WHILE ( expression ) ; .

    ID              reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    IF              reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    CONSOLE         reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INPUT           reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FOR             reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    WHILE           reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    DO              reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    }               reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    ARRAY           reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    INTTYPE         reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    FLOATTYPE       reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    STRINGTYPE      reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    BOOLTYPE        reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)
    RETURN          reduce using rule 71 (doWhile -> DO { loopBlock } WHILE ( expression ) ; .)


state 240

    (69) for -> FOR ( expression ; assign ) { loopBlock } .

    ARRAY           reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    ID              reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    IF              reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    CONSOLE         reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INPUT           reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FOR             reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    WHILE           reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    DO              reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    INTTYPE         reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    FLOATTYPE       reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    STRINGTYPE      reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    BOOLTYPE        reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    }               reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)
    RETURN          reduce using rule 69 (for -> FOR ( expression ; assign ) { loopBlock } .)


state 241

    (61) possibleElif -> ELIF ( . expression ) { block } possibleElif
    (72) expression -> . higherExp possibleHigherExp
    (77) higherExp -> . exp possibleExp
    (86) exp -> . possibleSign term possibleTerms
    (89) possibleSign -> . +
    (90) possibleSign -> . -
    (91) possibleSign -> .

    +               shift and go to state 42
    -               shift and go to state 43
    (               reduce using rule 91 (possibleSign -> .)
    ID              reduce using rule 91 (possibleSign -> .)
    INT             reduce using rule 91 (possibleSign -> .)
    FLOAT           reduce using rule 91 (possibleSign -> .)
    TRUE            reduce using rule 91 (possibleSign -> .)
    FALSE           reduce using rule 91 (possibleSign -> .)
    STRING          reduce using rule 91 (possibleSign -> .)
    INPUT           reduce using rule 91 (possibleSign -> .)

    higherExp                      shift and go to state 44
    possibleSign                   shift and go to state 45
    exp                            shift and go to state 46
    expression                     shift and go to state 244

state 242

    (60) conditional -> IF ( expression ) { block } possibleElif possibleElse .

    ID              reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    IF              reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    CONSOLE         reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INPUT           reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FOR             reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    WHILE           reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    DO              reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    }               reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    ARRAY           reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    INTTYPE         reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    FLOATTYPE       reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    STRINGTYPE      reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    BOOLTYPE        reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)
    RETURN          reduce using rule 60 (conditional -> IF ( expression ) { block } possibleElif possibleElse .)


state 243

    (63) possibleElse -> ELSE . { block }

    {               shift and go to state 245


state 244

    (61) possibleElif -> ELIF ( expression . ) { block } possibleElif

    )               shift and go to state 246


state 245

    (63) possibleElse -> ELSE { . block }
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 247
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 246

    (61) possibleElif -> ELIF ( expression ) . { block } possibleElif

    {               shift and go to state 248


state 247

    (63) possibleElse -> ELSE { block . }

    }               shift and go to state 249


state 248

    (61) possibleElif -> ELIF ( expression ) { . block } possibleElif
    (42) block -> . varDeclar block
    (43) block -> . assign ; block
    (44) block -> . conditional block
    (45) block -> . loop block
    (46) block -> . funcCall ; block
    (47) block -> . output block
    (48) block -> . input block
    (49) block -> .
    (7) varDeclar -> . vars ;
    (8) varDeclar -> . ARRAY arrays ;
    (57) assign -> . ID possibleArray = expression
    (60) conditional -> . IF ( expression ) { block } possibleElif possibleElse
    (66) loop -> . for
    (67) loop -> . while
    (68) loop -> . doWhile
    (37) funcCall -> . ID ( parIn )
    (65) output -> . CONSOLE ( expression ) ;
    (115) input -> . INPUT ( inputPar )
    (9) vars -> . type ID = expression moreVar
    (69) for -> . FOR ( expression ; assign ) { loopBlock }
    (70) while -> . WHILE ( expression ) { loopBlock }
    (71) doWhile -> . DO { loopBlock } WHILE ( expression ) ;
    (12) type -> . INTTYPE
    (13) type -> . FLOATTYPE
    (14) type -> . STRINGTYPE
    (15) type -> . BOOLTYPE

    }               reduce using rule 49 (block -> .)
    ARRAY           shift and go to state 6
    ID              shift and go to state 130
    IF              shift and go to state 131
    CONSOLE         shift and go to state 128
    INPUT           shift and go to state 66
    FOR             shift and go to state 129
    WHILE           shift and go to state 124
    DO              shift and go to state 121
    INTTYPE         shift and go to state 3
    FLOATTYPE       shift and go to state 5
    STRINGTYPE      shift and go to state 2
    BOOLTYPE        shift and go to state 1

    vars                           shift and go to state 4
    conditional                    shift and go to state 122
    doWhile                        shift and go to state 123
    for                            shift and go to state 125
    input                          shift and go to state 126
    varDeclar                      shift and go to state 127
    type                           shift and go to state 10
    funcCall                       shift and go to state 132
    while                          shift and go to state 133
    block                          shift and go to state 250
    output                         shift and go to state 135
    assign                         shift and go to state 136
    loop                           shift and go to state 137

state 249

    (63) possibleElse -> ELSE { block } .

    ARRAY           reduce using rule 63 (possibleElse -> ELSE { block } .)
    ID              reduce using rule 63 (possibleElse -> ELSE { block } .)
    IF              reduce using rule 63 (possibleElse -> ELSE { block } .)
    CONSOLE         reduce using rule 63 (possibleElse -> ELSE { block } .)
    INPUT           reduce using rule 63 (possibleElse -> ELSE { block } .)
    FOR             reduce using rule 63 (possibleElse -> ELSE { block } .)
    WHILE           reduce using rule 63 (possibleElse -> ELSE { block } .)
    DO              reduce using rule 63 (possibleElse -> ELSE { block } .)
    INTTYPE         reduce using rule 63 (possibleElse -> ELSE { block } .)
    FLOATTYPE       reduce using rule 63 (possibleElse -> ELSE { block } .)
    STRINGTYPE      reduce using rule 63 (possibleElse -> ELSE { block } .)
    BOOLTYPE        reduce using rule 63 (possibleElse -> ELSE { block } .)
    }               reduce using rule 63 (possibleElse -> ELSE { block } .)
    RETURN          reduce using rule 63 (possibleElse -> ELSE { block } .)


state 250

    (61) possibleElif -> ELIF ( expression ) { block . } possibleElif

    }               shift and go to state 251


state 251

    (61) possibleElif -> ELIF ( expression ) { block } . possibleElif
    (61) possibleElif -> . ELIF ( expression ) { block } possibleElif
    (62) possibleElif -> .

    ELIF            shift and go to state 237
    ELSE            reduce using rule 62 (possibleElif -> .)
    ARRAY           reduce using rule 62 (possibleElif -> .)
    ID              reduce using rule 62 (possibleElif -> .)
    IF              reduce using rule 62 (possibleElif -> .)
    CONSOLE         reduce using rule 62 (possibleElif -> .)
    INPUT           reduce using rule 62 (possibleElif -> .)
    FOR             reduce using rule 62 (possibleElif -> .)
    WHILE           reduce using rule 62 (possibleElif -> .)
    DO              reduce using rule 62 (possibleElif -> .)
    INTTYPE         reduce using rule 62 (possibleElif -> .)
    FLOATTYPE       reduce using rule 62 (possibleElif -> .)
    STRINGTYPE      reduce using rule 62 (possibleElif -> .)
    BOOLTYPE        reduce using rule 62 (possibleElif -> .)
    }               reduce using rule 62 (possibleElif -> .)
    RETURN          reduce using rule 62 (possibleElif -> .)

    possibleElif                   shift and go to state 252

state 252

    (61) possibleElif -> ELIF ( expression ) { block } possibleElif .

    ELSE            reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ARRAY           reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    ID              reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    IF              reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    CONSOLE         reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INPUT           reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FOR             reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    WHILE           reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    DO              reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    INTTYPE         reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    FLOATTYPE       reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    STRINGTYPE      reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    BOOLTYPE        reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    }               reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)
    RETURN          reduce using rule 61 (possibleElif -> ELIF ( expression ) { block } possibleElif .)

